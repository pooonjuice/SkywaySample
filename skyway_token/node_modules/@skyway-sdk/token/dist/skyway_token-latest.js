"use strict";
var skyway_token = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // shims/process.js
  var init_process = __esm({
    "shims/process.js"() {
      "use strict";
    }
  });

  // ../../node_modules/jsrsasign/lib/jsrsasign.js
  var require_jsrsasign = __commonJS({
    "../../node_modules/jsrsasign/lib/jsrsasign.js"(exports) {
      init_process();
      var navigator = {};
      navigator.userAgent = false;
      var window2 = {};
      var CryptoJS = CryptoJS || function(e2, g) {
        var a = {};
        var b = a.lib = {};
        var j = b.Base = function() {
          function n2() {
          }
          return { extend: function(p) {
            n2.prototype = this;
            var o2 = new n2();
            if (p) {
              o2.mixIn(p);
            }
            if (!o2.hasOwnProperty("init")) {
              o2.init = function() {
                o2.$super.init.apply(this, arguments);
              };
            }
            o2.init.prototype = o2;
            o2.$super = this;
            return o2;
          }, create: function() {
            var o2 = this.extend();
            o2.init.apply(o2, arguments);
            return o2;
          }, init: function() {
          }, mixIn: function(p) {
            for (var o2 in p) {
              if (p.hasOwnProperty(o2)) {
                this[o2] = p[o2];
              }
            }
            if (p.hasOwnProperty("toString")) {
              this.toString = p.toString;
            }
          }, clone: function() {
            return this.init.prototype.extend(this);
          } };
        }();
        var l = b.WordArray = j.extend({ init: function(o2, n2) {
          o2 = this.words = o2 || [];
          if (n2 != g) {
            this.sigBytes = n2;
          } else {
            this.sigBytes = o2.length * 4;
          }
        }, toString: function(n2) {
          return (n2 || h).stringify(this);
        }, concat: function(t3) {
          var q = this.words;
          var p = t3.words;
          var n2 = this.sigBytes;
          var s = t3.sigBytes;
          this.clamp();
          if (n2 % 4) {
            for (var r2 = 0; r2 < s; r2++) {
              var o2 = p[r2 >>> 2] >>> 24 - r2 % 4 * 8 & 255;
              q[n2 + r2 >>> 2] |= o2 << 24 - (n2 + r2) % 4 * 8;
            }
          } else {
            for (var r2 = 0; r2 < s; r2 += 4) {
              q[n2 + r2 >>> 2] = p[r2 >>> 2];
            }
          }
          this.sigBytes += s;
          return this;
        }, clamp: function() {
          var o2 = this.words;
          var n2 = this.sigBytes;
          o2[n2 >>> 2] &= 4294967295 << 32 - n2 % 4 * 8;
          o2.length = e2.ceil(n2 / 4);
        }, clone: function() {
          var n2 = j.clone.call(this);
          n2.words = this.words.slice(0);
          return n2;
        }, random: function(p) {
          var o2 = [];
          for (var n2 = 0; n2 < p; n2 += 4) {
            o2.push(e2.random() * 4294967296 | 0);
          }
          return new l.init(o2, p);
        } });
        var m = a.enc = {};
        var h = m.Hex = { stringify: function(p) {
          var r2 = p.words;
          var o2 = p.sigBytes;
          var q = [];
          for (var n2 = 0; n2 < o2; n2++) {
            var s = r2[n2 >>> 2] >>> 24 - n2 % 4 * 8 & 255;
            q.push((s >>> 4).toString(16));
            q.push((s & 15).toString(16));
          }
          return q.join("");
        }, parse: function(p) {
          var n2 = p.length;
          var q = [];
          for (var o2 = 0; o2 < n2; o2 += 2) {
            q[o2 >>> 3] |= parseInt(p.substr(o2, 2), 16) << 24 - o2 % 8 * 4;
          }
          return new l.init(q, n2 / 2);
        } };
        var d = m.Latin1 = { stringify: function(q) {
          var r2 = q.words;
          var p = q.sigBytes;
          var n2 = [];
          for (var o2 = 0; o2 < p; o2++) {
            var s = r2[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
            n2.push(String.fromCharCode(s));
          }
          return n2.join("");
        }, parse: function(p) {
          var n2 = p.length;
          var q = [];
          for (var o2 = 0; o2 < n2; o2++) {
            q[o2 >>> 2] |= (p.charCodeAt(o2) & 255) << 24 - o2 % 4 * 8;
          }
          return new l.init(q, n2);
        } };
        var c = m.Utf8 = { stringify: function(n2) {
          try {
            return decodeURIComponent(escape(d.stringify(n2)));
          } catch (o2) {
            throw new Error("Malformed UTF-8 data");
          }
        }, parse: function(n2) {
          return d.parse(unescape(encodeURIComponent(n2)));
        } };
        var i = b.BufferedBlockAlgorithm = j.extend({ reset: function() {
          this._data = new l.init();
          this._nDataBytes = 0;
        }, _append: function(n2) {
          if (typeof n2 == "string") {
            n2 = c.parse(n2);
          }
          this._data.concat(n2);
          this._nDataBytes += n2.sigBytes;
        }, _process: function(w) {
          var q = this._data;
          var x = q.words;
          var n2 = q.sigBytes;
          var t3 = this.blockSize;
          var v = t3 * 4;
          var u = n2 / v;
          if (w) {
            u = e2.ceil(u);
          } else {
            u = e2.max((u | 0) - this._minBufferSize, 0);
          }
          var s = u * t3;
          var r2 = e2.min(s * 4, n2);
          if (s) {
            for (var p = 0; p < s; p += t3) {
              this._doProcessBlock(x, p);
            }
            var o2 = x.splice(0, s);
            q.sigBytes -= r2;
          }
          return new l.init(o2, r2);
        }, clone: function() {
          var n2 = j.clone.call(this);
          n2._data = this._data.clone();
          return n2;
        }, _minBufferSize: 0 });
        var f = b.Hasher = i.extend({ cfg: j.extend(), init: function(n2) {
          this.cfg = this.cfg.extend(n2);
          this.reset();
        }, reset: function() {
          i.reset.call(this);
          this._doReset();
        }, update: function(n2) {
          this._append(n2);
          this._process();
          return this;
        }, finalize: function(n2) {
          if (n2) {
            this._append(n2);
          }
          var o2 = this._doFinalize();
          return o2;
        }, blockSize: 512 / 32, _createHelper: function(n2) {
          return function(p, o2) {
            return new n2.init(o2).finalize(p);
          };
        }, _createHmacHelper: function(n2) {
          return function(p, o2) {
            return new k.HMAC.init(n2, o2).finalize(p);
          };
        } });
        var k = a.algo = {};
        return a;
      }(Math);
      (function(g) {
        var a = CryptoJS, f = a.lib, e2 = f.Base, h = f.WordArray, a = a.x64 = {};
        a.Word = e2.extend({ init: function(b, c) {
          this.high = b;
          this.low = c;
        } });
        a.WordArray = e2.extend({ init: function(b, c) {
          b = this.words = b || [];
          this.sigBytes = c != g ? c : 8 * b.length;
        }, toX32: function() {
          for (var b = this.words, c = b.length, a2 = [], d = 0; d < c; d++) {
            var e3 = b[d];
            a2.push(e3.high);
            a2.push(e3.low);
          }
          return h.create(a2, this.sigBytes);
        }, clone: function() {
          for (var b = e2.clone.call(this), c = b.words = this.words.slice(0), a2 = c.length, d = 0; d < a2; d++)
            c[d] = c[d].clone();
          return b;
        } });
      })();
      CryptoJS.lib.Cipher || function(u) {
        var g = CryptoJS, f = g.lib, k = f.Base, l = f.WordArray, q = f.BufferedBlockAlgorithm, r2 = g.enc.Base64, v = g.algo.EvpKDF, n2 = f.Cipher = q.extend({ cfg: k.extend(), createEncryptor: function(a, b) {
          return this.create(this._ENC_XFORM_MODE, a, b);
        }, createDecryptor: function(a, b) {
          return this.create(this._DEC_XFORM_MODE, a, b);
        }, init: function(a, b, c) {
          this.cfg = this.cfg.extend(c);
          this._xformMode = a;
          this._key = b;
          this.reset();
        }, reset: function() {
          q.reset.call(this);
          this._doReset();
        }, process: function(a) {
          this._append(a);
          return this._process();
        }, finalize: function(a) {
          a && this._append(a);
          return this._doFinalize();
        }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function(a) {
          return { encrypt: function(b, c, d) {
            return ("string" == typeof c ? s : j).encrypt(a, b, c, d);
          }, decrypt: function(b, c, d) {
            return ("string" == typeof c ? s : j).decrypt(a, b, c, d);
          } };
        } });
        f.StreamCipher = n2.extend({ _doFinalize: function() {
          return this._process(true);
        }, blockSize: 1 });
        var m = g.mode = {}, t3 = function(a, b, c) {
          var d = this._iv;
          d ? this._iv = u : d = this._prevBlock;
          for (var e2 = 0; e2 < c; e2++)
            a[b + e2] ^= d[e2];
        }, h = (f.BlockCipherMode = k.extend({ createEncryptor: function(a, b) {
          return this.Encryptor.create(a, b);
        }, createDecryptor: function(a, b) {
          return this.Decryptor.create(a, b);
        }, init: function(a, b) {
          this._cipher = a;
          this._iv = b;
        } })).extend();
        h.Encryptor = h.extend({ processBlock: function(a, b) {
          var c = this._cipher, d = c.blockSize;
          t3.call(this, a, b, d);
          c.encryptBlock(a, b);
          this._prevBlock = a.slice(b, b + d);
        } });
        h.Decryptor = h.extend({ processBlock: function(a, b) {
          var c = this._cipher, d = c.blockSize, e2 = a.slice(b, b + d);
          c.decryptBlock(
            a,
            b
          );
          t3.call(this, a, b, d);
          this._prevBlock = e2;
        } });
        m = m.CBC = h;
        h = (g.pad = {}).Pkcs7 = { pad: function(a, b) {
          for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, e2 = [], f2 = 0; f2 < c; f2 += 4)
            e2.push(d);
          c = l.create(e2, c);
          a.concat(c);
        }, unpad: function(a) {
          a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;
        } };
        f.BlockCipher = n2.extend({ cfg: n2.cfg.extend({ mode: m, padding: h }), reset: function() {
          n2.reset.call(this);
          var a = this.cfg, b = a.iv, a = a.mode;
          if (this._xformMode == this._ENC_XFORM_MODE)
            var c = a.createEncryptor;
          else
            c = a.createDecryptor, this._minBufferSize = 1;
          this._mode = c.call(a, this, b && b.words);
        }, _doProcessBlock: function(a, b) {
          this._mode.processBlock(a, b);
        }, _doFinalize: function() {
          var a = this.cfg.padding;
          if (this._xformMode == this._ENC_XFORM_MODE) {
            a.pad(this._data, this.blockSize);
            var b = this._process(true);
          } else
            b = this._process(true), a.unpad(b);
          return b;
        }, blockSize: 4 });
        var p = f.CipherParams = k.extend({ init: function(a) {
          this.mixIn(a);
        }, toString: function(a) {
          return (a || this.formatter).stringify(this);
        } }), m = (g.format = {}).OpenSSL = { stringify: function(a) {
          var b = a.ciphertext;
          a = a.salt;
          return (a ? l.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r2);
        }, parse: function(a) {
          a = r2.parse(a);
          var b = a.words;
          if (1398893684 == b[0] && 1701076831 == b[1]) {
            var c = l.create(b.slice(2, 4));
            b.splice(0, 4);
            a.sigBytes -= 16;
          }
          return p.create({ ciphertext: a, salt: c });
        } }, j = f.SerializableCipher = k.extend({ cfg: k.extend({ format: m }), encrypt: function(a, b, c, d) {
          d = this.cfg.extend(d);
          var e2 = a.createEncryptor(c, d);
          b = e2.finalize(b);
          e2 = e2.cfg;
          return p.create({
            ciphertext: b,
            key: c,
            iv: e2.iv,
            algorithm: a,
            mode: e2.mode,
            padding: e2.padding,
            blockSize: a.blockSize,
            formatter: d.format
          });
        }, decrypt: function(a, b, c, d) {
          d = this.cfg.extend(d);
          b = this._parse(b, d.format);
          return a.createDecryptor(c, d).finalize(b.ciphertext);
        }, _parse: function(a, b) {
          return "string" == typeof a ? b.parse(a, this) : a;
        } }), g = (g.kdf = {}).OpenSSL = { execute: function(a, b, c, d) {
          d || (d = l.random(8));
          a = v.create({ keySize: b + c }).compute(a, d);
          c = l.create(a.words.slice(b), 4 * c);
          a.sigBytes = 4 * b;
          return p.create({ key: a, iv: c, salt: d });
        } }, s = f.PasswordBasedCipher = j.extend({ cfg: j.cfg.extend({ kdf: g }), encrypt: function(a, b, c, d) {
          d = this.cfg.extend(d);
          c = d.kdf.execute(c, a.keySize, a.ivSize);
          d.iv = c.iv;
          a = j.encrypt.call(this, a, b, c.key, d);
          a.mixIn(c);
          return a;
        }, decrypt: function(a, b, c, d) {
          d = this.cfg.extend(d);
          b = this._parse(b, d.format);
          c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt);
          d.iv = c.iv;
          return j.decrypt.call(this, a, b, c.key, d);
        } });
      }();
      (function() {
        for (var q = CryptoJS, x = q.lib.BlockCipher, r2 = q.algo, j = [], y = [], z2 = [], A = [], B = [], C = [], s = [], u = [], v = [], w = [], g = [], k = 0; 256 > k; k++)
          g[k] = 128 > k ? k << 1 : k << 1 ^ 283;
        for (var n2 = 0, l = 0, k = 0; 256 > k; k++) {
          var f = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4, f = f >>> 8 ^ f & 255 ^ 99;
          j[n2] = f;
          y[f] = n2;
          var t3 = g[n2], D = g[t3], E = g[D], b = 257 * g[f] ^ 16843008 * f;
          z2[n2] = b << 24 | b >>> 8;
          A[n2] = b << 16 | b >>> 16;
          B[n2] = b << 8 | b >>> 24;
          C[n2] = b;
          b = 16843009 * E ^ 65537 * D ^ 257 * t3 ^ 16843008 * n2;
          s[f] = b << 24 | b >>> 8;
          u[f] = b << 16 | b >>> 16;
          v[f] = b << 8 | b >>> 24;
          w[f] = b;
          n2 ? (n2 = t3 ^ g[g[g[E ^ t3]]], l ^= g[g[l]]) : n2 = l = 1;
        }
        var F = [
          0,
          1,
          2,
          4,
          8,
          16,
          32,
          64,
          128,
          27,
          54
        ], r2 = r2.AES = x.extend({ _doReset: function() {
          for (var c = this._key, e2 = c.words, a = c.sigBytes / 4, c = 4 * ((this._nRounds = a + 6) + 1), b2 = this._keySchedule = [], h = 0; h < c; h++)
            if (h < a)
              b2[h] = e2[h];
            else {
              var d = b2[h - 1];
              h % a ? 6 < a && 4 == h % a && (d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255]) : (d = d << 8 | d >>> 24, d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255], d ^= F[h / a | 0] << 24);
              b2[h] = b2[h - a] ^ d;
            }
          e2 = this._invKeySchedule = [];
          for (a = 0; a < c; a++)
            h = c - a, d = a % 4 ? b2[h] : b2[h - 4], e2[a] = 4 > a || 4 >= h ? d : s[j[d >>> 24]] ^ u[j[d >>> 16 & 255]] ^ v[j[d >>> 8 & 255]] ^ w[j[d & 255]];
        }, encryptBlock: function(c, e2) {
          this._doCryptBlock(c, e2, this._keySchedule, z2, A, B, C, j);
        }, decryptBlock: function(c, e2) {
          var a = c[e2 + 1];
          c[e2 + 1] = c[e2 + 3];
          c[e2 + 3] = a;
          this._doCryptBlock(c, e2, this._invKeySchedule, s, u, v, w, y);
          a = c[e2 + 1];
          c[e2 + 1] = c[e2 + 3];
          c[e2 + 3] = a;
        }, _doCryptBlock: function(c, e2, a, b2, h, d, j2, m) {
          for (var n3 = this._nRounds, f2 = c[e2] ^ a[0], g2 = c[e2 + 1] ^ a[1], k2 = c[e2 + 2] ^ a[2], p = c[e2 + 3] ^ a[3], l2 = 4, t4 = 1; t4 < n3; t4++)
            var q2 = b2[f2 >>> 24] ^ h[g2 >>> 16 & 255] ^ d[k2 >>> 8 & 255] ^ j2[p & 255] ^ a[l2++], r3 = b2[g2 >>> 24] ^ h[k2 >>> 16 & 255] ^ d[p >>> 8 & 255] ^ j2[f2 & 255] ^ a[l2++], s2 = b2[k2 >>> 24] ^ h[p >>> 16 & 255] ^ d[f2 >>> 8 & 255] ^ j2[g2 & 255] ^ a[l2++], p = b2[p >>> 24] ^ h[f2 >>> 16 & 255] ^ d[g2 >>> 8 & 255] ^ j2[k2 & 255] ^ a[l2++], f2 = q2, g2 = r3, k2 = s2;
          q2 = (m[f2 >>> 24] << 24 | m[g2 >>> 16 & 255] << 16 | m[k2 >>> 8 & 255] << 8 | m[p & 255]) ^ a[l2++];
          r3 = (m[g2 >>> 24] << 24 | m[k2 >>> 16 & 255] << 16 | m[p >>> 8 & 255] << 8 | m[f2 & 255]) ^ a[l2++];
          s2 = (m[k2 >>> 24] << 24 | m[p >>> 16 & 255] << 16 | m[f2 >>> 8 & 255] << 8 | m[g2 & 255]) ^ a[l2++];
          p = (m[p >>> 24] << 24 | m[f2 >>> 16 & 255] << 16 | m[g2 >>> 8 & 255] << 8 | m[k2 & 255]) ^ a[l2++];
          c[e2] = q2;
          c[e2 + 1] = r3;
          c[e2 + 2] = s2;
          c[e2 + 3] = p;
        }, keySize: 8 });
        q.AES = x._createHelper(r2);
      })();
      (function() {
        function j(b, c) {
          var a = (this._lBlock >>> b ^ this._rBlock) & c;
          this._rBlock ^= a;
          this._lBlock ^= a << b;
        }
        function l(b, c) {
          var a = (this._rBlock >>> b ^ this._lBlock) & c;
          this._lBlock ^= a;
          this._rBlock ^= a << b;
        }
        var h = CryptoJS, e2 = h.lib, n2 = e2.WordArray, e2 = e2.BlockCipher, g = h.algo, q = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], p = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], r2 = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], s = [{
          "0": 8421888,
          268435456: 32768,
          536870912: 8421378,
          805306368: 2,
          1073741824: 512,
          1342177280: 8421890,
          1610612736: 8389122,
          1879048192: 8388608,
          2147483648: 514,
          2415919104: 8389120,
          2684354560: 33280,
          2952790016: 8421376,
          3221225472: 32770,
          3489660928: 8388610,
          3758096384: 0,
          4026531840: 33282,
          134217728: 0,
          402653184: 8421890,
          671088640: 33282,
          939524096: 32768,
          1207959552: 8421888,
          1476395008: 512,
          1744830464: 8421378,
          2013265920: 2,
          2281701376: 8389120,
          2550136832: 33280,
          2818572288: 8421376,
          3087007744: 8389122,
          3355443200: 8388610,
          3623878656: 32770,
          3892314112: 514,
          4160749568: 8388608,
          1: 32768,
          268435457: 2,
          536870913: 8421888,
          805306369: 8388608,
          1073741825: 8421378,
          1342177281: 33280,
          1610612737: 512,
          1879048193: 8389122,
          2147483649: 8421890,
          2415919105: 8421376,
          2684354561: 8388610,
          2952790017: 33282,
          3221225473: 514,
          3489660929: 8389120,
          3758096385: 32770,
          4026531841: 0,
          134217729: 8421890,
          402653185: 8421376,
          671088641: 8388608,
          939524097: 512,
          1207959553: 32768,
          1476395009: 8388610,
          1744830465: 2,
          2013265921: 33282,
          2281701377: 32770,
          2550136833: 8389122,
          2818572289: 514,
          3087007745: 8421888,
          3355443201: 8389120,
          3623878657: 0,
          3892314113: 33280,
          4160749569: 8421378
        }, {
          "0": 1074282512,
          16777216: 16384,
          33554432: 524288,
          50331648: 1074266128,
          67108864: 1073741840,
          83886080: 1074282496,
          100663296: 1073758208,
          117440512: 16,
          134217728: 540672,
          150994944: 1073758224,
          167772160: 1073741824,
          184549376: 540688,
          201326592: 524304,
          218103808: 0,
          234881024: 16400,
          251658240: 1074266112,
          8388608: 1073758208,
          25165824: 540688,
          41943040: 16,
          58720256: 1073758224,
          75497472: 1074282512,
          92274688: 1073741824,
          109051904: 524288,
          125829120: 1074266128,
          142606336: 524304,
          159383552: 0,
          176160768: 16384,
          192937984: 1074266112,
          209715200: 1073741840,
          226492416: 540672,
          243269632: 1074282496,
          260046848: 16400,
          268435456: 0,
          285212672: 1074266128,
          301989888: 1073758224,
          318767104: 1074282496,
          335544320: 1074266112,
          352321536: 16,
          369098752: 540688,
          385875968: 16384,
          402653184: 16400,
          419430400: 524288,
          436207616: 524304,
          452984832: 1073741840,
          469762048: 540672,
          486539264: 1073758208,
          503316480: 1073741824,
          520093696: 1074282512,
          276824064: 540688,
          293601280: 524288,
          310378496: 1074266112,
          327155712: 16384,
          343932928: 1073758208,
          360710144: 1074282512,
          377487360: 16,
          394264576: 1073741824,
          411041792: 1074282496,
          427819008: 1073741840,
          444596224: 1073758224,
          461373440: 524304,
          478150656: 0,
          494927872: 16400,
          511705088: 1074266128,
          528482304: 540672
        }, {
          "0": 260,
          1048576: 0,
          2097152: 67109120,
          3145728: 65796,
          4194304: 65540,
          5242880: 67108868,
          6291456: 67174660,
          7340032: 67174400,
          8388608: 67108864,
          9437184: 67174656,
          10485760: 65792,
          11534336: 67174404,
          12582912: 67109124,
          13631488: 65536,
          14680064: 4,
          15728640: 256,
          524288: 67174656,
          1572864: 67174404,
          2621440: 0,
          3670016: 67109120,
          4718592: 67108868,
          5767168: 65536,
          6815744: 65540,
          7864320: 260,
          8912896: 4,
          9961472: 256,
          11010048: 67174400,
          12058624: 65796,
          13107200: 65792,
          14155776: 67109124,
          15204352: 67174660,
          16252928: 67108864,
          16777216: 67174656,
          17825792: 65540,
          18874368: 65536,
          19922944: 67109120,
          20971520: 256,
          22020096: 67174660,
          23068672: 67108868,
          24117248: 0,
          25165824: 67109124,
          26214400: 67108864,
          27262976: 4,
          28311552: 65792,
          29360128: 67174400,
          30408704: 260,
          31457280: 65796,
          32505856: 67174404,
          17301504: 67108864,
          18350080: 260,
          19398656: 67174656,
          20447232: 0,
          21495808: 65540,
          22544384: 67109120,
          23592960: 256,
          24641536: 67174404,
          25690112: 65536,
          26738688: 67174660,
          27787264: 65796,
          28835840: 67108868,
          29884416: 67109124,
          30932992: 67174400,
          31981568: 4,
          33030144: 65792
        }, {
          "0": 2151682048,
          65536: 2147487808,
          131072: 4198464,
          196608: 2151677952,
          262144: 0,
          327680: 4198400,
          393216: 2147483712,
          458752: 4194368,
          524288: 2147483648,
          589824: 4194304,
          655360: 64,
          720896: 2147487744,
          786432: 2151678016,
          851968: 4160,
          917504: 4096,
          983040: 2151682112,
          32768: 2147487808,
          98304: 64,
          163840: 2151678016,
          229376: 2147487744,
          294912: 4198400,
          360448: 2151682112,
          425984: 0,
          491520: 2151677952,
          557056: 4096,
          622592: 2151682048,
          688128: 4194304,
          753664: 4160,
          819200: 2147483648,
          884736: 4194368,
          950272: 4198464,
          1015808: 2147483712,
          1048576: 4194368,
          1114112: 4198400,
          1179648: 2147483712,
          1245184: 0,
          1310720: 4160,
          1376256: 2151678016,
          1441792: 2151682048,
          1507328: 2147487808,
          1572864: 2151682112,
          1638400: 2147483648,
          1703936: 2151677952,
          1769472: 4198464,
          1835008: 2147487744,
          1900544: 4194304,
          1966080: 64,
          2031616: 4096,
          1081344: 2151677952,
          1146880: 2151682112,
          1212416: 0,
          1277952: 4198400,
          1343488: 4194368,
          1409024: 2147483648,
          1474560: 2147487808,
          1540096: 64,
          1605632: 2147483712,
          1671168: 4096,
          1736704: 2147487744,
          1802240: 2151678016,
          1867776: 4160,
          1933312: 2151682048,
          1998848: 4194304,
          2064384: 4198464
        }, {
          "0": 128,
          4096: 17039360,
          8192: 262144,
          12288: 536870912,
          16384: 537133184,
          20480: 16777344,
          24576: 553648256,
          28672: 262272,
          32768: 16777216,
          36864: 537133056,
          40960: 536871040,
          45056: 553910400,
          49152: 553910272,
          53248: 0,
          57344: 17039488,
          61440: 553648128,
          2048: 17039488,
          6144: 553648256,
          10240: 128,
          14336: 17039360,
          18432: 262144,
          22528: 537133184,
          26624: 553910272,
          30720: 536870912,
          34816: 537133056,
          38912: 0,
          43008: 553910400,
          47104: 16777344,
          51200: 536871040,
          55296: 553648128,
          59392: 16777216,
          63488: 262272,
          65536: 262144,
          69632: 128,
          73728: 536870912,
          77824: 553648256,
          81920: 16777344,
          86016: 553910272,
          90112: 537133184,
          94208: 16777216,
          98304: 553910400,
          102400: 553648128,
          106496: 17039360,
          110592: 537133056,
          114688: 262272,
          118784: 536871040,
          122880: 0,
          126976: 17039488,
          67584: 553648256,
          71680: 16777216,
          75776: 17039360,
          79872: 537133184,
          83968: 536870912,
          88064: 17039488,
          92160: 128,
          96256: 553910272,
          100352: 262272,
          104448: 553910400,
          108544: 0,
          112640: 553648128,
          116736: 16777344,
          120832: 262144,
          124928: 537133056,
          129024: 536871040
        }, {
          "0": 268435464,
          256: 8192,
          512: 270532608,
          768: 270540808,
          1024: 268443648,
          1280: 2097152,
          1536: 2097160,
          1792: 268435456,
          2048: 0,
          2304: 268443656,
          2560: 2105344,
          2816: 8,
          3072: 270532616,
          3328: 2105352,
          3584: 8200,
          3840: 270540800,
          128: 270532608,
          384: 270540808,
          640: 8,
          896: 2097152,
          1152: 2105352,
          1408: 268435464,
          1664: 268443648,
          1920: 8200,
          2176: 2097160,
          2432: 8192,
          2688: 268443656,
          2944: 270532616,
          3200: 0,
          3456: 270540800,
          3712: 2105344,
          3968: 268435456,
          4096: 268443648,
          4352: 270532616,
          4608: 270540808,
          4864: 8200,
          5120: 2097152,
          5376: 268435456,
          5632: 268435464,
          5888: 2105344,
          6144: 2105352,
          6400: 0,
          6656: 8,
          6912: 270532608,
          7168: 8192,
          7424: 268443656,
          7680: 270540800,
          7936: 2097160,
          4224: 8,
          4480: 2105344,
          4736: 2097152,
          4992: 268435464,
          5248: 268443648,
          5504: 8200,
          5760: 270540808,
          6016: 270532608,
          6272: 270540800,
          6528: 270532616,
          6784: 8192,
          7040: 2105352,
          7296: 2097160,
          7552: 0,
          7808: 268435456,
          8064: 268443656
        }, {
          "0": 1048576,
          16: 33555457,
          32: 1024,
          48: 1049601,
          64: 34604033,
          80: 0,
          96: 1,
          112: 34603009,
          128: 33555456,
          144: 1048577,
          160: 33554433,
          176: 34604032,
          192: 34603008,
          208: 1025,
          224: 1049600,
          240: 33554432,
          8: 34603009,
          24: 0,
          40: 33555457,
          56: 34604032,
          72: 1048576,
          88: 33554433,
          104: 33554432,
          120: 1025,
          136: 1049601,
          152: 33555456,
          168: 34603008,
          184: 1048577,
          200: 1024,
          216: 34604033,
          232: 1,
          248: 1049600,
          256: 33554432,
          272: 1048576,
          288: 33555457,
          304: 34603009,
          320: 1048577,
          336: 33555456,
          352: 34604032,
          368: 1049601,
          384: 1025,
          400: 34604033,
          416: 1049600,
          432: 1,
          448: 0,
          464: 34603008,
          480: 33554433,
          496: 1024,
          264: 1049600,
          280: 33555457,
          296: 34603009,
          312: 1,
          328: 33554432,
          344: 1048576,
          360: 1025,
          376: 34604032,
          392: 33554433,
          408: 34603008,
          424: 0,
          440: 34604033,
          456: 1049601,
          472: 1024,
          488: 33555456,
          504: 1048577
        }, {
          "0": 134219808,
          1: 131072,
          2: 134217728,
          3: 32,
          4: 131104,
          5: 134350880,
          6: 134350848,
          7: 2048,
          8: 134348800,
          9: 134219776,
          10: 133120,
          11: 134348832,
          12: 2080,
          13: 0,
          14: 134217760,
          15: 133152,
          2147483648: 2048,
          2147483649: 134350880,
          2147483650: 134219808,
          2147483651: 134217728,
          2147483652: 134348800,
          2147483653: 133120,
          2147483654: 133152,
          2147483655: 32,
          2147483656: 134217760,
          2147483657: 2080,
          2147483658: 131104,
          2147483659: 134350848,
          2147483660: 0,
          2147483661: 134348832,
          2147483662: 134219776,
          2147483663: 131072,
          16: 133152,
          17: 134350848,
          18: 32,
          19: 2048,
          20: 134219776,
          21: 134217760,
          22: 134348832,
          23: 131072,
          24: 0,
          25: 131104,
          26: 134348800,
          27: 134219808,
          28: 134350880,
          29: 133120,
          30: 2080,
          31: 134217728,
          2147483664: 131072,
          2147483665: 2048,
          2147483666: 134348832,
          2147483667: 133152,
          2147483668: 32,
          2147483669: 134348800,
          2147483670: 134217728,
          2147483671: 134219808,
          2147483672: 134350880,
          2147483673: 134217760,
          2147483674: 134219776,
          2147483675: 0,
          2147483676: 133120,
          2147483677: 2080,
          2147483678: 131104,
          2147483679: 134350848
        }], t3 = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], m = g.DES = e2.extend({ _doReset: function() {
          for (var b = this._key.words, c = [], a = 0; 56 > a; a++) {
            var f = q[a] - 1;
            c[a] = b[f >>> 5] >>> 31 - f % 32 & 1;
          }
          b = this._subKeys = [];
          for (f = 0; 16 > f; f++) {
            for (var d = b[f] = [], e3 = r2[f], a = 0; 24 > a; a++)
              d[a / 6 | 0] |= c[(p[a] - 1 + e3) % 28] << 31 - a % 6, d[4 + (a / 6 | 0)] |= c[28 + (p[a + 24] - 1 + e3) % 28] << 31 - a % 6;
            d[0] = d[0] << 1 | d[0] >>> 31;
            for (a = 1; 7 > a; a++)
              d[a] >>>= 4 * (a - 1) + 3;
            d[7] = d[7] << 5 | d[7] >>> 27;
          }
          c = this._invSubKeys = [];
          for (a = 0; 16 > a; a++)
            c[a] = b[15 - a];
        }, encryptBlock: function(b, c) {
          this._doCryptBlock(b, c, this._subKeys);
        }, decryptBlock: function(b, c) {
          this._doCryptBlock(b, c, this._invSubKeys);
        }, _doCryptBlock: function(b, c, a) {
          this._lBlock = b[c];
          this._rBlock = b[c + 1];
          j.call(this, 4, 252645135);
          j.call(this, 16, 65535);
          l.call(this, 2, 858993459);
          l.call(this, 8, 16711935);
          j.call(this, 1, 1431655765);
          for (var f = 0; 16 > f; f++) {
            for (var d = a[f], e3 = this._lBlock, h2 = this._rBlock, g2 = 0, k = 0; 8 > k; k++)
              g2 |= s[k][((h2 ^ d[k]) & t3[k]) >>> 0];
            this._lBlock = h2;
            this._rBlock = e3 ^ g2;
          }
          a = this._lBlock;
          this._lBlock = this._rBlock;
          this._rBlock = a;
          j.call(this, 1, 1431655765);
          l.call(this, 8, 16711935);
          l.call(this, 2, 858993459);
          j.call(this, 16, 65535);
          j.call(this, 4, 252645135);
          b[c] = this._lBlock;
          b[c + 1] = this._rBlock;
        }, keySize: 2, ivSize: 2, blockSize: 2 });
        h.DES = e2._createHelper(m);
        g = g.TripleDES = e2.extend({ _doReset: function() {
          var b = this._key.words;
          this._des1 = m.createEncryptor(n2.create(b.slice(0, 2)));
          this._des2 = m.createEncryptor(n2.create(b.slice(2, 4)));
          this._des3 = m.createEncryptor(n2.create(b.slice(4, 6)));
        }, encryptBlock: function(b, c) {
          this._des1.encryptBlock(b, c);
          this._des2.decryptBlock(b, c);
          this._des3.encryptBlock(b, c);
        }, decryptBlock: function(b, c) {
          this._des3.decryptBlock(b, c);
          this._des2.encryptBlock(b, c);
          this._des1.decryptBlock(b, c);
        }, keySize: 6, ivSize: 2, blockSize: 2 });
        h.TripleDES = e2._createHelper(g);
      })();
      (function() {
        var h = CryptoJS, j = h.lib.WordArray;
        h.enc.Base64 = { stringify: function(b) {
          var e2 = b.words, f = b.sigBytes, c = this._map;
          b.clamp();
          b = [];
          for (var a = 0; a < f; a += 3)
            for (var d = (e2[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e2[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e2[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++)
              b.push(c.charAt(d >>> 6 * (3 - g) & 63));
          if (e2 = c.charAt(64))
            for (; b.length % 4; )
              b.push(e2);
          return b.join("");
        }, parse: function(b) {
          var e2 = b.length, f = this._map, c = f.charAt(64);
          c && (c = b.indexOf(c), -1 != c && (e2 = c));
          for (var c = [], a = 0, d = 0; d < e2; d++)
            if (d % 4) {
              var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h2 = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);
              c[a >>> 2] |= (g | h2) << 24 - 8 * (a % 4);
              a++;
            }
          return j.create(c, a);
        }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
      })();
      (function(E) {
        function h(a2, f, g, j, p, h2, k2) {
          a2 = a2 + (f & g | ~f & j) + p + k2;
          return (a2 << h2 | a2 >>> 32 - h2) + f;
        }
        function k(a2, f, g, j, p, h2, k2) {
          a2 = a2 + (f & j | g & ~j) + p + k2;
          return (a2 << h2 | a2 >>> 32 - h2) + f;
        }
        function l(a2, f, g, j, h2, k2, l2) {
          a2 = a2 + (f ^ g ^ j) + h2 + l2;
          return (a2 << k2 | a2 >>> 32 - k2) + f;
        }
        function n2(a2, f, g, j, h2, k2, l2) {
          a2 = a2 + (g ^ (f | ~j)) + h2 + l2;
          return (a2 << k2 | a2 >>> 32 - k2) + f;
        }
        for (var r2 = CryptoJS, q = r2.lib, F = q.WordArray, s = q.Hasher, q = r2.algo, a = [], t3 = 0; 64 > t3; t3++)
          a[t3] = 4294967296 * E.abs(E.sin(t3 + 1)) | 0;
        q = q.MD5 = s.extend({
          _doReset: function() {
            this._hash = new F.init([1732584193, 4023233417, 2562383102, 271733878]);
          },
          _doProcessBlock: function(m, f) {
            for (var g = 0; 16 > g; g++) {
              var j = f + g, p = m[j];
              m[j] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360;
            }
            var g = this._hash.words, j = m[f + 0], p = m[f + 1], q2 = m[f + 2], r3 = m[f + 3], s2 = m[f + 4], t4 = m[f + 5], u = m[f + 6], v = m[f + 7], w = m[f + 8], x = m[f + 9], y = m[f + 10], z2 = m[f + 11], A = m[f + 12], B = m[f + 13], C = m[f + 14], D = m[f + 15], b = g[0], c = g[1], d = g[2], e2 = g[3], b = h(b, c, d, e2, j, 7, a[0]), e2 = h(e2, b, c, d, p, 12, a[1]), d = h(d, e2, b, c, q2, 17, a[2]), c = h(c, d, e2, b, r3, 22, a[3]), b = h(b, c, d, e2, s2, 7, a[4]), e2 = h(e2, b, c, d, t4, 12, a[5]), d = h(d, e2, b, c, u, 17, a[6]), c = h(c, d, e2, b, v, 22, a[7]), b = h(b, c, d, e2, w, 7, a[8]), e2 = h(e2, b, c, d, x, 12, a[9]), d = h(d, e2, b, c, y, 17, a[10]), c = h(c, d, e2, b, z2, 22, a[11]), b = h(b, c, d, e2, A, 7, a[12]), e2 = h(e2, b, c, d, B, 12, a[13]), d = h(d, e2, b, c, C, 17, a[14]), c = h(c, d, e2, b, D, 22, a[15]), b = k(b, c, d, e2, p, 5, a[16]), e2 = k(e2, b, c, d, u, 9, a[17]), d = k(d, e2, b, c, z2, 14, a[18]), c = k(c, d, e2, b, j, 20, a[19]), b = k(b, c, d, e2, t4, 5, a[20]), e2 = k(e2, b, c, d, y, 9, a[21]), d = k(d, e2, b, c, D, 14, a[22]), c = k(c, d, e2, b, s2, 20, a[23]), b = k(b, c, d, e2, x, 5, a[24]), e2 = k(e2, b, c, d, C, 9, a[25]), d = k(d, e2, b, c, r3, 14, a[26]), c = k(c, d, e2, b, w, 20, a[27]), b = k(b, c, d, e2, B, 5, a[28]), e2 = k(
              e2,
              b,
              c,
              d,
              q2,
              9,
              a[29]
            ), d = k(d, e2, b, c, v, 14, a[30]), c = k(c, d, e2, b, A, 20, a[31]), b = l(b, c, d, e2, t4, 4, a[32]), e2 = l(e2, b, c, d, w, 11, a[33]), d = l(d, e2, b, c, z2, 16, a[34]), c = l(c, d, e2, b, C, 23, a[35]), b = l(b, c, d, e2, p, 4, a[36]), e2 = l(e2, b, c, d, s2, 11, a[37]), d = l(d, e2, b, c, v, 16, a[38]), c = l(c, d, e2, b, y, 23, a[39]), b = l(b, c, d, e2, B, 4, a[40]), e2 = l(e2, b, c, d, j, 11, a[41]), d = l(d, e2, b, c, r3, 16, a[42]), c = l(c, d, e2, b, u, 23, a[43]), b = l(b, c, d, e2, x, 4, a[44]), e2 = l(e2, b, c, d, A, 11, a[45]), d = l(d, e2, b, c, D, 16, a[46]), c = l(c, d, e2, b, q2, 23, a[47]), b = n2(b, c, d, e2, j, 6, a[48]), e2 = n2(e2, b, c, d, v, 10, a[49]), d = n2(
              d,
              e2,
              b,
              c,
              C,
              15,
              a[50]
            ), c = n2(c, d, e2, b, t4, 21, a[51]), b = n2(b, c, d, e2, A, 6, a[52]), e2 = n2(e2, b, c, d, r3, 10, a[53]), d = n2(d, e2, b, c, y, 15, a[54]), c = n2(c, d, e2, b, p, 21, a[55]), b = n2(b, c, d, e2, w, 6, a[56]), e2 = n2(e2, b, c, d, D, 10, a[57]), d = n2(d, e2, b, c, u, 15, a[58]), c = n2(c, d, e2, b, B, 21, a[59]), b = n2(b, c, d, e2, s2, 6, a[60]), e2 = n2(e2, b, c, d, z2, 10, a[61]), d = n2(d, e2, b, c, q2, 15, a[62]), c = n2(c, d, e2, b, x, 21, a[63]);
            g[0] = g[0] + b | 0;
            g[1] = g[1] + c | 0;
            g[2] = g[2] + d | 0;
            g[3] = g[3] + e2 | 0;
          },
          _doFinalize: function() {
            var a2 = this._data, f = a2.words, g = 8 * this._nDataBytes, j = 8 * a2.sigBytes;
            f[j >>> 5] |= 128 << 24 - j % 32;
            var h2 = E.floor(g / 4294967296);
            f[(j + 64 >>> 9 << 4) + 15] = (h2 << 8 | h2 >>> 24) & 16711935 | (h2 << 24 | h2 >>> 8) & 4278255360;
            f[(j + 64 >>> 9 << 4) + 14] = (g << 8 | g >>> 24) & 16711935 | (g << 24 | g >>> 8) & 4278255360;
            a2.sigBytes = 4 * (f.length + 1);
            this._process();
            a2 = this._hash;
            f = a2.words;
            for (g = 0; 4 > g; g++)
              j = f[g], f[g] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
            return a2;
          },
          clone: function() {
            var a2 = s.clone.call(this);
            a2._hash = this._hash.clone();
            return a2;
          }
        });
        r2.MD5 = s._createHelper(q);
        r2.HmacMD5 = s._createHmacHelper(q);
      })(Math);
      (function() {
        var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({ _doReset: function() {
          this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
        }, _doProcessBlock: function(n2, p) {
          for (var a = this._hash.words, e2 = a[0], f = a[1], h = a[2], j = a[3], b2 = a[4], c = 0; 80 > c; c++) {
            if (16 > c)
              d[c] = n2[p + c] | 0;
            else {
              var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];
              d[c] = g << 1 | g >>> 31;
            }
            g = (e2 << 5 | e2 >>> 27) + b2 + d[c];
            g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514);
            b2 = j;
            j = h;
            h = f << 30 | f >>> 2;
            f = e2;
            e2 = g;
          }
          a[0] = a[0] + e2 | 0;
          a[1] = a[1] + f | 0;
          a[2] = a[2] + h | 0;
          a[3] = a[3] + j | 0;
          a[4] = a[4] + b2 | 0;
        }, _doFinalize: function() {
          var b2 = this._data, d2 = b2.words, a = 8 * this._nDataBytes, e2 = 8 * b2.sigBytes;
          d2[e2 >>> 5] |= 128 << 24 - e2 % 32;
          d2[(e2 + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);
          d2[(e2 + 64 >>> 9 << 4) + 15] = a;
          b2.sigBytes = 4 * d2.length;
          this._process();
          return this._hash;
        }, clone: function() {
          var b2 = l.clone.call(this);
          b2._hash = this._hash.clone();
          return b2;
        } });
        k.SHA1 = l._createHelper(b);
        k.HmacSHA1 = l._createHmacHelper(b);
      })();
      (function(k) {
        for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t3 = [], u = function(q) {
          return 4294967296 * (q - (q | 0)) | 0;
        }, l = 2, b = 0; 64 > b; ) {
          var d;
          a: {
            d = l;
            for (var w = k.sqrt(d), r2 = 2; r2 <= w; r2++)
              if (!(d % r2)) {
                d = false;
                break a;
              }
            d = true;
          }
          d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t3[b] = u(k.pow(l, 1 / 3)), b++);
          l++;
        }
        var n2 = [], h = h.SHA256 = j.extend({ _doReset: function() {
          this._hash = new v.init(s.slice(0));
        }, _doProcessBlock: function(q, h2) {
          for (var a = this._hash.words, c = a[0], d2 = a[1], b2 = a[2], k2 = a[3], f = a[4], g2 = a[5], j2 = a[6], l2 = a[7], e2 = 0; 64 > e2; e2++) {
            if (16 > e2)
              n2[e2] = q[h2 + e2] | 0;
            else {
              var m = n2[e2 - 15], p = n2[e2 - 2];
              n2[e2] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n2[e2 - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n2[e2 - 16];
            }
            m = l2 + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g2 ^ ~f & j2) + t3[e2] + n2[e2];
            p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d2 ^ c & b2 ^ d2 & b2);
            l2 = j2;
            j2 = g2;
            g2 = f;
            f = k2 + m | 0;
            k2 = b2;
            b2 = d2;
            d2 = c;
            c = m + p | 0;
          }
          a[0] = a[0] + c | 0;
          a[1] = a[1] + d2 | 0;
          a[2] = a[2] + b2 | 0;
          a[3] = a[3] + k2 | 0;
          a[4] = a[4] + f | 0;
          a[5] = a[5] + g2 | 0;
          a[6] = a[6] + j2 | 0;
          a[7] = a[7] + l2 | 0;
        }, _doFinalize: function() {
          var d2 = this._data, b2 = d2.words, a = 8 * this._nDataBytes, c = 8 * d2.sigBytes;
          b2[c >>> 5] |= 128 << 24 - c % 32;
          b2[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);
          b2[(c + 64 >>> 9 << 4) + 15] = a;
          d2.sigBytes = 4 * b2.length;
          this._process();
          return this._hash;
        }, clone: function() {
          var b2 = j.clone.call(this);
          b2._hash = this._hash.clone();
          return b2;
        } });
        g.SHA256 = j._createHelper(h);
        g.HmacSHA256 = j._createHmacHelper(h);
      })(Math);
      (function() {
        var b = CryptoJS, d = b.lib.WordArray, a = b.algo, c = a.SHA256, a = a.SHA224 = c.extend({ _doReset: function() {
          this._hash = new d.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
        }, _doFinalize: function() {
          var a2 = c._doFinalize.call(this);
          a2.sigBytes -= 4;
          return a2;
        } });
        b.SHA224 = c._createHelper(a);
        b.HmacSHA224 = c._createHmacHelper(a);
      })();
      (function() {
        function a() {
          return d.create.apply(d, arguments);
        }
        for (var n2 = CryptoJS, r2 = n2.lib.Hasher, e2 = n2.x64, d = e2.Word, T = e2.WordArray, e2 = n2.algo, ea = [
          a(1116352408, 3609767458),
          a(1899447441, 602891725),
          a(3049323471, 3964484399),
          a(3921009573, 2173295548),
          a(961987163, 4081628472),
          a(1508970993, 3053834265),
          a(2453635748, 2937671579),
          a(2870763221, 3664609560),
          a(3624381080, 2734883394),
          a(310598401, 1164996542),
          a(607225278, 1323610764),
          a(1426881987, 3590304994),
          a(1925078388, 4068182383),
          a(2162078206, 991336113),
          a(2614888103, 633803317),
          a(3248222580, 3479774868),
          a(3835390401, 2666613458),
          a(4022224774, 944711139),
          a(264347078, 2341262773),
          a(604807628, 2007800933),
          a(770255983, 1495990901),
          a(1249150122, 1856431235),
          a(1555081692, 3175218132),
          a(1996064986, 2198950837),
          a(2554220882, 3999719339),
          a(2821834349, 766784016),
          a(2952996808, 2566594879),
          a(3210313671, 3203337956),
          a(3336571891, 1034457026),
          a(3584528711, 2466948901),
          a(113926993, 3758326383),
          a(338241895, 168717936),
          a(666307205, 1188179964),
          a(773529912, 1546045734),
          a(1294757372, 1522805485),
          a(
            1396182291,
            2643833823
          ),
          a(1695183700, 2343527390),
          a(1986661051, 1014477480),
          a(2177026350, 1206759142),
          a(2456956037, 344077627),
          a(2730485921, 1290863460),
          a(2820302411, 3158454273),
          a(3259730800, 3505952657),
          a(3345764771, 106217008),
          a(3516065817, 3606008344),
          a(3600352804, 1432725776),
          a(4094571909, 1467031594),
          a(275423344, 851169720),
          a(430227734, 3100823752),
          a(506948616, 1363258195),
          a(659060556, 3750685593),
          a(883997877, 3785050280),
          a(958139571, 3318307427),
          a(1322822218, 3812723403),
          a(1537002063, 2003034995),
          a(1747873779, 3602036899),
          a(1955562222, 1575990012),
          a(2024104815, 1125592928),
          a(2227730452, 2716904306),
          a(2361852424, 442776044),
          a(2428436474, 593698344),
          a(2756734187, 3733110249),
          a(3204031479, 2999351573),
          a(3329325298, 3815920427),
          a(3391569614, 3928383900),
          a(3515267271, 566280711),
          a(3940187606, 3454069534),
          a(4118630271, 4000239992),
          a(116418474, 1914138554),
          a(174292421, 2731055270),
          a(289380356, 3203993006),
          a(460393269, 320620315),
          a(685471733, 587496836),
          a(852142971, 1086792851),
          a(1017036298, 365543100),
          a(1126000580, 2618297676),
          a(
            1288033470,
            3409855158
          ),
          a(1501505948, 4234509866),
          a(1607167915, 987167468),
          a(1816402316, 1246189591)
        ], v = [], w = 0; 80 > w; w++)
          v[w] = a();
        e2 = e2.SHA512 = r2.extend({ _doReset: function() {
          this._hash = new T.init([new d.init(1779033703, 4089235720), new d.init(3144134277, 2227873595), new d.init(1013904242, 4271175723), new d.init(2773480762, 1595750129), new d.init(1359893119, 2917565137), new d.init(2600822924, 725511199), new d.init(528734635, 4215389547), new d.init(1541459225, 327033209)]);
        }, _doProcessBlock: function(a2, d2) {
          for (var f = this._hash.words, F = f[0], e3 = f[1], n3 = f[2], r3 = f[3], G = f[4], H = f[5], I = f[6], f = f[7], w2 = F.high, J = F.low, X = e3.high, K = e3.low, Y = n3.high, L = n3.low, Z = r3.high, M = r3.low, $ = G.high, N = G.low, aa = H.high, O = H.low, ba = I.high, P = I.low, ca = f.high, Q = f.low, k = w2, g = J, z2 = X, x = K, A = Y, y = L, U = Z, B = M, l = $, h = N, R = aa, C = O, S = ba, D = P, V = ca, E = Q, m = 0; 80 > m; m++) {
            var s = v[m];
            if (16 > m)
              var j = s.high = a2[d2 + 2 * m] | 0, b = s.low = a2[d2 + 2 * m + 1] | 0;
            else {
              var j = v[m - 15], b = j.high, p = j.low, j = (b >>> 1 | p << 31) ^ (b >>> 8 | p << 24) ^ b >>> 7, p = (p >>> 1 | b << 31) ^ (p >>> 8 | b << 24) ^ (p >>> 7 | b << 25), u = v[m - 2], b = u.high, c = u.low, u = (b >>> 19 | c << 13) ^ (b << 3 | c >>> 29) ^ b >>> 6, c = (c >>> 19 | b << 13) ^ (c << 3 | b >>> 29) ^ (c >>> 6 | b << 26), b = v[m - 7], W = b.high, t3 = v[m - 16], q = t3.high, t3 = t3.low, b = p + b.low, j = j + W + (b >>> 0 < p >>> 0 ? 1 : 0), b = b + c, j = j + u + (b >>> 0 < c >>> 0 ? 1 : 0), b = b + t3, j = j + q + (b >>> 0 < t3 >>> 0 ? 1 : 0);
              s.high = j;
              s.low = b;
            }
            var W = l & R ^ ~l & S, t3 = h & C ^ ~h & D, s = k & z2 ^ k & A ^ z2 & A, T2 = g & x ^ g & y ^ x & y, p = (k >>> 28 | g << 4) ^ (k << 30 | g >>> 2) ^ (k << 25 | g >>> 7), u = (g >>> 28 | k << 4) ^ (g << 30 | k >>> 2) ^ (g << 25 | k >>> 7), c = ea[m], fa = c.high, da = c.low, c = E + ((h >>> 14 | l << 18) ^ (h >>> 18 | l << 14) ^ (h << 23 | l >>> 9)), q = V + ((l >>> 14 | h << 18) ^ (l >>> 18 | h << 14) ^ (l << 23 | h >>> 9)) + (c >>> 0 < E >>> 0 ? 1 : 0), c = c + t3, q = q + W + (c >>> 0 < t3 >>> 0 ? 1 : 0), c = c + da, q = q + fa + (c >>> 0 < da >>> 0 ? 1 : 0), c = c + b, q = q + j + (c >>> 0 < b >>> 0 ? 1 : 0), b = u + T2, s = p + s + (b >>> 0 < u >>> 0 ? 1 : 0), V = S, E = D, S = R, D = C, R = l, C = h, h = B + c | 0, l = U + q + (h >>> 0 < B >>> 0 ? 1 : 0) | 0, U = A, B = y, A = z2, y = x, z2 = k, x = g, g = c + b | 0, k = q + s + (g >>> 0 < c >>> 0 ? 1 : 0) | 0;
          }
          J = F.low = J + g;
          F.high = w2 + k + (J >>> 0 < g >>> 0 ? 1 : 0);
          K = e3.low = K + x;
          e3.high = X + z2 + (K >>> 0 < x >>> 0 ? 1 : 0);
          L = n3.low = L + y;
          n3.high = Y + A + (L >>> 0 < y >>> 0 ? 1 : 0);
          M = r3.low = M + B;
          r3.high = Z + U + (M >>> 0 < B >>> 0 ? 1 : 0);
          N = G.low = N + h;
          G.high = $ + l + (N >>> 0 < h >>> 0 ? 1 : 0);
          O = H.low = O + C;
          H.high = aa + R + (O >>> 0 < C >>> 0 ? 1 : 0);
          P = I.low = P + D;
          I.high = ba + S + (P >>> 0 < D >>> 0 ? 1 : 0);
          Q = f.low = Q + E;
          f.high = ca + V + (Q >>> 0 < E >>> 0 ? 1 : 0);
        }, _doFinalize: function() {
          var a2 = this._data, d2 = a2.words, f = 8 * this._nDataBytes, e3 = 8 * a2.sigBytes;
          d2[e3 >>> 5] |= 128 << 24 - e3 % 32;
          d2[(e3 + 128 >>> 10 << 5) + 30] = Math.floor(f / 4294967296);
          d2[(e3 + 128 >>> 10 << 5) + 31] = f;
          a2.sigBytes = 4 * d2.length;
          this._process();
          return this._hash.toX32();
        }, clone: function() {
          var a2 = r2.clone.call(this);
          a2._hash = this._hash.clone();
          return a2;
        }, blockSize: 32 });
        n2.SHA512 = r2._createHelper(e2);
        n2.HmacSHA512 = r2._createHmacHelper(e2);
      })();
      (function() {
        var c = CryptoJS, a = c.x64, b = a.Word, e2 = a.WordArray, a = c.algo, d = a.SHA512, a = a.SHA384 = d.extend({ _doReset: function() {
          this._hash = new e2.init([new b.init(3418070365, 3238371032), new b.init(1654270250, 914150663), new b.init(2438529370, 812702999), new b.init(355462360, 4144912697), new b.init(1731405415, 4290775857), new b.init(2394180231, 1750603025), new b.init(3675008525, 1694076839), new b.init(1203062813, 3204075428)]);
        }, _doFinalize: function() {
          var a2 = d._doFinalize.call(this);
          a2.sigBytes -= 16;
          return a2;
        } });
        c.SHA384 = d._createHelper(a);
        c.HmacSHA384 = d._createHmacHelper(a);
      })();
      (function() {
        var q = CryptoJS, d = q.lib, n2 = d.WordArray, p = d.Hasher, d = q.algo, x = n2.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), y = n2.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), z2 = n2.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), A = n2.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), B = n2.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), C = n2.create([
          1352829926,
          1548603684,
          1836072691,
          2053994217,
          0
        ]), d = d.RIPEMD160 = p.extend({ _doReset: function() {
          this._hash = n2.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
        }, _doProcessBlock: function(e2, v) {
          for (var b = 0; 16 > b; b++) {
            var c = v + b, f = e2[c];
            e2[c] = (f << 8 | f >>> 24) & 16711935 | (f << 24 | f >>> 8) & 4278255360;
          }
          var c = this._hash.words, f = B.words, d2 = C.words, n3 = x.words, q2 = y.words, p2 = z2.words, w = A.words, t3, g, h, j, r2, u, k, l, m, s;
          u = t3 = c[0];
          k = g = c[1];
          l = h = c[2];
          m = j = c[3];
          s = r2 = c[4];
          for (var a, b = 0; 80 > b; b += 1)
            a = t3 + e2[v + n3[b]] | 0, a = 16 > b ? a + ((g ^ h ^ j) + f[0]) : 32 > b ? a + ((g & h | ~g & j) + f[1]) : 48 > b ? a + (((g | ~h) ^ j) + f[2]) : 64 > b ? a + ((g & j | h & ~j) + f[3]) : a + ((g ^ (h | ~j)) + f[4]), a |= 0, a = a << p2[b] | a >>> 32 - p2[b], a = a + r2 | 0, t3 = r2, r2 = j, j = h << 10 | h >>> 22, h = g, g = a, a = u + e2[v + q2[b]] | 0, a = 16 > b ? a + ((k ^ (l | ~m)) + d2[0]) : 32 > b ? a + ((k & m | l & ~m) + d2[1]) : 48 > b ? a + (((k | ~l) ^ m) + d2[2]) : 64 > b ? a + ((k & l | ~k & m) + d2[3]) : a + ((k ^ l ^ m) + d2[4]), a |= 0, a = a << w[b] | a >>> 32 - w[b], a = a + s | 0, u = s, s = m, m = l << 10 | l >>> 22, l = k, k = a;
          a = c[1] + h + m | 0;
          c[1] = c[2] + j + s | 0;
          c[2] = c[3] + r2 + u | 0;
          c[3] = c[4] + t3 + k | 0;
          c[4] = c[0] + g + l | 0;
          c[0] = a;
        }, _doFinalize: function() {
          var e2 = this._data, d2 = e2.words, b = 8 * this._nDataBytes, c = 8 * e2.sigBytes;
          d2[c >>> 5] |= 128 << 24 - c % 32;
          d2[(c + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360;
          e2.sigBytes = 4 * (d2.length + 1);
          this._process();
          e2 = this._hash;
          d2 = e2.words;
          for (b = 0; 5 > b; b++)
            c = d2[b], d2[b] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
          return e2;
        }, clone: function() {
          var d2 = p.clone.call(this);
          d2._hash = this._hash.clone();
          return d2;
        } });
        q.RIPEMD160 = p._createHelper(d);
        q.HmacRIPEMD160 = p._createHmacHelper(d);
      })(Math);
      (function() {
        var c = CryptoJS, k = c.enc.Utf8;
        c.algo.HMAC = c.lib.Base.extend({ init: function(a, b) {
          a = this._hasher = new a.init();
          "string" == typeof b && (b = k.parse(b));
          var c2 = a.blockSize, e2 = 4 * c2;
          b.sigBytes > e2 && (b = a.finalize(b));
          b.clamp();
          for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c2; d++)
            h[d] ^= 1549556828, j[d] ^= 909522486;
          f.sigBytes = g.sigBytes = e2;
          this.reset();
        }, reset: function() {
          var a = this._hasher;
          a.reset();
          a.update(this._iKey);
        }, update: function(a) {
          this._hasher.update(a);
          return this;
        }, finalize: function(a) {
          var b = this._hasher;
          a = b.finalize(a);
          b.reset();
          return b.finalize(this._oKey.clone().concat(a));
        } });
      })();
      (function() {
        var b = CryptoJS, a = b.lib, d = a.Base, m = a.WordArray, a = b.algo, q = a.HMAC, l = a.PBKDF2 = d.extend({ cfg: d.extend({ keySize: 4, hasher: a.SHA1, iterations: 1 }), init: function(a2) {
          this.cfg = this.cfg.extend(a2);
        }, compute: function(a2, b2) {
          for (var c = this.cfg, f = q.create(c.hasher, a2), g = m.create(), d2 = m.create([1]), l2 = g.words, r2 = d2.words, n2 = c.keySize, c = c.iterations; l2.length < n2; ) {
            var h = f.update(b2).finalize(d2);
            f.reset();
            for (var j = h.words, s = j.length, k = h, p = 1; p < c; p++) {
              k = f.finalize(k);
              f.reset();
              for (var t3 = k.words, e2 = 0; e2 < s; e2++)
                j[e2] ^= t3[e2];
            }
            g.concat(h);
            r2[0]++;
          }
          g.sigBytes = 4 * n2;
          return g;
        } });
        b.PBKDF2 = function(a2, b2, c) {
          return l.create(c).compute(a2, b2);
        };
      })();
      var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var b64pad = "=";
      function hex2b64(d) {
        var b;
        var e2;
        var a = "";
        for (b = 0; b + 3 <= d.length; b += 3) {
          e2 = parseInt(d.substring(b, b + 3), 16);
          a += b64map.charAt(e2 >> 6) + b64map.charAt(e2 & 63);
        }
        if (b + 1 == d.length) {
          e2 = parseInt(d.substring(b, b + 1), 16);
          a += b64map.charAt(e2 << 2);
        } else {
          if (b + 2 == d.length) {
            e2 = parseInt(d.substring(b, b + 2), 16);
            a += b64map.charAt(e2 >> 2) + b64map.charAt((e2 & 3) << 4);
          }
        }
        if (b64pad) {
          while ((a.length & 3) > 0) {
            a += b64pad;
          }
        }
        return a;
      }
      function b64tohex(f) {
        var d = "";
        var e2;
        var b = 0;
        var c;
        var a;
        for (e2 = 0; e2 < f.length; ++e2) {
          if (f.charAt(e2) == b64pad) {
            break;
          }
          a = b64map.indexOf(f.charAt(e2));
          if (a < 0) {
            continue;
          }
          if (b == 0) {
            d += int2char(a >> 2);
            c = a & 3;
            b = 1;
          } else {
            if (b == 1) {
              d += int2char(c << 2 | a >> 4);
              c = a & 15;
              b = 2;
            } else {
              if (b == 2) {
                d += int2char(c);
                d += int2char(a >> 2);
                c = a & 3;
                b = 3;
              } else {
                d += int2char(c << 2 | a >> 4);
                d += int2char(a & 15);
                b = 0;
              }
            }
          }
        }
        if (b == 1) {
          d += int2char(c << 2);
        }
        return d;
      }
      function b64toBA(e2) {
        var d = b64tohex(e2);
        var c;
        var b = new Array();
        for (c = 0; 2 * c < d.length; ++c) {
          b[c] = parseInt(d.substring(2 * c, 2 * c + 2), 16);
        }
        return b;
      }
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(e2, d, f) {
        if (e2 != null) {
          if ("number" == typeof e2) {
            this.fromNumber(e2, d, f);
          } else {
            if (d == null && "string" != typeof e2) {
              this.fromString(e2, 256);
            } else {
              this.fromString(e2, d);
            }
          }
        }
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(f, a, b, e2, h, g) {
        while (--g >= 0) {
          var d = a * this[f++] + b[e2] + h;
          h = Math.floor(d / 67108864);
          b[e2++] = d & 67108863;
        }
        return h;
      }
      function am2(f, q, r2, e2, o2, a) {
        var k = q & 32767, p = q >> 15;
        while (--a >= 0) {
          var d = this[f] & 32767;
          var g = this[f++] >> 15;
          var b = p * d + g * k;
          d = k * d + ((b & 32767) << 15) + r2[e2] + (o2 & 1073741823);
          o2 = (d >>> 30) + (b >>> 15) + p * g + (o2 >>> 30);
          r2[e2++] = d & 1073741823;
        }
        return o2;
      }
      function am3(f, q, r2, e2, o2, a) {
        var k = q & 16383, p = q >> 14;
        while (--a >= 0) {
          var d = this[f] & 16383;
          var g = this[f++] >> 14;
          var b = p * d + g * k;
          d = k * d + ((b & 16383) << 14) + r2[e2] + o2;
          o2 = (d >> 28) + (b >> 14) + p * g;
          r2[e2++] = d & 268435455;
        }
        return o2;
      }
      if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else {
        if (j_lm && navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr;
      var vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) {
        BI_RC[rr++] = vv;
      }
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) {
        BI_RC[rr++] = vv;
      }
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) {
        BI_RC[rr++] = vv;
      }
      function int2char(a) {
        return BI_RM.charAt(a);
      }
      function intAt(b, a) {
        var d = BI_RC[b.charCodeAt(a)];
        return d == null ? -1 : d;
      }
      function bnpCopyTo(b) {
        for (var a = this.t - 1; a >= 0; --a) {
          b[a] = this[a];
        }
        b.t = this.t;
        b.s = this.s;
      }
      function bnpFromInt(a) {
        this.t = 1;
        this.s = a < 0 ? -1 : 0;
        if (a > 0) {
          this[0] = a;
        } else {
          if (a < -1) {
            this[0] = a + this.DV;
          } else {
            this.t = 0;
          }
        }
      }
      function nbv(a) {
        var b = nbi();
        b.fromInt(a);
        return b;
      }
      function bnpFromString(h, c) {
        var e2;
        if (c == 16) {
          e2 = 4;
        } else {
          if (c == 8) {
            e2 = 3;
          } else {
            if (c == 256) {
              e2 = 8;
            } else {
              if (c == 2) {
                e2 = 1;
              } else {
                if (c == 32) {
                  e2 = 5;
                } else {
                  if (c == 4) {
                    e2 = 2;
                  } else {
                    this.fromRadix(h, c);
                    return;
                  }
                }
              }
            }
          }
        }
        this.t = 0;
        this.s = 0;
        var g = h.length, d = false, f = 0;
        while (--g >= 0) {
          var a = e2 == 8 ? h[g] & 255 : intAt(h, g);
          if (a < 0) {
            if (h.charAt(g) == "-") {
              d = true;
            }
            continue;
          }
          d = false;
          if (f == 0) {
            this[this.t++] = a;
          } else {
            if (f + e2 > this.DB) {
              this[this.t - 1] |= (a & (1 << this.DB - f) - 1) << f;
              this[this.t++] = a >> this.DB - f;
            } else {
              this[this.t - 1] |= a << f;
            }
          }
          f += e2;
          if (f >= this.DB) {
            f -= this.DB;
          }
        }
        if (e2 == 8 && (h[0] & 128) != 0) {
          this.s = -1;
          if (f > 0) {
            this[this.t - 1] |= (1 << this.DB - f) - 1 << f;
          }
        }
        this.clamp();
        if (d) {
          BigInteger.ZERO.subTo(this, this);
        }
      }
      function bnpClamp() {
        var a = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == a) {
          --this.t;
        }
      }
      function bnToString(c) {
        if (this.s < 0) {
          return "-" + this.negate().toString(c);
        }
        var e2;
        if (c == 16) {
          e2 = 4;
        } else {
          if (c == 8) {
            e2 = 3;
          } else {
            if (c == 2) {
              e2 = 1;
            } else {
              if (c == 32) {
                e2 = 5;
              } else {
                if (c == 4) {
                  e2 = 2;
                } else {
                  return this.toRadix(c);
                }
              }
            }
          }
        }
        var g = (1 << e2) - 1, l, a = false, h = "", f = this.t;
        var j = this.DB - f * this.DB % e2;
        if (f-- > 0) {
          if (j < this.DB && (l = this[f] >> j) > 0) {
            a = true;
            h = int2char(l);
          }
          while (f >= 0) {
            if (j < e2) {
              l = (this[f] & (1 << j) - 1) << e2 - j;
              l |= this[--f] >> (j += this.DB - e2);
            } else {
              l = this[f] >> (j -= e2) & g;
              if (j <= 0) {
                j += this.DB;
                --f;
              }
            }
            if (l > 0) {
              a = true;
            }
            if (a) {
              h += int2char(l);
            }
          }
        }
        return a ? h : "0";
      }
      function bnNegate() {
        var a = nbi();
        BigInteger.ZERO.subTo(this, a);
        return a;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(b) {
        var d = this.s - b.s;
        if (d != 0) {
          return d;
        }
        var c = this.t;
        d = c - b.t;
        if (d != 0) {
          return this.s < 0 ? -d : d;
        }
        while (--c >= 0) {
          if ((d = this[c] - b[c]) != 0) {
            return d;
          }
        }
        return 0;
      }
      function nbits(a) {
        var c = 1, b;
        if ((b = a >>> 16) != 0) {
          a = b;
          c += 16;
        }
        if ((b = a >> 8) != 0) {
          a = b;
          c += 8;
        }
        if ((b = a >> 4) != 0) {
          a = b;
          c += 4;
        }
        if ((b = a >> 2) != 0) {
          a = b;
          c += 2;
        }
        if ((b = a >> 1) != 0) {
          a = b;
          c += 1;
        }
        return c;
      }
      function bnBitLength() {
        if (this.t <= 0) {
          return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(c, b) {
        var a;
        for (a = this.t - 1; a >= 0; --a) {
          b[a + c] = this[a];
        }
        for (a = c - 1; a >= 0; --a) {
          b[a] = 0;
        }
        b.t = this.t + c;
        b.s = this.s;
      }
      function bnpDRShiftTo(c, b) {
        for (var a = c; a < this.t; ++a) {
          b[a - c] = this[a];
        }
        b.t = Math.max(this.t - c, 0);
        b.s = this.s;
      }
      function bnpLShiftTo(j, e2) {
        var b = j % this.DB;
        var a = this.DB - b;
        var g = (1 << a) - 1;
        var f = Math.floor(j / this.DB), h = this.s << b & this.DM, d;
        for (d = this.t - 1; d >= 0; --d) {
          e2[d + f + 1] = this[d] >> a | h;
          h = (this[d] & g) << b;
        }
        for (d = f - 1; d >= 0; --d) {
          e2[d] = 0;
        }
        e2[f] = h;
        e2.t = this.t + f + 1;
        e2.s = this.s;
        e2.clamp();
      }
      function bnpRShiftTo(g, d) {
        d.s = this.s;
        var e2 = Math.floor(g / this.DB);
        if (e2 >= this.t) {
          d.t = 0;
          return;
        }
        var b = g % this.DB;
        var a = this.DB - b;
        var f = (1 << b) - 1;
        d[0] = this[e2] >> b;
        for (var c = e2 + 1; c < this.t; ++c) {
          d[c - e2 - 1] |= (this[c] & f) << a;
          d[c - e2] = this[c] >> b;
        }
        if (b > 0) {
          d[this.t - e2 - 1] |= (this.s & f) << a;
        }
        d.t = this.t - e2;
        d.clamp();
      }
      function bnpSubTo(d, f) {
        var e2 = 0, g = 0, b = Math.min(d.t, this.t);
        while (e2 < b) {
          g += this[e2] - d[e2];
          f[e2++] = g & this.DM;
          g >>= this.DB;
        }
        if (d.t < this.t) {
          g -= d.s;
          while (e2 < this.t) {
            g += this[e2];
            f[e2++] = g & this.DM;
            g >>= this.DB;
          }
          g += this.s;
        } else {
          g += this.s;
          while (e2 < d.t) {
            g -= d[e2];
            f[e2++] = g & this.DM;
            g >>= this.DB;
          }
          g -= d.s;
        }
        f.s = g < 0 ? -1 : 0;
        if (g < -1) {
          f[e2++] = this.DV + g;
        } else {
          if (g > 0) {
            f[e2++] = g;
          }
        }
        f.t = e2;
        f.clamp();
      }
      function bnpMultiplyTo(c, e2) {
        var b = this.abs(), f = c.abs();
        var d = b.t;
        e2.t = d + f.t;
        while (--d >= 0) {
          e2[d] = 0;
        }
        for (d = 0; d < f.t; ++d) {
          e2[d + b.t] = b.am(0, f[d], e2, d, 0, b.t);
        }
        e2.s = 0;
        e2.clamp();
        if (this.s != c.s) {
          BigInteger.ZERO.subTo(e2, e2);
        }
      }
      function bnpSquareTo(d) {
        var a = this.abs();
        var b = d.t = 2 * a.t;
        while (--b >= 0) {
          d[b] = 0;
        }
        for (b = 0; b < a.t - 1; ++b) {
          var e2 = a.am(b, a[b], d, 2 * b, 0, 1);
          if ((d[b + a.t] += a.am(b + 1, 2 * a[b], d, 2 * b + 1, e2, a.t - b - 1)) >= a.DV) {
            d[b + a.t] -= a.DV;
            d[b + a.t + 1] = 1;
          }
        }
        if (d.t > 0) {
          d[d.t - 1] += a.am(b, a[b], d, 2 * b, 0, 1);
        }
        d.s = 0;
        d.clamp();
      }
      function bnpDivRemTo(n2, h, g) {
        var w = n2.abs();
        if (w.t <= 0) {
          return;
        }
        var k = this.abs();
        if (k.t < w.t) {
          if (h != null) {
            h.fromInt(0);
          }
          if (g != null) {
            this.copyTo(g);
          }
          return;
        }
        if (g == null) {
          g = nbi();
        }
        var d = nbi(), a = this.s, l = n2.s;
        var v = this.DB - nbits(w[w.t - 1]);
        if (v > 0) {
          w.lShiftTo(v, d);
          k.lShiftTo(v, g);
        } else {
          w.copyTo(d);
          k.copyTo(g);
        }
        var p = d.t;
        var b = d[p - 1];
        if (b == 0) {
          return;
        }
        var o2 = b * (1 << this.F1) + (p > 1 ? d[p - 2] >> this.F2 : 0);
        var A = this.FV / o2, z2 = (1 << this.F1) / o2, x = 1 << this.F2;
        var u = g.t, s = u - p, f = h == null ? nbi() : h;
        d.dlShiftTo(s, f);
        if (g.compareTo(f) >= 0) {
          g[g.t++] = 1;
          g.subTo(f, g);
        }
        BigInteger.ONE.dlShiftTo(p, f);
        f.subTo(d, d);
        while (d.t < p) {
          d[d.t++] = 0;
        }
        while (--s >= 0) {
          var c = g[--u] == b ? this.DM : Math.floor(g[u] * A + (g[u - 1] + x) * z2);
          if ((g[u] += d.am(0, c, g, s, 0, p)) < c) {
            d.dlShiftTo(s, f);
            g.subTo(f, g);
            while (g[u] < --c) {
              g.subTo(f, g);
            }
          }
        }
        if (h != null) {
          g.drShiftTo(p, h);
          if (a != l) {
            BigInteger.ZERO.subTo(h, h);
          }
        }
        g.t = p;
        g.clamp();
        if (v > 0) {
          g.rShiftTo(v, g);
        }
        if (a < 0) {
          BigInteger.ZERO.subTo(g, g);
        }
      }
      function bnMod(b) {
        var c = nbi();
        this.abs().divRemTo(b, null, c);
        if (this.s < 0 && c.compareTo(BigInteger.ZERO) > 0) {
          b.subTo(c, c);
        }
        return c;
      }
      function Classic(a) {
        this.m = a;
      }
      function cConvert(a) {
        if (a.s < 0 || a.compareTo(this.m) >= 0) {
          return a.mod(this.m);
        } else {
          return a;
        }
      }
      function cRevert(a) {
        return a;
      }
      function cReduce(a) {
        a.divRemTo(this.m, null, a);
      }
      function cMulTo(a, c, b) {
        a.multiplyTo(c, b);
        this.reduce(b);
      }
      function cSqrTo(a, b) {
        a.squareTo(b);
        this.reduce(b);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1) {
          return 0;
        }
        var a = this[0];
        if ((a & 1) == 0) {
          return 0;
        }
        var b = a & 3;
        b = b * (2 - (a & 15) * b) & 15;
        b = b * (2 - (a & 255) * b) & 255;
        b = b * (2 - ((a & 65535) * b & 65535)) & 65535;
        b = b * (2 - a * b % this.DV) % this.DV;
        return b > 0 ? this.DV - b : -b;
      }
      function Montgomery(a) {
        this.m = a;
        this.mp = a.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << a.DB - 15) - 1;
        this.mt2 = 2 * a.t;
      }
      function montConvert(a) {
        var b = nbi();
        a.abs().dlShiftTo(this.m.t, b);
        b.divRemTo(this.m, null, b);
        if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) {
          this.m.subTo(b, b);
        }
        return b;
      }
      function montRevert(a) {
        var b = nbi();
        a.copyTo(b);
        this.reduce(b);
        return b;
      }
      function montReduce(a) {
        while (a.t <= this.mt2) {
          a[a.t++] = 0;
        }
        for (var c = 0; c < this.m.t; ++c) {
          var b = a[c] & 32767;
          var d = b * this.mpl + ((b * this.mph + (a[c] >> 15) * this.mpl & this.um) << 15) & a.DM;
          b = c + this.m.t;
          a[b] += this.m.am(0, d, a, c, 0, this.m.t);
          while (a[b] >= a.DV) {
            a[b] -= a.DV;
            a[++b]++;
          }
        }
        a.clamp();
        a.drShiftTo(this.m.t, a);
        if (a.compareTo(this.m) >= 0) {
          a.subTo(this.m, a);
        }
      }
      function montSqrTo(a, b) {
        a.squareTo(b);
        this.reduce(b);
      }
      function montMulTo(a, c, b) {
        a.multiplyTo(c, b);
        this.reduce(b);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(h, j) {
        if (h > 4294967295 || h < 1) {
          return BigInteger.ONE;
        }
        var f = nbi(), a = nbi(), d = j.convert(this), c = nbits(h) - 1;
        d.copyTo(f);
        while (--c >= 0) {
          j.sqrTo(f, a);
          if ((h & 1 << c) > 0) {
            j.mulTo(a, d, f);
          } else {
            var b = f;
            f = a;
            a = b;
          }
        }
        return j.revert(f);
      }
      function bnModPowInt(b, a) {
        var c;
        if (b < 256 || a.isEven()) {
          c = new Classic(a);
        } else {
          c = new Montgomery(a);
        }
        return this.exp(b, c);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var a = nbi();
        this.copyTo(a);
        return a;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1) {
            return this[0] - this.DV;
          } else {
            if (this.t == 0) {
              return -1;
            }
          }
        } else {
          if (this.t == 1) {
            return this[0];
          } else {
            if (this.t == 0) {
              return 0;
            }
          }
        }
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(a) {
        return Math.floor(Math.LN2 * this.DB / Math.log(a));
      }
      function bnSigNum() {
        if (this.s < 0) {
          return -1;
        } else {
          if (this.t <= 0 || this.t == 1 && this[0] <= 0) {
            return 0;
          } else {
            return 1;
          }
        }
      }
      function bnpToRadix(c) {
        if (c == null) {
          c = 10;
        }
        if (this.signum() == 0 || c < 2 || c > 36) {
          return "0";
        }
        var f = this.chunkSize(c);
        var e2 = Math.pow(c, f);
        var i = nbv(e2), j = nbi(), h = nbi(), g = "";
        this.divRemTo(i, j, h);
        while (j.signum() > 0) {
          g = (e2 + h.intValue()).toString(c).substr(1) + g;
          j.divRemTo(i, j, h);
        }
        return h.intValue().toString(c) + g;
      }
      function bnpFromRadix(m, h) {
        this.fromInt(0);
        if (h == null) {
          h = 10;
        }
        var f = this.chunkSize(h);
        var g = Math.pow(h, f), e2 = false, a = 0, l = 0;
        for (var c = 0; c < m.length; ++c) {
          var k = intAt(m, c);
          if (k < 0) {
            if (m.charAt(c) == "-" && this.signum() == 0) {
              e2 = true;
            }
            continue;
          }
          l = h * l + k;
          if (++a >= f) {
            this.dMultiply(g);
            this.dAddOffset(l, 0);
            a = 0;
            l = 0;
          }
        }
        if (a > 0) {
          this.dMultiply(Math.pow(h, a));
          this.dAddOffset(l, 0);
        }
        if (e2) {
          BigInteger.ZERO.subTo(this, this);
        }
      }
      function bnpFromNumber(f, e2, h) {
        if ("number" == typeof e2) {
          if (f < 2) {
            this.fromInt(1);
          } else {
            this.fromNumber(f, h);
            if (!this.testBit(f - 1)) {
              this.bitwiseTo(BigInteger.ONE.shiftLeft(f - 1), op_or, this);
            }
            if (this.isEven()) {
              this.dAddOffset(1, 0);
            }
            while (!this.isProbablePrime(e2)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > f) {
                this.subTo(BigInteger.ONE.shiftLeft(f - 1), this);
              }
            }
          }
        } else {
          var d = new Array(), g = f & 7;
          d.length = (f >> 3) + 1;
          e2.nextBytes(d);
          if (g > 0) {
            d[0] &= (1 << g) - 1;
          } else {
            d[0] = 0;
          }
          this.fromString(d, 256);
        }
      }
      function bnToByteArray() {
        var b = this.t, c = new Array();
        c[0] = this.s;
        var e2 = this.DB - b * this.DB % 8, f, a = 0;
        if (b-- > 0) {
          if (e2 < this.DB && (f = this[b] >> e2) != (this.s & this.DM) >> e2) {
            c[a++] = f | this.s << this.DB - e2;
          }
          while (b >= 0) {
            if (e2 < 8) {
              f = (this[b] & (1 << e2) - 1) << 8 - e2;
              f |= this[--b] >> (e2 += this.DB - 8);
            } else {
              f = this[b] >> (e2 -= 8) & 255;
              if (e2 <= 0) {
                e2 += this.DB;
                --b;
              }
            }
            if ((f & 128) != 0) {
              f |= -256;
            }
            if (a == 0 && (this.s & 128) != (f & 128)) {
              ++a;
            }
            if (a > 0 || f != this.s) {
              c[a++] = f;
            }
          }
        }
        return c;
      }
      function bnEquals(b) {
        return this.compareTo(b) == 0;
      }
      function bnMin(b) {
        return this.compareTo(b) < 0 ? this : b;
      }
      function bnMax(b) {
        return this.compareTo(b) > 0 ? this : b;
      }
      function bnpBitwiseTo(c, h, e2) {
        var d, g, b = Math.min(c.t, this.t);
        for (d = 0; d < b; ++d) {
          e2[d] = h(this[d], c[d]);
        }
        if (c.t < this.t) {
          g = c.s & this.DM;
          for (d = b; d < this.t; ++d) {
            e2[d] = h(this[d], g);
          }
          e2.t = this.t;
        } else {
          g = this.s & this.DM;
          for (d = b; d < c.t; ++d) {
            e2[d] = h(g, c[d]);
          }
          e2.t = c.t;
        }
        e2.s = h(this.s, c.s);
        e2.clamp();
      }
      function op_and(a, b) {
        return a & b;
      }
      function bnAnd(b) {
        var c = nbi();
        this.bitwiseTo(b, op_and, c);
        return c;
      }
      function op_or(a, b) {
        return a | b;
      }
      function bnOr(b) {
        var c = nbi();
        this.bitwiseTo(b, op_or, c);
        return c;
      }
      function op_xor(a, b) {
        return a ^ b;
      }
      function bnXor(b) {
        var c = nbi();
        this.bitwiseTo(b, op_xor, c);
        return c;
      }
      function op_andnot(a, b) {
        return a & ~b;
      }
      function bnAndNot(b) {
        var c = nbi();
        this.bitwiseTo(b, op_andnot, c);
        return c;
      }
      function bnNot() {
        var b = nbi();
        for (var a = 0; a < this.t; ++a) {
          b[a] = this.DM & ~this[a];
        }
        b.t = this.t;
        b.s = ~this.s;
        return b;
      }
      function bnShiftLeft(b) {
        var a = nbi();
        if (b < 0) {
          this.rShiftTo(-b, a);
        } else {
          this.lShiftTo(b, a);
        }
        return a;
      }
      function bnShiftRight(b) {
        var a = nbi();
        if (b < 0) {
          this.lShiftTo(-b, a);
        } else {
          this.rShiftTo(b, a);
        }
        return a;
      }
      function lbit(a) {
        if (a == 0) {
          return -1;
        }
        var b = 0;
        if ((a & 65535) == 0) {
          a >>= 16;
          b += 16;
        }
        if ((a & 255) == 0) {
          a >>= 8;
          b += 8;
        }
        if ((a & 15) == 0) {
          a >>= 4;
          b += 4;
        }
        if ((a & 3) == 0) {
          a >>= 2;
          b += 2;
        }
        if ((a & 1) == 0) {
          ++b;
        }
        return b;
      }
      function bnGetLowestSetBit() {
        for (var a = 0; a < this.t; ++a) {
          if (this[a] != 0) {
            return a * this.DB + lbit(this[a]);
          }
        }
        if (this.s < 0) {
          return this.t * this.DB;
        }
        return -1;
      }
      function cbit(a) {
        var b = 0;
        while (a != 0) {
          a &= a - 1;
          ++b;
        }
        return b;
      }
      function bnBitCount() {
        var c = 0, a = this.s & this.DM;
        for (var b = 0; b < this.t; ++b) {
          c += cbit(this[b] ^ a);
        }
        return c;
      }
      function bnTestBit(b) {
        var a = Math.floor(b / this.DB);
        if (a >= this.t) {
          return this.s != 0;
        }
        return (this[a] & 1 << b % this.DB) != 0;
      }
      function bnpChangeBit(c, b) {
        var a = BigInteger.ONE.shiftLeft(c);
        this.bitwiseTo(a, b, a);
        return a;
      }
      function bnSetBit(a) {
        return this.changeBit(a, op_or);
      }
      function bnClearBit(a) {
        return this.changeBit(a, op_andnot);
      }
      function bnFlipBit(a) {
        return this.changeBit(a, op_xor);
      }
      function bnpAddTo(d, f) {
        var e2 = 0, g = 0, b = Math.min(d.t, this.t);
        while (e2 < b) {
          g += this[e2] + d[e2];
          f[e2++] = g & this.DM;
          g >>= this.DB;
        }
        if (d.t < this.t) {
          g += d.s;
          while (e2 < this.t) {
            g += this[e2];
            f[e2++] = g & this.DM;
            g >>= this.DB;
          }
          g += this.s;
        } else {
          g += this.s;
          while (e2 < d.t) {
            g += d[e2];
            f[e2++] = g & this.DM;
            g >>= this.DB;
          }
          g += d.s;
        }
        f.s = g < 0 ? -1 : 0;
        if (g > 0) {
          f[e2++] = g;
        } else {
          if (g < -1) {
            f[e2++] = this.DV + g;
          }
        }
        f.t = e2;
        f.clamp();
      }
      function bnAdd(b) {
        var c = nbi();
        this.addTo(b, c);
        return c;
      }
      function bnSubtract(b) {
        var c = nbi();
        this.subTo(b, c);
        return c;
      }
      function bnMultiply(b) {
        var c = nbi();
        this.multiplyTo(b, c);
        return c;
      }
      function bnSquare() {
        var a = nbi();
        this.squareTo(a);
        return a;
      }
      function bnDivide(b) {
        var c = nbi();
        this.divRemTo(b, c, null);
        return c;
      }
      function bnRemainder(b) {
        var c = nbi();
        this.divRemTo(b, null, c);
        return c;
      }
      function bnDivideAndRemainder(b) {
        var d = nbi(), c = nbi();
        this.divRemTo(b, d, c);
        return new Array(d, c);
      }
      function bnpDMultiply(a) {
        this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(b, a) {
        if (b == 0) {
          return;
        }
        while (this.t <= a) {
          this[this.t++] = 0;
        }
        this[a] += b;
        while (this[a] >= this.DV) {
          this[a] -= this.DV;
          if (++a >= this.t) {
            this[this.t++] = 0;
          }
          ++this[a];
        }
      }
      function NullExp() {
      }
      function nNop(a) {
        return a;
      }
      function nMulTo(a, c, b) {
        a.multiplyTo(c, b);
      }
      function nSqrTo(a, b) {
        a.squareTo(b);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(a) {
        return this.exp(a, new NullExp());
      }
      function bnpMultiplyLowerTo(b, f, e2) {
        var d = Math.min(this.t + b.t, f);
        e2.s = 0;
        e2.t = d;
        while (d > 0) {
          e2[--d] = 0;
        }
        var c;
        for (c = e2.t - this.t; d < c; ++d) {
          e2[d + this.t] = this.am(0, b[d], e2, d, 0, this.t);
        }
        for (c = Math.min(b.t, f); d < c; ++d) {
          this.am(0, b[d], e2, d, 0, f - d);
        }
        e2.clamp();
      }
      function bnpMultiplyUpperTo(b, e2, d) {
        --e2;
        var c = d.t = this.t + b.t - e2;
        d.s = 0;
        while (--c >= 0) {
          d[c] = 0;
        }
        for (c = Math.max(e2 - this.t, 0); c < b.t; ++c) {
          d[this.t + c - e2] = this.am(e2 - c, b[c], d, 0, 0, this.t + c - e2);
        }
        d.clamp();
        d.drShiftTo(1, d);
      }
      function Barrett(a) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * a.t, this.r2);
        this.mu = this.r2.divide(a);
        this.m = a;
      }
      function barrettConvert(a) {
        if (a.s < 0 || a.t > 2 * this.m.t) {
          return a.mod(this.m);
        } else {
          if (a.compareTo(this.m) < 0) {
            return a;
          } else {
            var b = nbi();
            a.copyTo(b);
            this.reduce(b);
            return b;
          }
        }
      }
      function barrettRevert(a) {
        return a;
      }
      function barrettReduce(a) {
        a.drShiftTo(this.m.t - 1, this.r2);
        if (a.t > this.m.t + 1) {
          a.t = this.m.t + 1;
          a.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (a.compareTo(this.r2) < 0) {
          a.dAddOffset(1, this.m.t + 1);
        }
        a.subTo(this.r2, a);
        while (a.compareTo(this.m) >= 0) {
          a.subTo(this.m, a);
        }
      }
      function barrettSqrTo(a, b) {
        a.squareTo(b);
        this.reduce(b);
      }
      function barrettMulTo(a, c, b) {
        a.multiplyTo(c, b);
        this.reduce(b);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(q, f) {
        var o2 = q.bitLength(), h, b = nbv(1), v;
        if (o2 <= 0) {
          return b;
        } else {
          if (o2 < 18) {
            h = 1;
          } else {
            if (o2 < 48) {
              h = 3;
            } else {
              if (o2 < 144) {
                h = 4;
              } else {
                if (o2 < 768) {
                  h = 5;
                } else {
                  h = 6;
                }
              }
            }
          }
        }
        if (o2 < 8) {
          v = new Classic(f);
        } else {
          if (f.isEven()) {
            v = new Barrett(f);
          } else {
            v = new Montgomery(f);
          }
        }
        var p = new Array(), d = 3, s = h - 1, a = (1 << h) - 1;
        p[1] = v.convert(this);
        if (h > 1) {
          var A = nbi();
          v.sqrTo(p[1], A);
          while (d <= a) {
            p[d] = nbi();
            v.mulTo(A, p[d - 2], p[d]);
            d += 2;
          }
        }
        var l = q.t - 1, x, u = true, c = nbi(), y;
        o2 = nbits(q[l]) - 1;
        while (l >= 0) {
          if (o2 >= s) {
            x = q[l] >> o2 - s & a;
          } else {
            x = (q[l] & (1 << o2 + 1) - 1) << s - o2;
            if (l > 0) {
              x |= q[l - 1] >> this.DB + o2 - s;
            }
          }
          d = h;
          while ((x & 1) == 0) {
            x >>= 1;
            --d;
          }
          if ((o2 -= d) < 0) {
            o2 += this.DB;
            --l;
          }
          if (u) {
            p[x].copyTo(b);
            u = false;
          } else {
            while (d > 1) {
              v.sqrTo(b, c);
              v.sqrTo(c, b);
              d -= 2;
            }
            if (d > 0) {
              v.sqrTo(b, c);
            } else {
              y = b;
              b = c;
              c = y;
            }
            v.mulTo(c, p[x], b);
          }
          while (l >= 0 && (q[l] & 1 << o2) == 0) {
            v.sqrTo(b, c);
            y = b;
            b = c;
            c = y;
            if (--o2 < 0) {
              o2 = this.DB - 1;
              --l;
            }
          }
        }
        return v.revert(b);
      }
      function bnGCD(c) {
        var b = this.s < 0 ? this.negate() : this.clone();
        var h = c.s < 0 ? c.negate() : c.clone();
        if (b.compareTo(h) < 0) {
          var e2 = b;
          b = h;
          h = e2;
        }
        var d = b.getLowestSetBit(), f = h.getLowestSetBit();
        if (f < 0) {
          return b;
        }
        if (d < f) {
          f = d;
        }
        if (f > 0) {
          b.rShiftTo(f, b);
          h.rShiftTo(f, h);
        }
        while (b.signum() > 0) {
          if ((d = b.getLowestSetBit()) > 0) {
            b.rShiftTo(d, b);
          }
          if ((d = h.getLowestSetBit()) > 0) {
            h.rShiftTo(d, h);
          }
          if (b.compareTo(h) >= 0) {
            b.subTo(h, b);
            b.rShiftTo(1, b);
          } else {
            h.subTo(b, h);
            h.rShiftTo(1, h);
          }
        }
        if (f > 0) {
          h.lShiftTo(f, h);
        }
        return h;
      }
      function bnpModInt(e2) {
        if (e2 <= 0) {
          return 0;
        }
        var c = this.DV % e2, b = this.s < 0 ? e2 - 1 : 0;
        if (this.t > 0) {
          if (c == 0) {
            b = this[0] % e2;
          } else {
            for (var a = this.t - 1; a >= 0; --a) {
              b = (c * b + this[a]) % e2;
            }
          }
        }
        return b;
      }
      function bnModInverse(f) {
        var j = f.isEven();
        if (this.isEven() && j || f.signum() == 0) {
          return BigInteger.ZERO;
        }
        var i = f.clone(), h = this.clone();
        var g = nbv(1), e2 = nbv(0), l = nbv(0), k = nbv(1);
        while (i.signum() != 0) {
          while (i.isEven()) {
            i.rShiftTo(1, i);
            if (j) {
              if (!g.isEven() || !e2.isEven()) {
                g.addTo(this, g);
                e2.subTo(f, e2);
              }
              g.rShiftTo(1, g);
            } else {
              if (!e2.isEven()) {
                e2.subTo(f, e2);
              }
            }
            e2.rShiftTo(1, e2);
          }
          while (h.isEven()) {
            h.rShiftTo(1, h);
            if (j) {
              if (!l.isEven() || !k.isEven()) {
                l.addTo(this, l);
                k.subTo(f, k);
              }
              l.rShiftTo(1, l);
            } else {
              if (!k.isEven()) {
                k.subTo(f, k);
              }
            }
            k.rShiftTo(1, k);
          }
          if (i.compareTo(h) >= 0) {
            i.subTo(h, i);
            if (j) {
              g.subTo(l, g);
            }
            e2.subTo(k, e2);
          } else {
            h.subTo(i, h);
            if (j) {
              l.subTo(g, l);
            }
            k.subTo(e2, k);
          }
        }
        if (h.compareTo(BigInteger.ONE) != 0) {
          return BigInteger.ZERO;
        }
        if (k.compareTo(f) >= 0) {
          return k.subtract(f);
        }
        if (k.signum() < 0) {
          k.addTo(f, k);
        } else {
          return k;
        }
        if (k.signum() < 0) {
          return k.add(f);
        } else {
          return k;
        }
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(e2) {
        var d, b = this.abs();
        if (b.t == 1 && b[0] <= lowprimes[lowprimes.length - 1]) {
          for (d = 0; d < lowprimes.length; ++d) {
            if (b[0] == lowprimes[d]) {
              return true;
            }
          }
          return false;
        }
        if (b.isEven()) {
          return false;
        }
        d = 1;
        while (d < lowprimes.length) {
          var a = lowprimes[d], c = d + 1;
          while (c < lowprimes.length && a < lplim) {
            a *= lowprimes[c++];
          }
          a = b.modInt(a);
          while (d < c) {
            if (a % lowprimes[d++] == 0) {
              return false;
            }
          }
        }
        return b.millerRabin(e2);
      }
      function bnpMillerRabin(f) {
        var g = this.subtract(BigInteger.ONE);
        var c = g.getLowestSetBit();
        if (c <= 0) {
          return false;
        }
        var h = g.shiftRight(c);
        f = f + 1 >> 1;
        if (f > lowprimes.length) {
          f = lowprimes.length;
        }
        var b = nbi();
        for (var e2 = 0; e2 < f; ++e2) {
          b.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var l = b.modPow(h, this);
          if (l.compareTo(BigInteger.ONE) != 0 && l.compareTo(g) != 0) {
            var d = 1;
            while (d++ < c && l.compareTo(g) != 0) {
              l = l.modPowInt(2, this);
              if (l.compareTo(BigInteger.ONE) == 0) {
                return false;
              }
            }
            if (l.compareTo(g) != 0) {
              return false;
            }
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(d) {
        var c, a, b;
        for (c = 0; c < 256; ++c) {
          this.S[c] = c;
        }
        a = 0;
        for (c = 0; c < 256; ++c) {
          a = a + this.S[c] + d[c % d.length] & 255;
          b = this.S[c];
          this.S[c] = this.S[a];
          this.S[a] = b;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var a;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        a = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = a;
        return this.S[a + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(a) {
        rng_pool[rng_pptr++] ^= a & 255;
        rng_pool[rng_pptr++] ^= a >> 8 & 255;
        rng_pool[rng_pptr++] ^= a >> 16 & 255;
        rng_pool[rng_pptr++] ^= a >> 24 & 255;
        if (rng_pptr >= rng_psize) {
          rng_pptr -= rng_psize;
        }
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        if (window2 !== void 0 && (window2.crypto !== void 0 || window2.msCrypto !== void 0)) {
          crypto2 = window2.crypto || window2.msCrypto;
          if (crypto2.getRandomValues) {
            ua = new Uint8Array(32);
            crypto2.getRandomValues(ua);
            for (t2 = 0; t2 < 32; ++t2) {
              rng_pool[rng_pptr++] = ua[t2];
            }
          } else {
            if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
              z = window2.crypto.random(32);
              for (t2 = 0; t2 < z.length; ++t2) {
                rng_pool[rng_pptr++] = z.charCodeAt(t2) & 255;
              }
            }
          }
        }
        while (rng_pptr < rng_psize) {
          t2 = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t2 >>> 8;
          rng_pool[rng_pptr++] = t2 & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      var t2;
      var crypto2;
      var ua;
      var z;
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
          }
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(b) {
        var a;
        for (a = 0; a < b.length; ++a) {
          b[a] = rng_get_byte();
        }
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function parseBigInt(b, a) {
        return new BigInteger(b, a);
      }
      function pkcs1pad2(e2, h) {
        if (h < e2.length + 11) {
          throw "Message too long for RSA";
          return null;
        }
        var g = new Array();
        var d = e2.length - 1;
        while (d >= 0 && h > 0) {
          var f = e2.charCodeAt(d--);
          if (f < 128) {
            g[--h] = f;
          } else {
            if (f > 127 && f < 2048) {
              g[--h] = f & 63 | 128;
              g[--h] = f >> 6 | 192;
            } else {
              g[--h] = f & 63 | 128;
              g[--h] = f >> 6 & 63 | 128;
              g[--h] = f >> 12 | 224;
            }
          }
        }
        g[--h] = 0;
        var b = new SecureRandom();
        var a = new Array();
        while (h > 2) {
          a[0] = 0;
          while (a[0] == 0) {
            b.nextBytes(a);
          }
          g[--h] = a[0];
        }
        g[--h] = 2;
        g[--h] = 0;
        return new BigInteger(g);
      }
      function oaep_mgf1_arr(c, a, e2) {
        var b = "", d = 0;
        while (b.length < a) {
          b += e2(String.fromCharCode.apply(String, c.concat([(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255])));
          d += 1;
        }
        return b;
      }
      function oaep_pad(q, a, f, l) {
        var c = KJUR.crypto.MessageDigest;
        var o2 = KJUR.crypto.Util;
        var b = null;
        if (!f) {
          f = "sha1";
        }
        if (typeof f === "string") {
          b = c.getCanonicalAlgName(f);
          l = c.getHashLength(b);
          f = function(i) {
            return hextorstr(o2.hashHex(rstrtohex(i), b));
          };
        }
        if (q.length + 2 * l + 2 > a) {
          throw "Message too long for RSA";
        }
        var k = "", e2;
        for (e2 = 0; e2 < a - q.length - 2 * l - 2; e2 += 1) {
          k += "\0";
        }
        var h = f("") + k + "" + q;
        var g = new Array(l);
        new SecureRandom().nextBytes(g);
        var j = oaep_mgf1_arr(g, h.length, f);
        var p = [];
        for (e2 = 0; e2 < h.length; e2 += 1) {
          p[e2] = h.charCodeAt(e2) ^ j.charCodeAt(e2);
        }
        var m = oaep_mgf1_arr(p, g.length, f);
        var d = [0];
        for (e2 = 0; e2 < g.length; e2 += 1) {
          d[e2 + 1] = g[e2] ^ m.charCodeAt(e2);
        }
        return new BigInteger(d.concat(p));
      }
      function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
      }
      function RSASetPublic(b, a) {
        this.isPublic = true;
        this.isPrivate = false;
        if (typeof b !== "string") {
          this.n = b;
          this.e = a;
        } else {
          if (b != null && a != null && b.length > 0 && a.length > 0) {
            this.n = parseBigInt(b, 16);
            this.e = parseInt(a, 16);
          } else {
            throw "Invalid RSA public key";
          }
        }
      }
      function RSADoPublic(a) {
        return a.modPowInt(this.e, this.n);
      }
      function RSAEncrypt(d) {
        var a = pkcs1pad2(d, this.n.bitLength() + 7 >> 3);
        if (a == null) {
          return null;
        }
        var e2 = this.doPublic(a);
        if (e2 == null) {
          return null;
        }
        var b = e2.toString(16);
        if ((b.length & 1) == 0) {
          return b;
        } else {
          return "0" + b;
        }
      }
      function RSAEncryptOAEP(f, e2, b) {
        var a = oaep_pad(f, this.n.bitLength() + 7 >> 3, e2, b);
        if (a == null) {
          return null;
        }
        var g = this.doPublic(a);
        if (g == null) {
          return null;
        }
        var d = g.toString(16);
        if ((d.length & 1) == 0) {
          return d;
        } else {
          return "0" + d;
        }
      }
      RSAKey.prototype.doPublic = RSADoPublic;
      RSAKey.prototype.setPublic = RSASetPublic;
      RSAKey.prototype.encrypt = RSAEncrypt;
      RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
      RSAKey.prototype.type = "RSA";
      function pkcs1unpad2(g, j) {
        var a = g.toByteArray();
        var f = 0;
        while (f < a.length && a[f] == 0) {
          ++f;
        }
        if (a.length - f != j - 1 || a[f] != 2) {
          return null;
        }
        ++f;
        while (a[f] != 0) {
          if (++f >= a.length) {
            return null;
          }
        }
        var e2 = "";
        while (++f < a.length) {
          var h = a[f] & 255;
          if (h < 128) {
            e2 += String.fromCharCode(h);
          } else {
            if (h > 191 && h < 224) {
              e2 += String.fromCharCode((h & 31) << 6 | a[f + 1] & 63);
              ++f;
            } else {
              e2 += String.fromCharCode((h & 15) << 12 | (a[f + 1] & 63) << 6 | a[f + 2] & 63);
              f += 2;
            }
          }
        }
        return e2;
      }
      function oaep_mgf1_str(c, a, e2) {
        var b = "", d = 0;
        while (b.length < a) {
          b += e2(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]));
          d += 1;
        }
        return b;
      }
      function oaep_unpad(o2, b, g, p) {
        var e2 = KJUR.crypto.MessageDigest;
        var r2 = KJUR.crypto.Util;
        var c = null;
        if (!g) {
          g = "sha1";
        }
        if (typeof g === "string") {
          c = e2.getCanonicalAlgName(g);
          p = e2.getHashLength(c);
          g = function(d) {
            return hextorstr(r2.hashHex(rstrtohex(d), c));
          };
        }
        o2 = o2.toByteArray();
        var h;
        for (h = 0; h < o2.length; h += 1) {
          o2[h] &= 255;
        }
        while (o2.length < b) {
          o2.unshift(0);
        }
        o2 = String.fromCharCode.apply(String, o2);
        if (o2.length < 2 * p + 2) {
          throw "Cipher too short";
        }
        var f = o2.substr(1, p);
        var s = o2.substr(p + 1);
        var q = oaep_mgf1_str(s, p, g);
        var k = [], h;
        for (h = 0; h < f.length; h += 1) {
          k[h] = f.charCodeAt(h) ^ q.charCodeAt(h);
        }
        var l = oaep_mgf1_str(String.fromCharCode.apply(String, k), o2.length - p, g);
        var j = [];
        for (h = 0; h < s.length; h += 1) {
          j[h] = s.charCodeAt(h) ^ l.charCodeAt(h);
        }
        j = String.fromCharCode.apply(String, j);
        if (j.substr(0, p) !== g("")) {
          throw "Hash mismatch";
        }
        j = j.substr(p);
        var a = j.indexOf("");
        var m = a != -1 ? j.substr(0, a).lastIndexOf("\0") : -1;
        if (m + 1 != a) {
          throw "Malformed data";
        }
        return j.substr(a + 1);
      }
      function RSASetPrivate(c, a, b) {
        this.isPrivate = true;
        if (typeof c !== "string") {
          this.n = c;
          this.e = a;
          this.d = b;
        } else {
          if (c != null && a != null && c.length > 0 && a.length > 0) {
            this.n = parseBigInt(c, 16);
            this.e = parseInt(a, 16);
            this.d = parseBigInt(b, 16);
          } else {
            throw "Invalid RSA private key";
          }
        }
      }
      function RSASetPrivateEx(g, d, e2, c, b, a, h, f) {
        this.isPrivate = true;
        this.isPublic = false;
        if (g == null) {
          throw "RSASetPrivateEx N == null";
        }
        if (d == null) {
          throw "RSASetPrivateEx E == null";
        }
        if (g.length == 0) {
          throw "RSASetPrivateEx N.length == 0";
        }
        if (d.length == 0) {
          throw "RSASetPrivateEx E.length == 0";
        }
        if (g != null && d != null && g.length > 0 && d.length > 0) {
          this.n = parseBigInt(g, 16);
          this.e = parseInt(d, 16);
          this.d = parseBigInt(e2, 16);
          this.p = parseBigInt(c, 16);
          this.q = parseBigInt(b, 16);
          this.dmp1 = parseBigInt(a, 16);
          this.dmq1 = parseBigInt(h, 16);
          this.coeff = parseBigInt(f, 16);
        } else {
          throw "Invalid RSA private key in RSASetPrivateEx";
        }
      }
      function RSAGenerate(b, l) {
        var a = new SecureRandom();
        var g = b >> 1;
        this.e = parseInt(l, 16);
        var c = new BigInteger(l, 16);
        var d = b / 2 - 100;
        var k = BigInteger.ONE.shiftLeft(d);
        for (; ; ) {
          for (; ; ) {
            this.p = new BigInteger(b - g, 1, a);
            if (this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
              break;
            }
          }
          for (; ; ) {
            this.q = new BigInteger(g, 1, a);
            if (this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
              break;
            }
          }
          if (this.p.compareTo(this.q) <= 0) {
            var j = this.p;
            this.p = this.q;
            this.q = j;
          }
          var h = this.q.subtract(this.p).abs();
          if (h.bitLength() < d || h.compareTo(k) <= 0) {
            continue;
          }
          var i = this.p.subtract(BigInteger.ONE);
          var e2 = this.q.subtract(BigInteger.ONE);
          var f = i.multiply(e2);
          if (f.gcd(c).compareTo(BigInteger.ONE) == 0) {
            this.n = this.p.multiply(this.q);
            if (this.n.bitLength() == b) {
              this.d = c.modInverse(f);
              this.dmp1 = this.d.mod(i);
              this.dmq1 = this.d.mod(e2);
              this.coeff = this.q.modInverse(this.p);
              break;
            }
          }
        }
        this.isPrivate = true;
      }
      function RSADoPrivate(a) {
        if (this.p == null || this.q == null) {
          return a.modPow(this.d, this.n);
        }
        var c = a.mod(this.p).modPow(this.dmp1, this.p);
        var b = a.mod(this.q).modPow(this.dmq1, this.q);
        while (c.compareTo(b) < 0) {
          c = c.add(this.p);
        }
        return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b);
      }
      function RSADecrypt(b) {
        if (b.length != Math.ceil(this.n.bitLength() / 4)) {
          throw new Error("wrong ctext length");
        }
        var d = parseBigInt(b, 16);
        var a = this.doPrivate(d);
        if (a == null) {
          return null;
        }
        return pkcs1unpad2(a, this.n.bitLength() + 7 >> 3);
      }
      function RSADecryptOAEP(e2, d, b) {
        if (e2.length != Math.ceil(this.n.bitLength() / 4)) {
          throw new Error("wrong ctext length");
        }
        var f = parseBigInt(e2, 16);
        var a = this.doPrivate(f);
        if (a == null) {
          return null;
        }
        return oaep_unpad(a, this.n.bitLength() + 7 >> 3, d, b);
      }
      RSAKey.prototype.doPrivate = RSADoPrivate;
      RSAKey.prototype.setPrivate = RSASetPrivate;
      RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
      RSAKey.prototype.generate = RSAGenerate;
      RSAKey.prototype.decrypt = RSADecrypt;
      RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
      function ECFieldElementFp(b, a) {
        this.x = a;
        this.q = b;
      }
      function feFpEquals(a) {
        if (a == this) {
          return true;
        }
        return this.q.equals(a.q) && this.x.equals(a.x);
      }
      function feFpToBigInteger() {
        return this.x;
      }
      function feFpNegate() {
        return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
      }
      function feFpAdd(a) {
        return new ECFieldElementFp(this.q, this.x.add(a.toBigInteger()).mod(this.q));
      }
      function feFpSubtract(a) {
        return new ECFieldElementFp(this.q, this.x.subtract(a.toBigInteger()).mod(this.q));
      }
      function feFpMultiply(a) {
        return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger()).mod(this.q));
      }
      function feFpSquare() {
        return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
      }
      function feFpDivide(a) {
        return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q));
      }
      ECFieldElementFp.prototype.equals = feFpEquals;
      ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
      ECFieldElementFp.prototype.negate = feFpNegate;
      ECFieldElementFp.prototype.add = feFpAdd;
      ECFieldElementFp.prototype.subtract = feFpSubtract;
      ECFieldElementFp.prototype.multiply = feFpMultiply;
      ECFieldElementFp.prototype.square = feFpSquare;
      ECFieldElementFp.prototype.divide = feFpDivide;
      ECFieldElementFp.prototype.sqrt = function() {
        return new ECFieldElementFp(this.q, this.x.sqrt().mod(this.q));
      };
      function ECPointFp(c, a, d, b) {
        this.curve = c;
        this.x = a;
        this.y = d;
        if (b == null) {
          this.z = BigInteger.ONE;
        } else {
          this.z = b;
        }
        this.zinv = null;
      }
      function pointFpGetX() {
        if (this.zinv == null) {
          this.zinv = this.z.modInverse(this.curve.q);
        }
        return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
      }
      function pointFpGetY() {
        if (this.zinv == null) {
          this.zinv = this.z.modInverse(this.curve.q);
        }
        return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
      }
      function pointFpEquals(a) {
        if (a == this) {
          return true;
        }
        if (this.isInfinity()) {
          return a.isInfinity();
        }
        if (a.isInfinity()) {
          return this.isInfinity();
        }
        var c, b;
        c = a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);
        if (!c.equals(BigInteger.ZERO)) {
          return false;
        }
        b = a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);
        return b.equals(BigInteger.ZERO);
      }
      function pointFpIsInfinity() {
        if (this.x == null && this.y == null) {
          return true;
        }
        return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
      }
      function pointFpNegate() {
        return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
      }
      function pointFpAdd(l) {
        if (this.isInfinity()) {
          return l;
        }
        if (l.isInfinity()) {
          return this;
        }
        var p = l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);
        var o2 = l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);
        if (BigInteger.ZERO.equals(o2)) {
          if (BigInteger.ZERO.equals(p)) {
            return this.twice();
          }
          return this.curve.getInfinity();
        }
        var j = new BigInteger("3");
        var e2 = this.x.toBigInteger();
        var n2 = this.y.toBigInteger();
        var c = l.x.toBigInteger();
        var k = l.y.toBigInteger();
        var m = o2.square();
        var i = m.multiply(o2);
        var d = e2.multiply(m);
        var g = p.square().multiply(this.z);
        var a = g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o2).mod(this.curve.q);
        var h = d.multiply(j).multiply(p).subtract(n2.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);
        var f = i.multiply(this.z).multiply(l.z).mod(this.curve.q);
        return new ECPointFp(this.curve, this.curve.fromBigInteger(a), this.curve.fromBigInteger(h), f);
      }
      function pointFpTwice() {
        if (this.isInfinity()) {
          return this;
        }
        if (this.y.toBigInteger().signum() == 0) {
          return this.curve.getInfinity();
        }
        var g = new BigInteger("3");
        var c = this.x.toBigInteger();
        var h = this.y.toBigInteger();
        var e2 = h.multiply(this.z);
        var j = e2.multiply(h).mod(this.curve.q);
        var i = this.curve.a.toBigInteger();
        var k = c.square().multiply(g);
        if (!BigInteger.ZERO.equals(i)) {
          k = k.add(this.z.square().multiply(i));
        }
        k = k.mod(this.curve.q);
        var b = k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e2).mod(this.curve.q);
        var f = k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);
        var d = e2.square().multiply(e2).shiftLeft(3).mod(this.curve.q);
        return new ECPointFp(this.curve, this.curve.fromBigInteger(b), this.curve.fromBigInteger(f), d);
      }
      function pointFpMultiply(d) {
        if (this.isInfinity()) {
          return this;
        }
        if (d.signum() == 0) {
          return this.curve.getInfinity();
        }
        var m = d;
        var l = m.multiply(new BigInteger("3"));
        var b = this.negate();
        var j = this;
        var q = this.curve.q.subtract(d);
        var o2 = q.multiply(new BigInteger("3"));
        var c = new ECPointFp(this.curve, this.x, this.y);
        var a = c.negate();
        var g;
        for (g = l.bitLength() - 2; g > 0; --g) {
          j = j.twice();
          var n2 = l.testBit(g);
          var f = m.testBit(g);
          if (n2 != f) {
            j = j.add(n2 ? this : b);
          }
        }
        for (g = o2.bitLength() - 2; g > 0; --g) {
          c = c.twice();
          var p = o2.testBit(g);
          var r2 = q.testBit(g);
          if (p != r2) {
            c = c.add(p ? c : a);
          }
        }
        return j;
      }
      function pointFpMultiplyTwo(c, a, b) {
        var d;
        if (c.bitLength() > b.bitLength()) {
          d = c.bitLength() - 1;
        } else {
          d = b.bitLength() - 1;
        }
        var f = this.curve.getInfinity();
        var e2 = this.add(a);
        while (d >= 0) {
          f = f.twice();
          if (c.testBit(d)) {
            if (b.testBit(d)) {
              f = f.add(e2);
            } else {
              f = f.add(this);
            }
          } else {
            if (b.testBit(d)) {
              f = f.add(a);
            }
          }
          --d;
        }
        return f;
      }
      ECPointFp.prototype.getX = pointFpGetX;
      ECPointFp.prototype.getY = pointFpGetY;
      ECPointFp.prototype.equals = pointFpEquals;
      ECPointFp.prototype.isInfinity = pointFpIsInfinity;
      ECPointFp.prototype.negate = pointFpNegate;
      ECPointFp.prototype.add = pointFpAdd;
      ECPointFp.prototype.twice = pointFpTwice;
      ECPointFp.prototype.multiply = pointFpMultiply;
      ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
      function ECCurveFp(e2, d, c) {
        this.q = e2;
        this.a = this.fromBigInteger(d);
        this.b = this.fromBigInteger(c);
        this.infinity = new ECPointFp(this, null, null);
      }
      function curveFpGetQ() {
        return this.q;
      }
      function curveFpGetA() {
        return this.a;
      }
      function curveFpGetB() {
        return this.b;
      }
      function curveFpEquals(a) {
        if (a == this) {
          return true;
        }
        return this.q.equals(a.q) && this.a.equals(a.a) && this.b.equals(a.b);
      }
      function curveFpGetInfinity() {
        return this.infinity;
      }
      function curveFpFromBigInteger(a) {
        return new ECFieldElementFp(this.q, a);
      }
      function curveFpDecodePointHex(m) {
        switch (parseInt(m.substr(0, 2), 16)) {
          case 0:
            return this.infinity;
          case 2:
          case 3:
            var c = m.substr(0, 2);
            var l = m.substr(2);
            var j = this.fromBigInteger(new BigInteger(k, 16));
            var i = this.getA();
            var h = this.getB();
            var e2 = j.square().add(i).multiply(j).add(h);
            var g = e2.sqrt();
            if (c == "03") {
              g = g.negate();
            }
            return new ECPointFp(this, j, g);
          case 4:
          case 6:
          case 7:
            var d = (m.length - 2) / 2;
            var k = m.substr(2, d);
            var f = m.substr(d + 2, d);
            return new ECPointFp(this, this.fromBigInteger(new BigInteger(k, 16)), this.fromBigInteger(new BigInteger(f, 16)));
          default:
            return null;
        }
      }
      ECCurveFp.prototype.getQ = curveFpGetQ;
      ECCurveFp.prototype.getA = curveFpGetA;
      ECCurveFp.prototype.getB = curveFpGetB;
      ECCurveFp.prototype.equals = curveFpEquals;
      ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
      ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
      ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
      ECFieldElementFp.prototype.getByteLength = function() {
        return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
      };
      ECPointFp.prototype.getEncoded = function(c) {
        var d = function(h, f) {
          var g = h.toByteArrayUnsigned();
          if (f < g.length) {
            g = g.slice(g.length - f);
          } else {
            while (f > g.length) {
              g.unshift(0);
            }
          }
          return g;
        };
        var a = this.getX().toBigInteger();
        var e2 = this.getY().toBigInteger();
        var b = d(a, 32);
        if (c) {
          if (e2.isEven()) {
            b.unshift(2);
          } else {
            b.unshift(3);
          }
        } else {
          b.unshift(4);
          b = b.concat(d(e2, 32));
        }
        return b;
      };
      ECPointFp.decodeFrom = function(g, c) {
        var f = c[0];
        var e2 = c.length - 1;
        var d = c.slice(1, 1 + e2 / 2);
        var b = c.slice(1 + e2 / 2, 1 + e2);
        d.unshift(0);
        b.unshift(0);
        var a = new BigInteger(d);
        var h = new BigInteger(b);
        return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
      };
      ECPointFp.decodeFromHex = function(g, c) {
        var f = c.substr(0, 2);
        var e2 = c.length - 2;
        var d = c.substr(2, e2 / 2);
        var b = c.substr(2 + e2 / 2, e2 / 2);
        var a = new BigInteger(d, 16);
        var h = new BigInteger(b, 16);
        return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
      };
      ECPointFp.prototype.add2D = function(c) {
        if (this.isInfinity()) {
          return c;
        }
        if (c.isInfinity()) {
          return this;
        }
        if (this.x.equals(c.x)) {
          if (this.y.equals(c.y)) {
            return this.twice();
          }
          return this.curve.getInfinity();
        }
        var g = c.x.subtract(this.x);
        var e2 = c.y.subtract(this.y);
        var a = e2.divide(g);
        var d = a.square().subtract(this.x).subtract(c.x);
        var f = a.multiply(this.x.subtract(d)).subtract(this.y);
        return new ECPointFp(this.curve, d, f);
      };
      ECPointFp.prototype.twice2D = function() {
        if (this.isInfinity()) {
          return this;
        }
        if (this.y.toBigInteger().signum() == 0) {
          return this.curve.getInfinity();
        }
        var b = this.curve.fromBigInteger(BigInteger.valueOf(2));
        var e2 = this.curve.fromBigInteger(BigInteger.valueOf(3));
        var a = this.x.square().multiply(e2).add(this.curve.a).divide(this.y.multiply(b));
        var c = a.square().subtract(this.x.multiply(b));
        var d = a.multiply(this.x.subtract(c)).subtract(this.y);
        return new ECPointFp(this.curve, c, d);
      };
      ECPointFp.prototype.multiply2D = function(b) {
        if (this.isInfinity()) {
          return this;
        }
        if (b.signum() == 0) {
          return this.curve.getInfinity();
        }
        var g = b;
        var f = g.multiply(new BigInteger("3"));
        var l = this.negate();
        var d = this;
        var c;
        for (c = f.bitLength() - 2; c > 0; --c) {
          d = d.twice();
          var a = f.testBit(c);
          var j = g.testBit(c);
          if (a != j) {
            d = d.add2D(a ? this : l);
          }
        }
        return d;
      };
      ECPointFp.prototype.isOnCurve = function() {
        var d = this.getX().toBigInteger();
        var i = this.getY().toBigInteger();
        var f = this.curve.getA().toBigInteger();
        var c = this.curve.getB().toBigInteger();
        var h = this.curve.getQ();
        var e2 = i.multiply(i).mod(h);
        var g = d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);
        return e2.equals(g);
      };
      ECPointFp.prototype.toString = function() {
        return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")";
      };
      ECPointFp.prototype.validate = function() {
        var c = this.curve.getQ();
        if (this.isInfinity()) {
          throw new Error("Point is at infinity.");
        }
        var a = this.getX().toBigInteger();
        var b = this.getY().toBigInteger();
        if (a.compareTo(BigInteger.ONE) < 0 || a.compareTo(c.subtract(BigInteger.ONE)) > 0) {
          throw new Error("x coordinate out of bounds");
        }
        if (b.compareTo(BigInteger.ONE) < 0 || b.compareTo(c.subtract(BigInteger.ONE)) > 0) {
          throw new Error("y coordinate out of bounds");
        }
        if (!this.isOnCurve()) {
          throw new Error("Point is not on the curve.");
        }
        if (this.multiply(c).isInfinity()) {
          throw new Error("Point is not a scalar multiple of G.");
        }
        return true;
      };
      var jsonParse = function() {
        var e2 = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";
        var j = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
        var i = '(?:"' + j + '*")';
        var d = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + e2 + "|" + i + ")", "g");
        var k = new RegExp("\\\\(?:([^u])|u(.{4}))", "g");
        var g = { '"': '"', "/": "/", "\\": "\\", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" };
        function h(l, m, n2) {
          return m ? g[m] : String.fromCharCode(parseInt(n2, 16));
        }
        var c = new String("");
        var a = "\\";
        var f = { "{": Object, "[": Array };
        var b = Object.hasOwnProperty;
        return function(u, q) {
          var p = u.match(d);
          var x;
          var v = p[0];
          var l = false;
          if ("{" === v) {
            x = {};
          } else {
            if ("[" === v) {
              x = [];
            } else {
              x = [];
              l = true;
            }
          }
          var t3;
          var r2 = [x];
          for (var o2 = 1 - l, m = p.length; o2 < m; ++o2) {
            v = p[o2];
            var w;
            switch (v.charCodeAt(0)) {
              default:
                w = r2[0];
                w[t3 || w.length] = +v;
                t3 = void 0;
                break;
              case 34:
                v = v.substring(1, v.length - 1);
                if (v.indexOf(a) !== -1) {
                  v = v.replace(k, h);
                }
                w = r2[0];
                if (!t3) {
                  if (w instanceof Array) {
                    t3 = w.length;
                  } else {
                    t3 = v || c;
                    break;
                  }
                }
                w[t3] = v;
                t3 = void 0;
                break;
              case 91:
                w = r2[0];
                r2.unshift(w[t3 || w.length] = []);
                t3 = void 0;
                break;
              case 93:
                r2.shift();
                break;
              case 102:
                w = r2[0];
                w[t3 || w.length] = false;
                t3 = void 0;
                break;
              case 110:
                w = r2[0];
                w[t3 || w.length] = null;
                t3 = void 0;
                break;
              case 116:
                w = r2[0];
                w[t3 || w.length] = true;
                t3 = void 0;
                break;
              case 123:
                w = r2[0];
                r2.unshift(w[t3 || w.length] = {});
                t3 = void 0;
                break;
              case 125:
                r2.shift();
                break;
            }
          }
          if (l) {
            if (r2.length !== 1) {
              throw new Error();
            }
            x = x[0];
          } else {
            if (r2.length) {
              throw new Error();
            }
          }
          if (q) {
            var s = function(C, B) {
              var D = C[B];
              if (D && typeof D === "object") {
                var n2 = null;
                for (var z2 in D) {
                  if (b.call(D, z2) && D !== C) {
                    var y = s(D, z2);
                    if (y !== void 0) {
                      D[z2] = y;
                    } else {
                      if (!n2) {
                        n2 = [];
                      }
                      n2.push(z2);
                    }
                  }
                }
                if (n2) {
                  for (var A = n2.length; --A >= 0; ) {
                    delete D[n2[A]];
                  }
                }
              }
              return q.call(C, B, D);
            };
            x = s({ "": x }, "");
          }
          return x;
        };
      }();
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      KJUR.asn1.ASN1Util = new function() {
        this.integerToByteHex = function(a) {
          var b = a.toString(16);
          if (b.length % 2 == 1) {
            b = "0" + b;
          }
          return b;
        };
        this.bigIntToMinTwosComplementsHex = function(j) {
          var f = j.toString(16);
          if (f.substr(0, 1) != "-") {
            if (f.length % 2 == 1) {
              f = "0" + f;
            } else {
              if (!f.match(/^[0-7]/)) {
                f = "00" + f;
              }
            }
          } else {
            var a = f.substr(1);
            var e2 = a.length;
            if (e2 % 2 == 1) {
              e2 += 1;
            } else {
              if (!f.match(/^[0-7]/)) {
                e2 += 2;
              }
            }
            var g = "";
            for (var d = 0; d < e2; d++) {
              g += "f";
            }
            var c = new BigInteger(g, 16);
            var b = c.xor(j).add(BigInteger.ONE);
            f = b.toString(16).replace(/^-/, "");
          }
          return f;
        };
        this.getPEMStringFromHex = function(a, b) {
          return hextopem(a, b);
        };
        this.newObject = function(k) {
          var F = KJUR, o2 = F.asn1, v = o2.ASN1Object, B = o2.DERBoolean, e2 = o2.DERInteger, t3 = o2.DERBitString, h = o2.DEROctetString, x = o2.DERNull, y = o2.DERObjectIdentifier, m = o2.DEREnumerated, g = o2.DERUTF8String, f = o2.DERNumericString, A = o2.DERPrintableString, w = o2.DERTeletexString, q = o2.DERIA5String, E = o2.DERUTCTime, j = o2.DERGeneralizedTime, b = o2.DERVisibleString, l = o2.DERBMPString, n2 = o2.DERSequence, c = o2.DERSet, s = o2.DERTaggedObject, p = o2.ASN1Util.newObject;
          if (k instanceof o2.ASN1Object) {
            return k;
          }
          var u = Object.keys(k);
          if (u.length != 1) {
            throw new Error("key of param shall be only one.");
          }
          var H = u[0];
          if (":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + H + ":") == -1) {
            throw new Error("undefined key: " + H);
          }
          if (H == "bool") {
            return new B(k[H]);
          }
          if (H == "int") {
            return new e2(k[H]);
          }
          if (H == "bitstr") {
            return new t3(k[H]);
          }
          if (H == "octstr") {
            return new h(k[H]);
          }
          if (H == "null") {
            return new x(k[H]);
          }
          if (H == "oid") {
            return new y(k[H]);
          }
          if (H == "enum") {
            return new m(k[H]);
          }
          if (H == "utf8str") {
            return new g(k[H]);
          }
          if (H == "numstr") {
            return new f(k[H]);
          }
          if (H == "prnstr") {
            return new A(k[H]);
          }
          if (H == "telstr") {
            return new w(k[H]);
          }
          if (H == "ia5str") {
            return new q(k[H]);
          }
          if (H == "utctime") {
            return new E(k[H]);
          }
          if (H == "gentime") {
            return new j(k[H]);
          }
          if (H == "visstr") {
            return new b(k[H]);
          }
          if (H == "bmpstr") {
            return new l(k[H]);
          }
          if (H == "asn1") {
            return new v(k[H]);
          }
          if (H == "seq") {
            var d = k[H];
            var G = [];
            for (var z2 = 0; z2 < d.length; z2++) {
              var D = p(d[z2]);
              G.push(D);
            }
            return new n2({ array: G });
          }
          if (H == "set") {
            var d = k[H];
            var G = [];
            for (var z2 = 0; z2 < d.length; z2++) {
              var D = p(d[z2]);
              G.push(D);
            }
            return new c({ array: G });
          }
          if (H == "tag") {
            var C = k[H];
            if (Object.prototype.toString.call(C) === "[object Array]" && C.length == 3) {
              var r2 = p(C[2]);
              return new s({ tag: C[0], explicit: C[1], obj: r2 });
            } else {
              return new s(C);
            }
          }
        };
        this.jsonToASN1HEX = function(b) {
          var a = this.newObject(b);
          return a.tohex();
        };
      }();
      KJUR.asn1.ASN1Util.oidHexToInt = function(a) {
        var j = "";
        var k = parseInt(a.substr(0, 2), 16);
        var d = Math.floor(k / 40);
        var c = k % 40;
        var j = d + "." + c;
        var e2 = "";
        for (var f = 2; f < a.length; f += 2) {
          var g = parseInt(a.substr(f, 2), 16);
          var h = ("00000000" + g.toString(2)).slice(-8);
          e2 = e2 + h.substr(1, 7);
          if (h.substr(0, 1) == "0") {
            var b = new BigInteger(e2, 2);
            j = j + "." + b.toString(10);
            e2 = "";
          }
        }
        return j;
      };
      KJUR.asn1.ASN1Util.oidIntToHex = function(f) {
        var e2 = function(a) {
          var k = a.toString(16);
          if (k.length == 1) {
            k = "0" + k;
          }
          return k;
        };
        var d = function(o2) {
          var n2 = "";
          var k = new BigInteger(o2, 10);
          var a = k.toString(2);
          var l = 7 - a.length % 7;
          if (l == 7) {
            l = 0;
          }
          var q = "";
          for (var m = 0; m < l; m++) {
            q += "0";
          }
          a = q + a;
          for (var m = 0; m < a.length - 1; m += 7) {
            var p = a.substr(m, 7);
            if (m != a.length - 7) {
              p = "1" + p;
            }
            n2 += e2(parseInt(p, 2));
          }
          return n2;
        };
        if (!f.match(/^[0-9.]+$/)) {
          throw "malformed oid string: " + f;
        }
        var g = "";
        var b = f.split(".");
        var j = parseInt(b[0]) * 40 + parseInt(b[1]);
        g += e2(j);
        b.splice(0, 2);
        for (var c = 0; c < b.length; c++) {
          g += d(b[c]);
        }
        return g;
      };
      KJUR.asn1.ASN1Object = function(e2) {
        var c = true;
        var b = null;
        var d = "00";
        var f = "00";
        var a = "";
        this.params = null;
        this.getLengthHexFromValue = function() {
          if (typeof this.hV == "undefined" || this.hV == null) {
            throw new Error("this.hV is null or undefined");
          }
          if (this.hV.length % 2 == 1) {
            throw new Error("value hex must be even length: n=" + a.length + ",v=" + this.hV);
          }
          var j = this.hV.length / 2;
          var i = j.toString(16);
          if (i.length % 2 == 1) {
            i = "0" + i;
          }
          if (j < 128) {
            return i;
          } else {
            var h = i.length / 2;
            if (h > 15) {
              throw new Error("ASN.1 length too long to represent by 8x: n = " + j.toString(16));
            }
            var g = 128 + h;
            return g.toString(16) + i;
          }
        };
        this.tohex = function() {
          if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
          }
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.getValueHex = function() {
          this.tohex();
          return this.hV;
        };
        this.getFreshValueHex = function() {
          return "";
        };
        this.setByParam = function(g) {
          this.params = g;
        };
        if (e2 != void 0) {
          if (e2.tlv != void 0) {
            this.hTLV = e2.tlv;
            this.isModified = false;
          }
        }
      };
      KJUR.asn1.DERAbstractString = function(c) {
        KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
        var b = null;
        var a = null;
        this.getString = function() {
          return this.s;
        };
        this.setString = function(d) {
          this.hTLV = null;
          this.isModified = true;
          this.s = d;
          this.hV = utf8tohex(this.s).toLowerCase();
        };
        this.setStringHex = function(d) {
          this.hTLV = null;
          this.isModified = true;
          this.s = null;
          this.hV = d;
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
        if (typeof c != "undefined") {
          if (typeof c == "string") {
            this.setString(c);
          } else {
            if (typeof c.str != "undefined") {
              this.setString(c.str);
            } else {
              if (typeof c.hex != "undefined") {
                this.setStringHex(c.hex);
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERAbstractTime = function(c) {
        KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
        var b = null;
        var a = null;
        this.localDateToUTC = function(g) {
          var e2 = g.getTime() + g.getTimezoneOffset() * 6e4;
          var f = new Date(e2);
          return f;
        };
        this.formatDate = function(m, o2, e2) {
          var g = this.zeroPadding;
          var n2 = this.localDateToUTC(m);
          var p = String(n2.getFullYear());
          if (o2 == "utc") {
            p = p.substr(2, 2);
          }
          var l = g(String(n2.getMonth() + 1), 2);
          var q = g(String(n2.getDate()), 2);
          var h = g(String(n2.getHours()), 2);
          var i = g(String(n2.getMinutes()), 2);
          var j = g(String(n2.getSeconds()), 2);
          var r2 = p + l + q + h + i + j;
          if (e2 === true) {
            var f = n2.getMilliseconds();
            if (f != 0) {
              var k = g(String(f), 3);
              k = k.replace(/[0]+$/, "");
              r2 = r2 + "." + k;
            }
          }
          return r2 + "Z";
        };
        this.zeroPadding = function(e2, d) {
          if (e2.length >= d) {
            return e2;
          }
          return new Array(d - e2.length + 1).join("0") + e2;
        };
        this.setByParam = function(d) {
          this.hV = null;
          this.hTLV = null;
          this.params = d;
        };
        this.getString = function() {
          return void 0;
        };
        this.setString = function(d) {
          this.hTLV = null;
          this.isModified = true;
          if (this.params == void 0) {
            this.params = {};
          }
          this.params.str = d;
        };
        this.setByDate = function(d) {
          this.hTLV = null;
          this.isModified = true;
          if (this.params == void 0) {
            this.params = {};
          }
          this.params.date = d;
        };
        this.setByDateValue = function(h, j, e2, d, f, g) {
          var i = new Date(Date.UTC(h, j - 1, e2, d, f, g, 0));
          this.setByDate(i);
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
      };
      extendClass(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERAbstractStructured = function(b) {
        KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
        var a = null;
        this.setByASN1ObjectArray = function(c) {
          this.hTLV = null;
          this.isModified = true;
          this.asn1Array = c;
        };
        this.appendASN1Object = function(c) {
          this.hTLV = null;
          this.isModified = true;
          this.asn1Array.push(c);
        };
        this.asn1Array = new Array();
        if (typeof b != "undefined") {
          if (typeof b.array != "undefined") {
            this.asn1Array = b.array;
          }
        }
      };
      extendClass(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERBoolean = function(a) {
        KJUR.asn1.DERBoolean.superclass.constructor.call(this);
        this.hT = "01";
        if (a == false) {
          this.hTLV = "010100";
        } else {
          this.hTLV = "0101ff";
        }
      };
      extendClass(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERInteger = function(a) {
        KJUR.asn1.DERInteger.superclass.constructor.call(this);
        this.hT = "02";
        this.setByBigInteger = function(b) {
          this.hTLV = null;
          this.isModified = true;
          this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);
        };
        this.setByInteger = function(c) {
          var b = new BigInteger(String(c), 10);
          this.setByBigInteger(b);
        };
        this.setValueHex = function(b) {
          this.hV = b;
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
        if (typeof a != "undefined") {
          if (typeof a.bigint != "undefined") {
            this.setByBigInteger(a.bigint);
          } else {
            if (typeof a["int"] != "undefined") {
              this.setByInteger(a["int"]);
            } else {
              if (typeof a == "number") {
                this.setByInteger(a);
              } else {
                if (typeof a.hex != "undefined") {
                  this.setValueHex(a.hex);
                }
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERBitString = function(b) {
        if (b !== void 0 && typeof b.obj !== "undefined") {
          var a = KJUR.asn1.ASN1Util.newObject(b.obj);
          b.hex = "00" + a.tohex();
        }
        KJUR.asn1.DERBitString.superclass.constructor.call(this);
        this.hT = "03";
        this.setHexValueIncludingUnusedBits = function(c) {
          this.hTLV = null;
          this.isModified = true;
          this.hV = c;
        };
        this.setUnusedBitsAndHexValue = function(c, e2) {
          if (c < 0 || 7 < c) {
            throw "unused bits shall be from 0 to 7: u = " + c;
          }
          var d = "0" + c;
          this.hTLV = null;
          this.isModified = true;
          this.hV = d + e2;
        };
        this.setByBinaryString = function(e2) {
          e2 = e2.replace(/0+$/, "");
          var f = 8 - e2.length % 8;
          if (f == 8) {
            f = 0;
          }
          e2 += "0000000".substr(0, f);
          var j = "";
          for (var g = 0; g < e2.length - 1; g += 8) {
            var d = e2.substr(g, 8);
            var c = parseInt(d, 2).toString(16);
            if (c.length == 1) {
              c = "0" + c;
            }
            j += c;
          }
          this.hTLV = null;
          this.isModified = true;
          this.hV = "0" + f + j;
        };
        this.setByBooleanArray = function(e2) {
          var d = "";
          for (var c = 0; c < e2.length; c++) {
            if (e2[c] == true) {
              d += "1";
            } else {
              d += "0";
            }
          }
          this.setByBinaryString(d);
        };
        this.newFalseArray = function(e2) {
          var c = new Array(e2);
          for (var d = 0; d < e2; d++) {
            c[d] = false;
          }
          return c;
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
        if (typeof b != "undefined") {
          if (typeof b == "string" && b.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(b);
          } else {
            if (typeof b.hex != "undefined") {
              this.setHexValueIncludingUnusedBits(b.hex);
            } else {
              if (typeof b.bin != "undefined") {
                this.setByBinaryString(b.bin);
              } else {
                if (typeof b.array != "undefined") {
                  this.setByBooleanArray(b.array);
                }
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
      KJUR.asn1.DEROctetString = function(b) {
        if (b !== void 0 && typeof b.obj !== "undefined") {
          var a = KJUR.asn1.ASN1Util.newObject(b.obj);
          b.hex = a.tohex();
        }
        KJUR.asn1.DEROctetString.superclass.constructor.call(this, b);
        this.hT = "04";
      };
      extendClass(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERNull = function() {
        KJUR.asn1.DERNull.superclass.constructor.call(this);
        this.hT = "05";
        this.hTLV = "0500";
      };
      extendClass(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERObjectIdentifier = function(a) {
        KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
        this.hT = "06";
        this.setValueHex = function(b) {
          this.hTLV = null;
          this.isModified = true;
          this.s = null;
          this.hV = b;
        };
        this.setValueOidString = function(b) {
          var c = oidtohex(b);
          if (c == null) {
            throw new Error("malformed oid string: " + b);
          }
          this.hTLV = null;
          this.isModified = true;
          this.s = null;
          this.hV = c;
        };
        this.setValueName = function(c) {
          var b = KJUR.asn1.x509.OID.name2oid(c);
          if (b !== "") {
            this.setValueOidString(b);
          } else {
            throw new Error("DERObjectIdentifier oidName undefined: " + c);
          }
        };
        this.setValueNameOrOid = function(b) {
          if (b.match(/^[0-2].[0-9.]+$/)) {
            this.setValueOidString(b);
          } else {
            this.setValueName(b);
          }
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
        this.setByParam = function(b) {
          if (typeof b === "string") {
            this.setValueNameOrOid(b);
          } else {
            if (b.oid !== void 0) {
              this.setValueNameOrOid(b.oid);
            } else {
              if (b.name !== void 0) {
                this.setValueNameOrOid(b.name);
              } else {
                if (b.hex !== void 0) {
                  this.setValueHex(b.hex);
                }
              }
            }
          }
        };
        if (a !== void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
      KJUR.asn1.DEREnumerated = function(a) {
        KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
        this.hT = "0a";
        this.setByBigInteger = function(b) {
          this.hTLV = null;
          this.isModified = true;
          this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b);
        };
        this.setByInteger = function(c) {
          var b = new BigInteger(String(c), 10);
          this.setByBigInteger(b);
        };
        this.setValueHex = function(b) {
          this.hV = b;
        };
        this.getFreshValueHex = function() {
          return this.hV;
        };
        if (typeof a != "undefined") {
          if (typeof a["int"] != "undefined") {
            this.setByInteger(a["int"]);
          } else {
            if (typeof a == "number") {
              this.setByInteger(a);
            } else {
              if (typeof a.hex != "undefined") {
                this.setValueHex(a.hex);
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
      KJUR.asn1.DERUTF8String = function(a) {
        KJUR.asn1.DERUTF8String.superclass.constructor.call(this, a);
        this.hT = "0c";
      };
      extendClass(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERNumericString = function(a) {
        KJUR.asn1.DERNumericString.superclass.constructor.call(this, a);
        this.hT = "12";
      };
      extendClass(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERPrintableString = function(a) {
        KJUR.asn1.DERPrintableString.superclass.constructor.call(this, a);
        this.hT = "13";
      };
      extendClass(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERTeletexString = function(a) {
        KJUR.asn1.DERTeletexString.superclass.constructor.call(this, a);
        this.hT = "14";
      };
      extendClass(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERIA5String = function(a) {
        KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
        this.hT = "16";
      };
      extendClass(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERVisibleString = function(a) {
        KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
        this.hT = "1a";
      };
      extendClass(KJUR.asn1.DERVisibleString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERBMPString = function(a) {
        KJUR.asn1.DERBMPString.superclass.constructor.call(this, a);
        this.hT = "1e";
      };
      extendClass(KJUR.asn1.DERBMPString, KJUR.asn1.DERAbstractString);
      KJUR.asn1.DERUTCTime = function(a) {
        KJUR.asn1.DERUTCTime.superclass.constructor.call(this, a);
        this.hT = "17";
        this.params = void 0;
        this.getFreshValueHex = function() {
          var d = this.params;
          if (this.params == void 0) {
            d = { date: new Date() };
          }
          if (typeof d == "string") {
            if (d.match(/^[0-9]{12}Z$/) || d.match(/^[0-9]{12}\.[0-9]+Z$/)) {
              this.hV = stohex(d);
            } else {
              throw new Error("malformed string for UTCTime: " + d);
            }
          } else {
            if (d.str != void 0) {
              this.hV = stohex(d.str);
            } else {
              if (d.date == void 0 && d.millis == true) {
                var c = new Date();
                this.hV = stohex(this.formatDate(c, "utc", true));
              } else {
                if (d.date != void 0 && d.date instanceof Date) {
                  var b = d.millis === true;
                  this.hV = stohex(this.formatDate(d.date, "utc", b));
                } else {
                  if (d instanceof Date) {
                    this.hV = stohex(this.formatDate(d, "utc"));
                  }
                }
              }
            }
          }
          if (this.hV == void 0) {
            throw new Error("parameter not specified properly for UTCTime");
          }
          return this.hV;
        };
        if (a != void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
      KJUR.asn1.DERGeneralizedTime = function(a) {
        KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, a);
        this.hT = "18";
        this.params = a;
        this.getFreshValueHex = function() {
          var d = this.params;
          if (this.params == void 0) {
            d = { date: new Date() };
          }
          if (typeof d == "string") {
            if (d.match(/^[0-9]{14}Z$/) || d.match(/^[0-9]{14}\.[0-9]+Z$/)) {
              this.hV = stohex(d);
            } else {
              throw new Error("malformed string for GeneralizedTime: " + d);
            }
          } else {
            if (d.str != void 0) {
              this.hV = stohex(d.str);
            } else {
              if (d.date == void 0 && d.millis == true) {
                var c = new Date();
                this.hV = stohex(this.formatDate(c, "gen", true));
              } else {
                if (d.date != void 0 && d.date instanceof Date) {
                  var b = d.millis === true;
                  this.hV = stohex(this.formatDate(d.date, "gen", b));
                } else {
                  if (d instanceof Date) {
                    this.hV = stohex(this.formatDate(d, "gen"));
                  }
                }
              }
            }
          }
          if (this.hV == void 0) {
            throw new Error("parameter not specified properly for GeneralizedTime");
          }
          return this.hV;
        };
        if (a != void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
      KJUR.asn1.DERSequence = function(a) {
        KJUR.asn1.DERSequence.superclass.constructor.call(this, a);
        this.hT = "30";
        this.getFreshValueHex = function() {
          var c = "";
          for (var b = 0; b < this.asn1Array.length; b++) {
            var d = this.asn1Array[b];
            c += d.tohex();
          }
          this.hV = c;
          return this.hV;
        };
      };
      extendClass(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
      KJUR.asn1.DERSet = function(a) {
        KJUR.asn1.DERSet.superclass.constructor.call(this, a);
        this.hT = "31";
        this.sortFlag = true;
        this.getFreshValueHex = function() {
          var b = new Array();
          for (var c = 0; c < this.asn1Array.length; c++) {
            var d = this.asn1Array[c];
            b.push(d.tohex());
          }
          if (this.sortFlag == true) {
            b.sort();
          }
          this.hV = b.join("");
          return this.hV;
        };
        if (typeof a != "undefined") {
          if (typeof a.sortflag != "undefined" && a.sortflag == false) {
            this.sortFlag = false;
          }
        }
      };
      extendClass(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
      KJUR.asn1.DERTaggedObject = function(f) {
        KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
        var d = KJUR.asn1, e2 = ASN1HEX, a = e2.getV, c = e2.isASN1HEX, b = d.ASN1Util.newObject;
        this.hT = "a0";
        this.hV = "";
        this.isExplicit = true;
        this.asn1Object = null;
        this.params = { tag: "a0", explicit: true };
        this.setASN1Object = function(g, h, i) {
          this.params = { tag: h, explicit: g, obj: i };
        };
        this.getFreshValueHex = function() {
          var h = this.params;
          if (h.explicit == void 0) {
            h.explicit = true;
          }
          if (h.tage != void 0) {
            h.tag = h.tage;
            h.explicit = true;
          }
          if (h.tagi != void 0) {
            h.tag = h.tagi;
            h.explicit = false;
          }
          if (h.str != void 0) {
            this.hV = utf8tohex(h.str);
          } else {
            if (h.hex != void 0) {
              this.hV = h.hex;
            } else {
              if (h.obj != void 0) {
                var g;
                if (h.obj instanceof d.ASN1Object) {
                  g = h.obj.tohex();
                } else {
                  if (typeof h.obj == "object") {
                    g = b(h.obj).tohex();
                  }
                }
                if (h.explicit) {
                  this.hV = g;
                } else {
                  this.hV = a(g, 0);
                }
              } else {
                throw new Error("str, hex nor obj not specified");
              }
            }
          }
          if (h.tag == void 0) {
            h.tag = "a0";
          }
          this.hT = h.tag;
          this.hTLV = null;
          this.isModified = true;
          return this.hV;
        };
        this.setByParam = function(g) {
          this.params = g;
        };
        if (f !== void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
      var ASN1HEX = new function() {
      }();
      ASN1HEX.getLblen = function(c, a) {
        if (c.substr(a + 2, 1) != "8") {
          return 1;
        }
        var b = parseInt(c.substr(a + 3, 1));
        if (b == 0) {
          return -1;
        }
        if (0 < b && b < 10) {
          return b + 1;
        }
        return -2;
      };
      ASN1HEX.getL = function(c, b) {
        var a = ASN1HEX.getLblen(c, b);
        if (a < 1) {
          return "";
        }
        return c.substr(b + 2, a * 2);
      };
      ASN1HEX.getVblen = function(d, a) {
        var c, b;
        c = ASN1HEX.getL(d, a);
        if (c == "") {
          return -1;
        }
        if (c.substr(0, 1) === "8") {
          b = new BigInteger(c.substr(2), 16);
        } else {
          b = new BigInteger(c, 16);
        }
        return b.intValue();
      };
      ASN1HEX.getVidx = function(c, b) {
        var a = ASN1HEX.getLblen(c, b);
        if (a < 0) {
          return a;
        }
        return b + (a + 1) * 2;
      };
      ASN1HEX.getV = function(d, a) {
        var c = ASN1HEX.getVidx(d, a);
        var b = ASN1HEX.getVblen(d, a);
        return d.substr(c, b * 2);
      };
      ASN1HEX.getTLV = function(b, a) {
        return b.substr(a, 2) + ASN1HEX.getL(b, a) + ASN1HEX.getV(b, a);
      };
      ASN1HEX.getTLVblen = function(b, a) {
        return 2 + ASN1HEX.getLblen(b, a) * 2 + ASN1HEX.getVblen(b, a) * 2;
      };
      ASN1HEX.getNextSiblingIdx = function(d, a) {
        var c = ASN1HEX.getVidx(d, a);
        var b = ASN1HEX.getVblen(d, a);
        return c + b * 2;
      };
      ASN1HEX.getChildIdx = function(e2, k) {
        var l = ASN1HEX;
        var j = [];
        var c, f, g;
        c = l.getVidx(e2, k);
        f = l.getVblen(e2, k) * 2;
        if (e2.substr(k, 2) == "03") {
          c += 2;
          f -= 2;
        }
        g = 0;
        var d = c;
        while (g <= f) {
          var b = l.getTLVblen(e2, d);
          g += b;
          if (g <= f) {
            j.push(d);
          }
          d += b;
          if (g >= f) {
            break;
          }
        }
        return j;
      };
      ASN1HEX.getNthChildIdx = function(d, b, e2) {
        var c = ASN1HEX.getChildIdx(d, b);
        return c[e2];
      };
      ASN1HEX.getIdxbyList = function(e2, d, c, i) {
        var g = ASN1HEX;
        var f, b;
        if (c.length == 0) {
          if (i !== void 0) {
            if (e2.substr(d, 2) !== i) {
              return -1;
            }
          }
          return d;
        }
        f = c.shift();
        b = g.getChildIdx(e2, d);
        if (f >= b.length) {
          return -1;
        }
        return g.getIdxbyList(e2, b[f], c, i);
      };
      ASN1HEX.getIdxbyListEx = function(f, k, b, g) {
        var m = ASN1HEX;
        var d, l;
        if (b.length == 0) {
          if (g !== void 0) {
            if (f.substr(k, 2) !== g) {
              return -1;
            }
          }
          return k;
        }
        d = b.shift();
        l = m.getChildIdx(f, k);
        var j = 0;
        for (var e2 = 0; e2 < l.length; e2++) {
          var c = f.substr(l[e2], 2);
          if (typeof d == "number" && !m.isContextTag(c) && j == d || typeof d == "string" && m.isContextTag(c, d)) {
            return m.getIdxbyListEx(f, l[e2], b, g);
          }
          if (!m.isContextTag(c)) {
            j++;
          }
        }
        return -1;
      };
      ASN1HEX.getTLVbyList = function(d, c, b, f) {
        var e2 = ASN1HEX;
        var a = e2.getIdxbyList(d, c, b, f);
        if (a == -1) {
          return null;
        }
        if (a >= d.length) {
          return null;
        }
        return e2.getTLV(d, a);
      };
      ASN1HEX.getTLVbyListEx = function(d, c, b, f) {
        var e2 = ASN1HEX;
        var a = e2.getIdxbyListEx(d, c, b, f);
        if (a == -1) {
          return null;
        }
        return e2.getTLV(d, a);
      };
      ASN1HEX.getVbyList = function(e2, c, b, g, i) {
        var f = ASN1HEX;
        var a, d;
        a = f.getIdxbyList(e2, c, b, g);
        if (a == -1) {
          return null;
        }
        if (a >= e2.length) {
          return null;
        }
        d = f.getV(e2, a);
        if (i === true) {
          d = d.substr(2);
        }
        return d;
      };
      ASN1HEX.getVbyListEx = function(b, e2, a, d, f) {
        var j = ASN1HEX;
        var g, c, i;
        g = j.getIdxbyListEx(b, e2, a, d);
        if (g == -1) {
          return null;
        }
        i = j.getV(b, g);
        if (b.substr(g, 2) == "03" && f !== false) {
          i = i.substr(2);
        }
        return i;
      };
      ASN1HEX.getInt = function(e2, b, f) {
        if (f == void 0) {
          f = -1;
        }
        try {
          var c = e2.substr(b, 2);
          if (c != "02" && c != "03") {
            return f;
          }
          var a = ASN1HEX.getV(e2, b);
          if (c == "02") {
            return parseInt(a, 16);
          } else {
            return bitstrtoint(a);
          }
        } catch (d) {
          return f;
        }
      };
      ASN1HEX.getOID = function(c, a, d) {
        if (d == void 0) {
          d = null;
        }
        try {
          if (c.substr(a, 2) != "06") {
            return d;
          }
          var e2 = ASN1HEX.getV(c, a);
          return hextooid(e2);
        } catch (b) {
          return d;
        }
      };
      ASN1HEX.getOIDName = function(d, a, f) {
        if (f == void 0) {
          f = null;
        }
        try {
          var e2 = ASN1HEX.getOID(d, a, f);
          if (e2 == f) {
            return f;
          }
          var b = KJUR.asn1.x509.OID.oid2name(e2);
          if (b == "") {
            return e2;
          }
          return b;
        } catch (c) {
          return f;
        }
      };
      ASN1HEX.getString = function(d, b, e2) {
        if (e2 == void 0) {
          e2 = null;
        }
        try {
          var a = ASN1HEX.getV(d, b);
          return hextorstr(a);
        } catch (c) {
          return e2;
        }
      };
      ASN1HEX.hextooidstr = function(e2) {
        var h = function(b, a) {
          if (b.length >= a) {
            return b;
          }
          return new Array(a - b.length + 1).join("0") + b;
        };
        var l = [];
        var o2 = e2.substr(0, 2);
        var f = parseInt(o2, 16);
        l[0] = new String(Math.floor(f / 40));
        l[1] = new String(f % 40);
        var m = e2.substr(2);
        var k = [];
        for (var g = 0; g < m.length / 2; g++) {
          k.push(parseInt(m.substr(g * 2, 2), 16));
        }
        var j = [];
        var d = "";
        for (var g = 0; g < k.length; g++) {
          if (k[g] & 128) {
            d = d + h((k[g] & 127).toString(2), 7);
          } else {
            d = d + h((k[g] & 127).toString(2), 7);
            j.push(new String(parseInt(d, 2)));
            d = "";
          }
        }
        var n2 = l.join(".");
        if (j.length > 0) {
          n2 = n2 + "." + j.join(".");
        }
        return n2;
      };
      ASN1HEX.dump = function(t3, c, l, g) {
        var p = ASN1HEX;
        var j = p.getV;
        var y = p.dump;
        var w = p.getChildIdx;
        var e2 = t3;
        if (t3 instanceof KJUR.asn1.ASN1Object) {
          e2 = t3.tohex();
        }
        var q = function(A, i) {
          if (A.length <= i * 2) {
            return A;
          } else {
            var v = A.substr(0, i) + "..(total " + A.length / 2 + "bytes).." + A.substr(A.length - i, i);
            return v;
          }
        };
        if (c === void 0) {
          c = { ommit_long_octet: 32 };
        }
        if (l === void 0) {
          l = 0;
        }
        if (g === void 0) {
          g = "";
        }
        var x = c.ommit_long_octet;
        var z2 = e2.substr(l, 2);
        if (z2 == "01") {
          var h = j(e2, l);
          if (h == "00") {
            return g + "BOOLEAN FALSE\n";
          } else {
            return g + "BOOLEAN TRUE\n";
          }
        }
        if (z2 == "02") {
          var h = j(e2, l);
          return g + "INTEGER " + q(h, x) + "\n";
        }
        if (z2 == "03") {
          var h = j(e2, l);
          if (p.isASN1HEX(h.substr(2))) {
            var k = g + "BITSTRING, encapsulates\n";
            k = k + y(h.substr(2), c, 0, g + "  ");
            return k;
          } else {
            return g + "BITSTRING " + q(h, x) + "\n";
          }
        }
        if (z2 == "04") {
          var h = j(e2, l);
          if (p.isASN1HEX(h)) {
            var k = g + "OCTETSTRING, encapsulates\n";
            k = k + y(h, c, 0, g + "  ");
            return k;
          } else {
            return g + "OCTETSTRING " + q(h, x) + "\n";
          }
        }
        if (z2 == "05") {
          return g + "NULL\n";
        }
        if (z2 == "06") {
          var m = j(e2, l);
          var b = KJUR.asn1.ASN1Util.oidHexToInt(m);
          var o2 = KJUR.asn1.x509.OID.oid2name(b);
          var a = b.replace(/\./g, " ");
          if (o2 != "") {
            return g + "ObjectIdentifier " + o2 + " (" + a + ")\n";
          } else {
            return g + "ObjectIdentifier (" + a + ")\n";
          }
        }
        if (z2 == "0a") {
          return g + "ENUMERATED " + parseInt(j(e2, l)) + "\n";
        }
        if (z2 == "0c") {
          return g + "UTF8String '" + hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "13") {
          return g + "PrintableString '" + hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "14") {
          return g + "TeletexString '" + hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "16") {
          return g + "IA5String '" + hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "17") {
          return g + "UTCTime " + hextoutf8(j(e2, l)) + "\n";
        }
        if (z2 == "18") {
          return g + "GeneralizedTime " + hextoutf8(j(e2, l)) + "\n";
        }
        if (z2 == "1a") {
          return g + "VisualString '" + hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "1e") {
          return g + "BMPString '" + ucs2hextoutf8(j(e2, l)) + "'\n";
        }
        if (z2 == "30") {
          if (e2.substr(l, 4) == "3000") {
            return g + "SEQUENCE {}\n";
          }
          var k = g + "SEQUENCE\n";
          var d = w(e2, l);
          var f = c;
          if ((d.length == 2 || d.length == 3) && e2.substr(d[0], 2) == "06" && e2.substr(d[d.length - 1], 2) == "04") {
            var o2 = p.oidname(j(e2, d[0]));
            var r2 = JSON.parse(JSON.stringify(c));
            r2.x509ExtName = o2;
            f = r2;
          }
          for (var u = 0; u < d.length; u++) {
            k = k + y(e2, f, d[u], g + "  ");
          }
          return k;
        }
        if (z2 == "31") {
          var k = g + "SET\n";
          var d = w(e2, l);
          for (var u = 0; u < d.length; u++) {
            k = k + y(e2, c, d[u], g + "  ");
          }
          return k;
        }
        var z2 = parseInt(z2, 16);
        if ((z2 & 128) != 0) {
          var n2 = z2 & 31;
          if ((z2 & 32) != 0) {
            var k = g + "[" + n2 + "]\n";
            var d = w(e2, l);
            for (var u = 0; u < d.length; u++) {
              k = k + y(e2, c, d[u], g + "  ");
            }
            return k;
          } else {
            var h = j(e2, l);
            if (ASN1HEX.isASN1HEX(h)) {
              var k = g + "[" + n2 + "]\n";
              k = k + y(h, c, 0, g + "  ");
              return k;
            } else {
              if (h.substr(0, 8) == "68747470") {
                h = hextoutf8(h);
              } else {
                if (c.x509ExtName === "subjectAltName" && n2 == 2) {
                  h = hextoutf8(h);
                }
              }
            }
            var k = g + "[" + n2 + "] " + h + "\n";
            return k;
          }
        }
        return g + "UNKNOWN(" + z2 + ") " + j(e2, l) + "\n";
      };
      ASN1HEX.parse = function(x) {
        var t3 = ASN1HEX, f = t3.parse, a = t3.isASN1HEX, l = t3.getV, b = t3.getTLV, y = t3.getChildIdx, i = KJUR.asn1, e2 = i.ASN1Util.oidHexToInt, B = i.x509.OID.oid2name, k = hextoutf8, n2 = ucs2hextoutf8, q = iso88591hextoutf8;
        var c = { "0c": "utf8str", "12": "numstr", "13": "prnstr", "14": "telstr", "16": "ia5str", "17": "utctime", "18": "gentime", "1a": "visstr", "1e": "bmpstr", "30": "seq", "31": "set" };
        var u = function(H) {
          var D = [];
          var E = y(H, 0);
          for (var G = 0; G < E.length; G++) {
            var s = E[G];
            var d = b(H, s);
            var F = f(d);
            D.push(F);
          }
          return D;
        };
        var C = x.substr(0, 2);
        var j = {};
        var p = l(x, 0);
        if (C == "01") {
          if (x == "0101ff") {
            return { bool: true };
          }
          return { bool: false };
        } else {
          if (C == "02") {
            return { "int": { hex: p } };
          } else {
            if (C == "03") {
              try {
                if (p.substr(0, 2) != "00") {
                  throw "not encap";
                }
                var v = p.substr(2);
                if (!a(v)) {
                  throw "not encap";
                }
                return { bitstr: { obj: f(v) } };
              } catch (z2) {
                var m = null;
                if (p.length <= 10) {
                  m = bitstrtobinstr(p);
                }
                if (m == null) {
                  return { bitstr: { hex: p } };
                } else {
                  return { bitstr: { bin: m } };
                }
              }
            } else {
              if (C == "04") {
                try {
                  if (!a(p)) {
                    throw "not encap";
                  }
                  return { octstr: { obj: f(p) } };
                } catch (z2) {
                  return { octstr: { hex: p } };
                }
              } else {
                if (C == "05") {
                  return { "null": "" };
                } else {
                  if (C == "06") {
                    var g = e2(p);
                    var r2 = B(g);
                    if (r2 == "") {
                      return { oid: g };
                    } else {
                      return { oid: r2 };
                    }
                  } else {
                    if (C == "0a") {
                      if (p.length > 4) {
                        return { "enum": { hex: p } };
                      } else {
                        return { "enum": parseInt(p, 16) };
                      }
                    } else {
                      if (C == "30" || C == "31") {
                        j[c[C]] = u(x);
                        return j;
                      } else {
                        if (C == "14") {
                          var o2 = q(p);
                          j[c[C]] = { str: o2 };
                          return j;
                        } else {
                          if (C == "1e") {
                            var o2 = n2(p);
                            j[c[C]] = { str: o2 };
                            return j;
                          } else {
                            if (":0c:12:13:16:17:18:1a:".indexOf(C) != -1) {
                              var o2 = k(p);
                              j[c[C]] = { str: o2 };
                              return j;
                            } else {
                              if (C.match(/^8[0-9]$/)) {
                                var o2 = k(p);
                                if (o2 == null | o2 == "") {
                                  return { tag: { tag: C, explicit: false, hex: p } };
                                } else {
                                  if (o2.match(/[\x00-\x1F\x7F-\x9F]/) != null || o2.match(/[\u0000-\u001F\u0080–\u009F]/) != null) {
                                    return { tag: { tag: C, explicit: false, hex: p } };
                                  } else {
                                    return { tag: { tag: C, explicit: false, str: o2 } };
                                  }
                                }
                              } else {
                                if (C.match(/^a[0-9]$/)) {
                                  try {
                                    if (!a(p)) {
                                      throw new Error("not encap");
                                    }
                                    return { tag: { tag: C, explicit: true, obj: f(p) } };
                                  } catch (z2) {
                                    return { tag: { tag: C, explicit: true, hex: p } };
                                  }
                                } else {
                                  var A = new KJUR.asn1.ASN1Object();
                                  A.hV = p;
                                  var w = A.getLengthHexFromValue();
                                  return { asn1: { tlv: C + w + p } };
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      ASN1HEX.isContextTag = function(c, b) {
        c = c.toLowerCase();
        var f, e2;
        try {
          f = parseInt(c, 16);
        } catch (d) {
          return -1;
        }
        if (b === void 0) {
          if ((f & 192) == 128) {
            return true;
          } else {
            return false;
          }
        }
        try {
          var a = b.match(/^\[[0-9]+\]$/);
          if (a == null) {
            return false;
          }
          e2 = parseInt(b.substr(1, b.length - 1), 10);
          if (e2 > 31) {
            return false;
          }
          if ((f & 192) == 128 && (f & 31) == e2) {
            return true;
          }
          return false;
        } catch (d) {
          return false;
        }
      };
      ASN1HEX.isASN1HEX = function(e2) {
        var d = ASN1HEX;
        if (e2.length % 2 == 1) {
          return false;
        }
        var c = d.getVblen(e2, 0);
        var b = e2.substr(0, 2);
        var f = d.getL(e2, 0);
        var a = e2.length - b.length - f.length;
        if (a == c * 2) {
          return true;
        }
        return false;
      };
      ASN1HEX.checkStrictDER = function(g, o2, d, c, r2) {
        var s = ASN1HEX;
        if (d === void 0) {
          if (typeof g != "string") {
            throw new Error("not hex string");
          }
          g = g.toLowerCase();
          if (!KJUR.lang.String.isHex(g)) {
            throw new Error("not hex string");
          }
          d = g.length;
          c = g.length / 2;
          if (c < 128) {
            r2 = 1;
          } else {
            r2 = Math.ceil(c.toString(16)) + 1;
          }
        }
        var k = s.getL(g, o2);
        if (k.length > r2 * 2) {
          throw new Error("L of TLV too long: idx=" + o2);
        }
        var n2 = s.getVblen(g, o2);
        if (n2 > c) {
          throw new Error("value of L too long than hex: idx=" + o2);
        }
        var q = s.getTLV(g, o2);
        var f = q.length - 2 - s.getL(g, o2).length;
        if (f !== n2 * 2) {
          throw new Error("V string length and L's value not the same:" + f + "/" + n2 * 2);
        }
        if (o2 === 0) {
          if (g.length != q.length) {
            throw new Error("total length and TLV length unmatch:" + g.length + "!=" + q.length);
          }
        }
        var b = g.substr(o2, 2);
        if (b === "02") {
          var a = s.getVidx(g, o2);
          if (g.substr(a, 2) == "00" && g.charCodeAt(a + 2) < 56) {
            throw new Error("not least zeros for DER INTEGER");
          }
        }
        if (parseInt(b, 16) & 32) {
          var p = s.getVblen(g, o2);
          var m = 0;
          var l = s.getChildIdx(g, o2);
          for (var e2 = 0; e2 < l.length; e2++) {
            var j = s.getTLV(g, l[e2]);
            m += j.length;
            s.checkStrictDER(g, l[e2], d, c, r2);
          }
          if (p * 2 != m) {
            throw new Error("sum of children's TLV length and L unmatch: " + p * 2 + "!=" + m);
          }
        }
      };
      ASN1HEX.oidname = function(a) {
        var c = KJUR.asn1;
        if (KJUR.lang.String.isHex(a)) {
          a = c.ASN1Util.oidHexToInt(a);
        }
        var b = c.x509.OID.oid2name(a);
        if (b === "") {
          b = a;
        }
        return b;
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      if (typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) {
        KJUR.asn1.x509 = {};
      }
      KJUR.asn1.x509.Certificate = function(h) {
        KJUR.asn1.x509.Certificate.superclass.constructor.call(this);
        var d = KJUR, c = d.asn1, f = c.DERBitString, b = c.DERSequence, g = c.x509, a = g.TBSCertificate, e2 = g.AlgorithmIdentifier;
        this.params = void 0;
        this.setByParam = function(i) {
          this.params = i;
        };
        this.sign = function() {
          var l = this.params;
          var k = l.sigalg;
          if (l.sigalg.name != void 0) {
            k = l.sigalg.name;
          }
          var i = l.tbsobj.tohex();
          var j = new KJUR.crypto.Signature({ alg: k });
          j.init(l.cakey);
          j.updateHex(i);
          l.sighex = j.sign();
        };
        this.getPEM = function() {
          return hextopem(this.tohex(), "CERTIFICATE");
        };
        this.tohex = function() {
          var k = this.params;
          if (k.tbsobj == void 0 || k.tbsobj == null) {
            k.tbsobj = new a(k);
          }
          if (k.sighex == void 0 && k.cakey != void 0) {
            this.sign();
          }
          if (k.sighex == void 0) {
            throw new Error("sighex or cakey parameter not defined");
          }
          var i = [];
          i.push(k.tbsobj);
          i.push(new e2({ name: k.sigalg }));
          i.push(new f({ hex: "00" + k.sighex }));
          var j = new b({ array: i });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (h != void 0) {
          this.params = h;
        }
      };
      extendClass(KJUR.asn1.x509.Certificate, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.TBSCertificate = function(f) {
        KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);
        var b = KJUR, i = b.asn1, d = i.x509, c = i.DERTaggedObject, h = i.DERInteger, g = i.DERSequence, l = d.AlgorithmIdentifier, e2 = d.Time, a = d.X500Name, j = d.Extensions, k = d.SubjectPublicKeyInfo;
        this.params = null;
        this.setByParam = function(m) {
          this.params = m;
        };
        this.tohex = function() {
          var n2 = [];
          var q = this.params;
          if (q.version != void 0 || q.version != 1) {
            var m = 2;
            if (q.version != void 0) {
              m = q.version - 1;
            }
            var p = new c({ obj: new h({ "int": m }) });
            n2.push(p);
          }
          n2.push(new h(q.serial));
          n2.push(new l({ name: q.sigalg }));
          n2.push(new a(q.issuer));
          n2.push(new g({ array: [new e2(q.notbefore), new e2(q.notafter)] }));
          n2.push(new a(q.subject));
          n2.push(new k(KEYUTIL.getKey(q.sbjpubkey)));
          if (q.ext !== void 0 && q.ext.length > 0) {
            n2.push(new c({ tag: "a3", obj: new j(q.ext) }));
          }
          var o2 = new KJUR.asn1.DERSequence({ array: n2 });
          return o2.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.x509.TBSCertificate, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.Extensions = function(d) {
        KJUR.asn1.x509.Extensions.superclass.constructor.call(this);
        var c = KJUR, b = c.asn1, a = b.DERSequence, e2 = b.x509;
        this.aParam = [];
        this.setByParam = function(f) {
          this.aParam = f;
        };
        this.tohex = function() {
          var f = [];
          for (var h = 0; h < this.aParam.length; h++) {
            var l = this.aParam[h];
            var k = l.extname;
            var j = null;
            if (l.extn != void 0) {
              j = new e2.PrivateExtension(l);
            } else {
              if (k == "subjectKeyIdentifier") {
                j = new e2.SubjectKeyIdentifier(l);
              } else {
                if (k == "keyUsage") {
                  j = new e2.KeyUsage(l);
                } else {
                  if (k == "subjectAltName") {
                    j = new e2.SubjectAltName(l);
                  } else {
                    if (k == "issuerAltName") {
                      j = new e2.IssuerAltName(l);
                    } else {
                      if (k == "basicConstraints") {
                        j = new e2.BasicConstraints(l);
                      } else {
                        if (k == "nameConstraints") {
                          j = new e2.NameConstraints(l);
                        } else {
                          if (k == "cRLDistributionPoints") {
                            j = new e2.CRLDistributionPoints(l);
                          } else {
                            if (k == "certificatePolicies") {
                              j = new e2.CertificatePolicies(l);
                            } else {
                              if (k == "policyMappings") {
                                j = new e2.PolicyMappings(l);
                              } else {
                                if (k == "policyConstraints") {
                                  j = new e2.PolicyConstraints(l);
                                } else {
                                  if (k == "inhibitAnyPolicy") {
                                    j = new e2.InhibitAnyPolicy(l);
                                  } else {
                                    if (k == "authorityKeyIdentifier") {
                                      j = new e2.AuthorityKeyIdentifier(l);
                                    } else {
                                      if (k == "extKeyUsage") {
                                        j = new e2.ExtKeyUsage(l);
                                      } else {
                                        if (k == "authorityInfoAccess") {
                                          j = new e2.AuthorityInfoAccess(l);
                                        } else {
                                          if (k == "cRLNumber") {
                                            j = new e2.CRLNumber(l);
                                          } else {
                                            if (k == "cRLReason") {
                                              j = new e2.CRLReason(l);
                                            } else {
                                              if (k == "ocspNonce") {
                                                j = new e2.OCSPNonce(l);
                                              } else {
                                                if (k == "ocspNoCheck") {
                                                  j = new e2.OCSPNoCheck(l);
                                                } else {
                                                  if (k == "adobeTimeStamp") {
                                                    j = new e2.AdobeTimeStamp(l);
                                                  } else {
                                                    if (k == "subjectDirectoryAttributes") {
                                                      j = new e2.SubjectDirectoryAttributes(l);
                                                    } else {
                                                      throw new Error("extension not supported:" + JSON.stringify(l));
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (j != null) {
              f.push(j);
            }
          }
          var g = new a({ array: f });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d != void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.x509.Extensions, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.Extension = function(d) {
        KJUR.asn1.x509.Extension.superclass.constructor.call(this);
        var f = null, a = KJUR, e2 = a.asn1, h = e2.DERObjectIdentifier, i = e2.DEROctetString, b = e2.DERBitString, g = e2.DERBoolean, c = e2.DERSequence;
        this.tohex = function() {
          var m = new h({ oid: this.oid });
          var l = new i({ hex: this.getExtnValueHex() });
          var k = new Array();
          k.push(m);
          if (this.critical) {
            k.push(new g());
          }
          k.push(l);
          var j = new c({ array: k });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.critical = false;
        if (d !== void 0) {
          if (d.critical !== void 0) {
            this.critical = d.critical;
          }
        }
      };
      extendClass(KJUR.asn1.x509.Extension, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.KeyUsage = function(c) {
        KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this, c);
        var b = Error;
        var a = { digitalSignature: 0, nonRepudiation: 1, keyEncipherment: 2, dataEncipherment: 3, keyAgreement: 4, keyCertSign: 5, cRLSign: 6, encipherOnly: 7, decipherOnly: 8 };
        this.getExtnValueHex = function() {
          var d = this.getBinValue();
          this.asn1ExtnValue = new KJUR.asn1.DERBitString({ bin: d });
          return this.asn1ExtnValue.tohex();
        };
        this.getBinValue = function() {
          var d = this.params;
          if (typeof d != "object" || typeof d.names != "object" && typeof d.bin != "string") {
            throw new b("parameter not yet set");
          }
          if (d.names != void 0) {
            return namearraytobinstr(d.names, a);
          } else {
            if (d.bin != void 0) {
              return d.bin;
            } else {
              throw new b("parameter not set properly");
            }
          }
        };
        this.oid = "2.5.29.15";
        if (c !== void 0) {
          this.params = c;
        }
      };
      extendClass(KJUR.asn1.x509.KeyUsage, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.BasicConstraints = function(g) {
        KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this, g);
        var c = KJUR.asn1, e2 = c.DERBoolean, f = c.DERInteger, b = c.DERSequence;
        var a = false;
        var d = -1;
        this.getExtnValueHex = function() {
          var i = new Array();
          if (this.cA) {
            i.push(new e2());
          }
          if (this.pathLen > -1) {
            i.push(new f({ "int": this.pathLen }));
          }
          var h = new b({ array: i });
          this.asn1ExtnValue = h;
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.19";
        this.cA = false;
        this.pathLen = -1;
        if (g !== void 0) {
          if (g.cA !== void 0) {
            this.cA = g.cA;
          }
          if (g.pathLen !== void 0) {
            this.pathLen = g.pathLen;
          }
        }
      };
      extendClass(KJUR.asn1.x509.BasicConstraints, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.CRLDistributionPoints = function(d) {
        KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, d);
        var b = KJUR, a = b.asn1, c = a.x509;
        this.getExtnValueHex = function() {
          return this.asn1ExtnValue.tohex();
        };
        this.setByDPArray = function(e2) {
          var f = [];
          for (var g = 0; g < e2.length; g++) {
            if (e2[g] instanceof KJUR.asn1.ASN1Object) {
              f.push(e2[g]);
            } else {
              var h = new c.DistributionPoint(e2[g]);
              f.push(h);
            }
          }
          this.asn1ExtnValue = new a.DERSequence({ array: f });
        };
        this.setByOneURI = function(f) {
          var e2 = new c.DistributionPoint({ fulluri: f });
          this.setByDPArray([e2]);
        };
        this.oid = "2.5.29.31";
        if (d !== void 0) {
          if (d.array !== void 0) {
            this.setByDPArray(d.array);
          } else {
            if (d.uri !== void 0) {
              this.setByOneURI(d.uri);
            }
          }
        }
      };
      extendClass(KJUR.asn1.x509.CRLDistributionPoints, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.DistributionPoint = function(e2) {
        KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);
        var a = null, c = KJUR, b = c.asn1, d = b.x509.DistributionPointName;
        this.tohex = function() {
          var f = new b.DERSequence();
          if (this.asn1DP != null) {
            var g = new b.DERTaggedObject({ explicit: true, tag: "a0", obj: this.asn1DP });
            f.appendASN1Object(g);
          }
          this.hTLV = f.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          if (e2.dpobj !== void 0) {
            this.asn1DP = e2.dpobj;
          } else {
            if (e2.dpname !== void 0) {
              this.asn1DP = new d(e2.dpname);
            } else {
              if (e2.fulluri !== void 0) {
                this.asn1DP = new d({ full: [{ uri: e2.fulluri }] });
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.x509.DistributionPoint, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.DistributionPointName = function(h) {
        KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);
        var g = null, d = null, a = null, f = null, c = KJUR, b = c.asn1, e2 = b.DERTaggedObject;
        this.tohex = function() {
          if (this.type != "full") {
            throw new Error("currently type shall be 'full': " + this.type);
          }
          this.asn1Obj = new e2({ explicit: false, tag: this.tag, obj: this.asn1V });
          this.hTLV = this.asn1Obj.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (h !== void 0) {
          if (b.x509.GeneralNames.prototype.isPrototypeOf(h)) {
            this.type = "full";
            this.tag = "a0";
            this.asn1V = h;
          } else {
            if (h.full !== void 0) {
              this.type = "full";
              this.tag = "a0";
              this.asn1V = new b.x509.GeneralNames(h.full);
            } else {
              throw new Error("This class supports GeneralNames only as argument");
            }
          }
        }
      };
      extendClass(KJUR.asn1.x509.DistributionPointName, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.CertificatePolicies = function(f) {
        KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this, f);
        var c = KJUR, b = c.asn1, e2 = b.x509, a = b.DERSequence, d = e2.PolicyInformation;
        this.params = null;
        this.getExtnValueHex = function() {
          var j = [];
          for (var h = 0; h < this.params.array.length; h++) {
            j.push(new d(this.params.array[h]));
          }
          var g = new a({ array: j });
          this.asn1ExtnValue = g;
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.32";
        if (f !== void 0) {
          this.params = f;
        }
      };
      extendClass(KJUR.asn1.x509.CertificatePolicies, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.PolicyInformation = function(d) {
        KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this, d);
        var c = KJUR.asn1, b = c.DERSequence, e2 = c.DERObjectIdentifier, a = c.x509.PolicyQualifierInfo;
        this.params = null;
        this.tohex = function() {
          if (this.params.policyoid === void 0 && this.params.array === void 0) {
            throw new Error("parameter oid and array missing");
          }
          var f = [new e2(this.params.policyoid)];
          if (this.params.array !== void 0) {
            var j = [];
            for (var h = 0; h < this.params.array.length; h++) {
              j.push(new a(this.params.array[h]));
            }
            if (j.length > 0) {
              f.push(new b({ array: j }));
            }
          }
          var g = new b({ array: f });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d !== void 0) {
          this.params = d;
        }
      };
      extendClass(KJUR.asn1.x509.PolicyInformation, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.PolicyQualifierInfo = function(e2) {
        KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this, e2);
        var c = KJUR.asn1, b = c.DERSequence, d = c.DERIA5String, f = c.DERObjectIdentifier, a = c.x509.UserNotice;
        this.params = null;
        this.tohex = function() {
          if (this.params.cps !== void 0) {
            var g = new b({ array: [new f({ oid: "1.3.6.1.5.5.7.2.1" }), new d({ str: this.params.cps })] });
            return g.tohex();
          }
          if (this.params.unotice != void 0) {
            var g = new b({ array: [new f({ oid: "1.3.6.1.5.5.7.2.2" }), new a(this.params.unotice)] });
            return g.tohex();
          }
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.PolicyQualifierInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.UserNotice = function(e2) {
        KJUR.asn1.x509.UserNotice.superclass.constructor.call(this, e2);
        var a = KJUR.asn1.DERSequence, d = KJUR.asn1.DERInteger, c = KJUR.asn1.x509.DisplayText, b = KJUR.asn1.x509.NoticeReference;
        this.params = null;
        this.tohex = function() {
          var f = [];
          if (this.params.noticeref !== void 0) {
            f.push(new b(this.params.noticeref));
          }
          if (this.params.exptext !== void 0) {
            f.push(new c(this.params.exptext));
          }
          var g = new a({ array: f });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.UserNotice, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.NoticeReference = function(d) {
        KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this, d);
        var a = KJUR.asn1.DERSequence, c = KJUR.asn1.DERInteger, b = KJUR.asn1.x509.DisplayText;
        this.params = null;
        this.tohex = function() {
          var f = [];
          if (this.params.org !== void 0) {
            f.push(new b(this.params.org));
          }
          if (this.params.noticenum !== void 0) {
            var h = [];
            var e2 = this.params.noticenum;
            for (var j = 0; j < e2.length; j++) {
              h.push(new c(e2[j]));
            }
            f.push(new a({ array: h }));
          }
          if (f.length == 0) {
            throw new Error("parameter is empty");
          }
          var g = new a({ array: f });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d !== void 0) {
          this.params = d;
        }
      };
      extendClass(KJUR.asn1.x509.NoticeReference, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.DisplayText = function(a) {
        KJUR.asn1.x509.DisplayText.superclass.constructor.call(this, a);
        this.hT = "0c";
        if (a !== void 0) {
          if (a.type === "ia5") {
            this.hT = "16";
          } else {
            if (a.type === "vis") {
              this.hT = "1a";
            } else {
              if (a.type === "bmp") {
                this.hT = "1e";
              }
            }
          }
        }
      };
      extendClass(KJUR.asn1.x509.DisplayText, KJUR.asn1.DERAbstractString);
      KJUR.asn1.x509.PolicyMappings = function(e2) {
        KJUR.asn1.x509.PolicyMappings.superclass.constructor.call(this, e2);
        var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
        this.params = null;
        this.getExtnValueHex = function() {
          var j = this.params;
          var f = [];
          for (var g = 0; g < j.array.length; g++) {
            var h = j.array[g];
            f.push({ seq: [{ oid: h[0] }, { oid: h[1] }] });
          }
          this.asn1ExtnValue = a({ seq: f });
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.33";
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.PolicyMappings, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.PolicyConstraints = function(e2) {
        KJUR.asn1.x509.PolicyConstraints.superclass.constructor.call(this, e2);
        var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
        this.params = null;
        this.getExtnValueHex = function() {
          var g = this.params;
          var f = [];
          if (g.reqexp != void 0) {
            f.push({ tag: { tagi: "80", obj: { "int": g.reqexp } } });
          }
          if (g.inhibit != void 0) {
            f.push({ tag: { tagi: "81", obj: { "int": g.inhibit } } });
          }
          this.asn1ExtnValue = a({ seq: f });
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.36";
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.PolicyConstraints, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.InhibitAnyPolicy = function(e2) {
        KJUR.asn1.x509.InhibitAnyPolicy.superclass.constructor.call(this, e2);
        var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
        this.params = null;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = a({ "int": this.params.skip });
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.54";
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.InhibitAnyPolicy, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.NameConstraints = function(f) {
        KJUR.asn1.x509.NameConstraints.superclass.constructor.call(this, f);
        var c = KJUR, b = c.asn1, e2 = b.x509, a = b.ASN1Util.newObject, d = e2.GeneralSubtree;
        this.params = null;
        this.getExtnValueHex = function() {
          var l = this.params;
          var g = [];
          if (l.permit != void 0 && l.permit.length != void 0) {
            var k = [];
            for (var h = 0; h < l.permit.length; h++) {
              k.push(new d(l.permit[h]));
            }
            g.push({ tag: { tagi: "a0", obj: { seq: k } } });
          }
          if (l.exclude != void 0 && l.exclude.length != void 0) {
            var j = [];
            for (var h = 0; h < l.exclude.length; h++) {
              j.push(new d(l.exclude[h]));
            }
            g.push({ tag: { tagi: "a1", obj: { seq: j } } });
          }
          this.asn1ExtnValue = a({ seq: g });
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.30";
        if (f !== void 0) {
          this.params = f;
        }
      };
      extendClass(KJUR.asn1.x509.NameConstraints, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.GeneralSubtree = function(e2) {
        KJUR.asn1.x509.GeneralSubtree.superclass.constructor.call(this);
        var b = KJUR.asn1, d = b.x509, c = d.GeneralName, a = b.ASN1Util.newObject;
        this.params = null;
        this.setByParam = function(f) {
          this.params = f;
        };
        this.tohex = function() {
          var h = this.params;
          var f = [new c(h)];
          if (h.min != void 0) {
            f.push({ tag: { tagi: "80", obj: { "int": h.min } } });
          }
          if (h.max != void 0) {
            f.push({ tag: { tagi: "81", obj: { "int": h.max } } });
          }
          var g = a({ seq: f });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.x509.GeneralSubtree, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.ExtKeyUsage = function(c) {
        KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, c);
        var b = KJUR, a = b.asn1;
        this.setPurposeArray = function(d) {
          this.asn1ExtnValue = new a.DERSequence();
          for (var e2 = 0; e2 < d.length; e2++) {
            var f = new a.DERObjectIdentifier(d[e2]);
            this.asn1ExtnValue.appendASN1Object(f);
          }
        };
        this.getExtnValueHex = function() {
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.37";
        if (c !== void 0) {
          if (c.array !== void 0) {
            this.setPurposeArray(c.array);
          }
        }
      };
      extendClass(KJUR.asn1.x509.ExtKeyUsage, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.AuthorityKeyIdentifier = function(f) {
        KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, f);
        var b = KJUR, a = b.asn1, d = a.DERTaggedObject, e2 = a.x509.GeneralNames, c = b.crypto.Util.isKey;
        this.asn1KID = null;
        this.asn1CertIssuer = null;
        this.asn1CertSN = null;
        this.getExtnValueHex = function() {
          var h = new Array();
          if (this.asn1KID) {
            h.push(new d({ explicit: false, tag: "80", obj: this.asn1KID }));
          }
          if (this.asn1CertIssuer) {
            h.push(new d({ explicit: false, tag: "a1", obj: new e2([{ dn: this.asn1CertIssuer }]) }));
          }
          if (this.asn1CertSN) {
            h.push(new d({ explicit: false, tag: "82", obj: this.asn1CertSN }));
          }
          var g = new a.DERSequence({ array: h });
          this.asn1ExtnValue = g;
          return this.asn1ExtnValue.tohex();
        };
        this.setKIDByParam = function(i) {
          if (i.str !== void 0 || i.hex !== void 0) {
            this.asn1KID = new KJUR.asn1.DEROctetString(i);
          } else {
            if (typeof i === "object" && KJUR.crypto.Util.isKey(i) || typeof i === "string" && i.indexOf("BEGIN ") != -1) {
              var h = i;
              if (typeof i === "string") {
                h = KEYUTIL.getKey(i);
              }
              var g = KEYUTIL.getKeyID(h);
              this.asn1KID = new KJUR.asn1.DEROctetString({ hex: g });
            }
          }
        };
        this.setCertIssuerByParam = function(g) {
          if (g.str !== void 0 || g.ldapstr !== void 0 || g.hex !== void 0 || g.certsubject !== void 0 || g.certissuer !== void 0) {
            this.asn1CertIssuer = new KJUR.asn1.x509.X500Name(g);
          } else {
            if (typeof g === "string" && g.indexOf("BEGIN ") != -1 && g.indexOf("CERTIFICATE") != -1) {
              this.asn1CertIssuer = new KJUR.asn1.x509.X500Name({ certissuer: g });
            }
          }
        };
        this.setCertSNByParam = function(i) {
          if (i.str !== void 0 || i.bigint !== void 0 || i.hex !== void 0) {
            this.asn1CertSN = new KJUR.asn1.DERInteger(i);
          } else {
            if (typeof i === "string" && i.indexOf("BEGIN ") != -1 && i.indexOf("CERTIFICATE")) {
              var g = new X509();
              g.readCertPEM(i);
              var h = g.getSerialNumberHex();
              this.asn1CertSN = new KJUR.asn1.DERInteger({ hex: h });
            }
          }
        };
        this.oid = "2.5.29.35";
        if (f !== void 0) {
          if (f.kid !== void 0) {
            this.setKIDByParam(f.kid);
          }
          if (f.issuer !== void 0) {
            this.setCertIssuerByParam(f.issuer);
          }
          if (f.sn !== void 0) {
            this.setCertSNByParam(f.sn);
          }
          if (f.issuersn !== void 0 && typeof f.issuersn === "string" && f.issuersn.indexOf("BEGIN ") != -1 && f.issuersn.indexOf("CERTIFICATE")) {
            this.setCertSNByParam(f.issuersn);
            this.setCertIssuerByParam(f.issuersn);
          }
        }
      };
      extendClass(KJUR.asn1.x509.AuthorityKeyIdentifier, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.SubjectKeyIdentifier = function(d) {
        KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, d);
        var b = KJUR, a = b.asn1, c = a.DEROctetString;
        this.asn1KID = null;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = this.asn1KID;
          return this.asn1ExtnValue.tohex();
        };
        this.setKIDByParam = function(g) {
          if (g.str !== void 0 || g.hex !== void 0) {
            this.asn1KID = new c(g);
          } else {
            if (typeof g === "object" && KJUR.crypto.Util.isKey(g) || typeof g === "string" && g.indexOf("BEGIN") != -1) {
              var f = g;
              if (typeof g === "string") {
                f = KEYUTIL.getKey(g);
              }
              var e2 = KEYUTIL.getKeyID(f);
              this.asn1KID = new KJUR.asn1.DEROctetString({ hex: e2 });
            }
          }
        };
        this.oid = "2.5.29.14";
        if (d !== void 0) {
          if (d.kid !== void 0) {
            this.setKIDByParam(d.kid);
          }
        }
      };
      extendClass(KJUR.asn1.x509.SubjectKeyIdentifier, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.AuthorityInfoAccess = function(a) {
        KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, a);
        this.setAccessDescriptionArray = function(k) {
          var d = new Array(), b = KJUR, g = b.asn1, c = g.DERSequence, j = g.DERObjectIdentifier, l = g.x509.GeneralName;
          for (var f = 0; f < k.length; f++) {
            var e2;
            var h = k[f];
            if (h.ocsp !== void 0) {
              e2 = new c({ array: [new j({ oid: "1.3.6.1.5.5.7.48.1" }), new l({ uri: h.ocsp })] });
            } else {
              if (h.caissuer !== void 0) {
                e2 = new c({ array: [new j({ oid: "1.3.6.1.5.5.7.48.2" }), new l({ uri: h.caissuer })] });
              } else {
                throw new Error("unknown AccessMethod parameter: " + JSON.stringify(h));
              }
            }
            d.push(e2);
          }
          this.asn1ExtnValue = new c({ array: d });
        };
        this.getExtnValueHex = function() {
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "1.3.6.1.5.5.7.1.1";
        if (a !== void 0) {
          if (a.array !== void 0) {
            this.setAccessDescriptionArray(a.array);
          }
        }
      };
      extendClass(KJUR.asn1.x509.AuthorityInfoAccess, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.SubjectAltName = function(a) {
        KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this, a);
        this.setNameArray = function(b) {
          this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
        };
        this.getExtnValueHex = function() {
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.17";
        if (a !== void 0) {
          if (a.array !== void 0) {
            this.setNameArray(a.array);
          }
        }
      };
      extendClass(KJUR.asn1.x509.SubjectAltName, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.IssuerAltName = function(a) {
        KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this, a);
        this.setNameArray = function(b) {
          this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
        };
        this.getExtnValueHex = function() {
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.18";
        if (a !== void 0) {
          if (a.array !== void 0) {
            this.setNameArray(a.array);
          }
        }
      };
      extendClass(KJUR.asn1.x509.IssuerAltName, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.SubjectDirectoryAttributes = function(e2) {
        KJUR.asn1.x509.SubjectDirectoryAttributes.superclass.constructor.call(this, e2);
        var c = KJUR.asn1, a = c.DERSequence, b = c.ASN1Util.newObject, d = c.x509.OID.name2oid;
        this.params = null;
        this.getExtnValueHex = function() {
          var f = [];
          for (var j = 0; j < this.params.array.length; j++) {
            var k = this.params.array[j];
            var h = { seq: [{ oid: "1.2.3.4" }, { set: [{ utf8str: "DE" }] }] };
            if (k.attr == "dateOfBirth") {
              h.seq[0].oid = d(k.attr);
              h.seq[1].set[0] = { gentime: k.str };
            } else {
              if (k.attr == "placeOfBirth") {
                h.seq[0].oid = d(k.attr);
                h.seq[1].set[0] = { utf8str: k.str };
              } else {
                if (k.attr == "gender") {
                  h.seq[0].oid = d(k.attr);
                  h.seq[1].set[0] = { prnstr: k.str };
                } else {
                  if (k.attr == "countryOfCitizenship") {
                    h.seq[0].oid = d(k.attr);
                    h.seq[1].set[0] = { prnstr: k.str };
                  } else {
                    if (k.attr == "countryOfResidence") {
                      h.seq[0].oid = d(k.attr);
                      h.seq[1].set[0] = { prnstr: k.str };
                    } else {
                      throw new Error("unsupported attribute: " + k.attr);
                    }
                  }
                }
              }
            }
            f.push(new b(h));
          }
          var g = new a({ array: f });
          this.asn1ExtnValue = g;
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.9";
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.x509.SubjectDirectoryAttributes, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.PrivateExtension = function(f) {
        KJUR.asn1.x509.PrivateExtension.superclass.constructor.call(this, f);
        var c = KJUR, e2 = c.lang.String.isHex, b = c.asn1, d = b.x509.OID.name2oid, a = b.ASN1Util.newObject;
        this.params = null;
        this.setByParam = function(g) {
          this.oid = d(g.extname);
          this.params = g;
        };
        this.getExtnValueHex = function() {
          if (this.params.extname == void 0 || this.params.extn == void 0) {
            throw new Error("extname or extnhex not specified");
          }
          var h = this.params.extn;
          if (typeof h == "string" && e2(h)) {
            return h;
          } else {
            if (typeof h == "object") {
              try {
                return a(h).tohex();
              } catch (g) {
              }
            }
          }
          throw new Error("unsupported extn value");
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.x509.PrivateExtension, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.CRL = function(g) {
        KJUR.asn1.x509.CRL.superclass.constructor.call(this);
        var c = KJUR, b = c.asn1, a = b.DERSequence, e2 = b.DERBitString, f = b.x509, d = f.AlgorithmIdentifier, h = f.TBSCertList;
        this.params = void 0;
        this.setByParam = function(i) {
          this.params = i;
        };
        this.sign = function() {
          var j = new h(this.params).tohex();
          var k = new KJUR.crypto.Signature({ alg: this.params.sigalg });
          k.init(this.params.cakey);
          k.updateHex(j);
          var i = k.sign();
          this.params.sighex = i;
        };
        this.getPEM = function() {
          return hextopem(this.tohex(), "X509 CRL");
        };
        this.tohex = function() {
          var k = this.params;
          if (k.tbsobj == void 0) {
            k.tbsobj = new h(k);
          }
          if (k.sighex == void 0 && k.cakey != void 0) {
            this.sign();
          }
          if (k.sighex == void 0) {
            throw new Error("sighex or cakey parameter not defined");
          }
          var i = [];
          i.push(k.tbsobj);
          i.push(new d({ name: k.sigalg }));
          i.push(new e2({ hex: "00" + k.sighex }));
          var j = new a({ array: i });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.params = g;
        }
      };
      extendClass(KJUR.asn1.x509.CRL, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.TBSCertList = function(f) {
        KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);
        var b = KJUR, i = b.asn1, h = i.DERInteger, g = i.DERSequence, c = i.DERTaggedObject, k = i.DERObjectIdentifier, d = i.x509, l = d.AlgorithmIdentifier, e2 = d.Time, j = d.Extensions, a = d.X500Name;
        this.params = null;
        this.setByParam = function(m) {
          this.params = m;
        };
        this.getRevCertSequence = function() {
          var m = [];
          var n2 = this.params.revcert;
          for (var o2 = 0; o2 < n2.length; o2++) {
            var p = [new h(n2[o2].sn), new e2(n2[o2].date)];
            if (n2[o2].ext != void 0) {
              p.push(new j(n2[o2].ext));
            }
            m.push(new g({ array: p }));
          }
          return new g({ array: m });
        };
        this.tohex = function() {
          var n2 = [];
          var r2 = this.params;
          if (r2.version != void 0) {
            var m = r2.version - 1;
            var p = new h({ "int": m });
            n2.push(p);
          }
          n2.push(new l({ name: r2.sigalg }));
          n2.push(new a(r2.issuer));
          n2.push(new e2(r2.thisupdate));
          if (r2.nextupdate != void 0) {
            n2.push(new e2(r2.nextupdate));
          }
          if (r2.revcert != void 0) {
            n2.push(this.getRevCertSequence());
          }
          if (r2.ext != void 0) {
            var q = new j(r2.ext);
            n2.push(new c({ tag: "a0", explicit: true, obj: q }));
          }
          var o2 = new g({ array: n2 });
          return o2.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.x509.TBSCertList, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.CRLEntry = function(e2) {
        KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);
        var d = null, c = null, b = KJUR, a = b.asn1;
        this.setCertSerial = function(f) {
          this.sn = new a.DERInteger(f);
        };
        this.setRevocationDate = function(f) {
          this.time = new a.x509.Time(f);
        };
        this.tohex = function() {
          var f = new a.DERSequence({ array: [this.sn, this.time] });
          this.TLV = f.tohex();
          return this.TLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          if (e2.time !== void 0) {
            this.setRevocationDate(e2.time);
          }
          if (e2.sn !== void 0) {
            this.setCertSerial(e2.sn);
          }
        }
      };
      extendClass(KJUR.asn1.x509.CRLEntry, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.CRLNumber = function(a) {
        KJUR.asn1.x509.CRLNumber.superclass.constructor.call(this, a);
        this.params = void 0;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = new KJUR.asn1.DERInteger(this.params.num);
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.20";
        if (a != void 0) {
          this.params = a;
        }
      };
      extendClass(KJUR.asn1.x509.CRLNumber, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.CRLReason = function(a) {
        KJUR.asn1.x509.CRLReason.superclass.constructor.call(this, a);
        this.params = void 0;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = new KJUR.asn1.DEREnumerated(this.params.code);
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "2.5.29.21";
        if (a != void 0) {
          this.params = a;
        }
      };
      extendClass(KJUR.asn1.x509.CRLReason, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.OCSPNonce = function(a) {
        KJUR.asn1.x509.OCSPNonce.superclass.constructor.call(this, a);
        this.params = void 0;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = new KJUR.asn1.DEROctetString(this.params);
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "1.3.6.1.5.5.7.48.1.2";
        if (a != void 0) {
          this.params = a;
        }
      };
      extendClass(KJUR.asn1.x509.OCSPNonce, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.OCSPNoCheck = function(a) {
        KJUR.asn1.x509.OCSPNoCheck.superclass.constructor.call(this, a);
        this.params = void 0;
        this.getExtnValueHex = function() {
          this.asn1ExtnValue = new KJUR.asn1.DERNull();
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "1.3.6.1.5.5.7.48.1.5";
        if (a != void 0) {
          this.params = a;
        }
      };
      extendClass(KJUR.asn1.x509.OCSPNoCheck, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.AdobeTimeStamp = function(g) {
        KJUR.asn1.x509.AdobeTimeStamp.superclass.constructor.call(this, g);
        var c = KJUR, b = c.asn1, f = b.DERInteger, d = b.DERBoolean, a = b.DERSequence, e2 = b.x509.GeneralName;
        this.params = null;
        this.getExtnValueHex = function() {
          var i = this.params;
          var h = [new f(1)];
          h.push(new e2({ uri: i.uri }));
          if (i.reqauth != void 0) {
            h.push(new d(i.reqauth));
          }
          this.asn1ExtnValue = new a({ array: h });
          return this.asn1ExtnValue.tohex();
        };
        this.oid = "1.2.840.113583.1.1.9.1";
        if (g !== void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.x509.AdobeTimeStamp, KJUR.asn1.x509.Extension);
      KJUR.asn1.x509.X500Name = function(f) {
        KJUR.asn1.x509.X500Name.superclass.constructor.call(this);
        this.asn1Array = [];
        this.paramArray = [];
        this.sRule = "utf8";
        var c = KJUR, b = c.asn1, e2 = b.x509, d = e2.RDN, a = pemtohex;
        this.setByString = function(g, l) {
          if (l !== void 0) {
            this.sRule = l;
          }
          var k = g.split("/");
          k.shift();
          var j = [];
          for (var m = 0; m < k.length; m++) {
            if (k[m].match(/^[^=]+=.+$/)) {
              j.push(k[m]);
            } else {
              var h = j.length - 1;
              j[h] = j[h] + "/" + k[m];
            }
          }
          for (var m = 0; m < j.length; m++) {
            this.asn1Array.push(new d({ str: j[m], rule: this.sRule }));
          }
        };
        this.setByLdapString = function(g, h) {
          if (h !== void 0) {
            this.sRule = h;
          }
          var i = e2.X500Name.ldapToCompat(g);
          this.setByString(i, h);
        };
        this.setByObject = function(j, i) {
          if (i !== void 0) {
            this.sRule = i;
          }
          for (var g in j) {
            if (j.hasOwnProperty(g)) {
              var h = new d({ str: g + "=" + j[g], rule: this.sRule });
              this.asn1Array ? this.asn1Array.push(h) : this.asn1Array = [h];
            }
          }
        };
        this.setByParam = function(h) {
          if (h.rule !== void 0) {
            this.sRule = h.rule;
          }
          if (h.array !== void 0) {
            this.paramArray = h.array;
          } else {
            if (h.str !== void 0) {
              this.setByString(h.str);
            } else {
              if (h.ldapstr !== void 0) {
                this.setByLdapString(h.ldapstr);
              } else {
                if (h.hex !== void 0) {
                  this.hTLV = h.hex;
                } else {
                  if (h.certissuer !== void 0) {
                    var g = new X509();
                    g.readCertPEM(h.certissuer);
                    this.hTLV = g.getIssuerHex();
                  } else {
                    if (h.certsubject !== void 0) {
                      var g = new X509();
                      g.readCertPEM(h.certsubject);
                      this.hTLV = g.getSubjectHex();
                    } else {
                      if (typeof h === "object" && h.certsubject === void 0 && h.certissuer === void 0) {
                        this.setByObject(h);
                      }
                    }
                  }
                }
              }
            }
          }
        };
        this.tohex = function() {
          if (typeof this.hTLV == "string") {
            return this.hTLV;
          }
          if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
            for (var g = 0; g < this.paramArray.length; g++) {
              var k = { array: this.paramArray[g] };
              if (this.sRule != "utf8") {
                k.rule = this.sRule;
              }
              var h = new d(k);
              this.asn1Array.push(h);
            }
          }
          var j = new b.DERSequence({ array: this.asn1Array });
          this.hTLV = j.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.x509.X500Name, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.X500Name.compatToLDAP = function(d) {
        if (d.substr(0, 1) !== "/") {
          throw "malformed input";
        }
        var b = "";
        d = d.substr(1);
        var c = d.split("/");
        c.reverse();
        c = c.map(function(a) {
          return a.replace(/,/, "\\,");
        });
        return c.join(",");
      };
      KJUR.asn1.x509.X500Name.onelineToLDAP = function(a) {
        return KJUR.asn1.x509.X500Name.compatToLDAP(a);
      };
      KJUR.asn1.x509.X500Name.ldapToCompat = function(g) {
        var c = g.split(",");
        var e2 = false;
        var b = [];
        for (var f = 0; c.length > 0; f++) {
          var h = c.shift();
          if (e2 === true) {
            var d = b.pop();
            var j = (d + "," + h).replace(/\\,/g, ",");
            b.push(j);
            e2 = false;
          } else {
            b.push(h);
          }
          if (h.substr(-1, 1) === "\\") {
            e2 = true;
          }
        }
        b = b.map(function(a) {
          return a.replace("/", "\\/");
        });
        b.reverse();
        return "/" + b.join("/");
      };
      KJUR.asn1.x509.X500Name.ldapToOneline = function(a) {
        return KJUR.asn1.x509.X500Name.ldapToCompat(a);
      };
      KJUR.asn1.x509.RDN = function(b) {
        KJUR.asn1.x509.RDN.superclass.constructor.call(this);
        this.asn1Array = [];
        this.paramArray = [];
        this.sRule = "utf8";
        var a = KJUR.asn1.x509.AttributeTypeAndValue;
        this.setByParam = function(c) {
          if (c.rule !== void 0) {
            this.sRule = c.rule;
          }
          if (c.str !== void 0) {
            this.addByMultiValuedString(c.str);
          }
          if (c.array !== void 0) {
            this.paramArray = c.array;
          }
        };
        this.addByString = function(c) {
          this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({ str: c, rule: this.sRule }));
        };
        this.addByMultiValuedString = function(e2) {
          var c = KJUR.asn1.x509.RDN.parseString(e2);
          for (var d = 0; d < c.length; d++) {
            this.addByString(c[d]);
          }
        };
        this.tohex = function() {
          if (this.asn1Array.length == 0 && this.paramArray.length > 0) {
            for (var d = 0; d < this.paramArray.length; d++) {
              var f = this.paramArray[d];
              if (f.rule !== void 0 && this.sRule != "utf8") {
                f.rule = this.sRule;
              }
              var c = new a(f);
              this.asn1Array.push(c);
            }
          }
          var e2 = new KJUR.asn1.DERSet({ array: this.asn1Array });
          this.TLV = e2.tohex();
          return this.TLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (b !== void 0) {
          this.setByParam(b);
        }
      };
      extendClass(KJUR.asn1.x509.RDN, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.RDN.parseString = function(m) {
        var j = m.split(/\+/);
        var h = false;
        var c = [];
        for (var g = 0; j.length > 0; g++) {
          var k = j.shift();
          if (h === true) {
            var f = c.pop();
            var d = (f + "+" + k).replace(/\\\+/g, "+");
            c.push(d);
            h = false;
          } else {
            c.push(k);
          }
          if (k.substr(-1, 1) === "\\") {
            h = true;
          }
        }
        var l = false;
        var b = [];
        for (var g = 0; c.length > 0; g++) {
          var k = c.shift();
          if (l === true) {
            var e2 = b.pop();
            if (k.match(/"$/)) {
              var d = (e2 + "+" + k).replace(/^([^=]+)="(.*)"$/, "$1=$2");
              b.push(d);
              l = false;
            } else {
              b.push(e2 + "+" + k);
            }
          } else {
            b.push(k);
          }
          if (k.match(/^[^=]+="/)) {
            l = true;
          }
        }
        return b;
      };
      KJUR.asn1.x509.AttributeTypeAndValue = function(c) {
        KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);
        this.sRule = "utf8";
        this.sType = null;
        this.sValue = null;
        this.dsType = null;
        var a = KJUR, g = a.asn1, d = g.DERSequence, l = g.DERUTF8String, i = g.DERPrintableString, h = g.DERTeletexString, b = g.DERIA5String, e2 = g.DERVisibleString, k = g.DERBMPString, f = a.lang.String.isMail, j = a.lang.String.isPrintable;
        this.setByParam = function(o2) {
          if (o2.rule !== void 0) {
            this.sRule = o2.rule;
          }
          if (o2.ds !== void 0) {
            this.dsType = o2.ds;
          }
          if (o2.value === void 0 && o2.str !== void 0) {
            var n2 = o2.str;
            var m = n2.match(/^([^=]+)=(.+)$/);
            if (m) {
              this.sType = m[1];
              this.sValue = m[2];
            } else {
              throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
            }
          } else {
            this.sType = o2.type;
            this.sValue = o2.value;
          }
        };
        this.setByString = function(n2, o2) {
          if (o2 !== void 0) {
            this.sRule = o2;
          }
          var m = n2.match(/^([^=]+)=(.+)$/);
          if (m) {
            this.setByAttrTypeAndValueStr(m[1], m[2]);
          } else {
            throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
          }
        };
        this._getDsType = function() {
          var o2 = this.sType;
          var n2 = this.sValue;
          var m = this.sRule;
          if (m === "prn") {
            if (o2 == "CN" && f(n2)) {
              return "ia5";
            }
            if (j(n2)) {
              return "prn";
            }
            return "utf8";
          } else {
            if (m === "utf8") {
              if (o2 == "CN" && f(n2)) {
                return "ia5";
              }
              if (o2 == "C") {
                return "prn";
              }
              return "utf8";
            }
          }
          return "utf8";
        };
        this.setByAttrTypeAndValueStr = function(o2, n2, m) {
          if (m !== void 0) {
            this.sRule = m;
          }
          this.sType = o2;
          this.sValue = n2;
        };
        this.getValueObj = function(n2, m) {
          if (n2 == "utf8") {
            return new l({ str: m });
          }
          if (n2 == "prn") {
            return new i({ str: m });
          }
          if (n2 == "tel") {
            return new h({ str: m });
          }
          if (n2 == "ia5") {
            return new b({ str: m });
          }
          if (n2 == "vis") {
            return new e2({ str: m });
          }
          if (n2 == "bmp") {
            return new k({ str: m });
          }
          throw new Error("unsupported directory string type: type=" + n2 + " value=" + m);
        };
        this.tohex = function() {
          if (this.dsType == null) {
            this.dsType = this._getDsType();
          }
          var n2 = KJUR.asn1.x509.OID.atype2obj(this.sType);
          var m = this.getValueObj(this.dsType, this.sValue);
          var p = new d({ array: [n2, m] });
          this.TLV = p.tohex();
          return this.TLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (c !== void 0) {
          this.setByParam(c);
        }
      };
      extendClass(KJUR.asn1.x509.AttributeTypeAndValue, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.SubjectPublicKeyInfo = function(f) {
        KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
        var l = null, k = null, a = KJUR, j = a.asn1, i = j.DERInteger, b = j.DERBitString, m = j.DERObjectIdentifier, e2 = j.DERSequence, h = j.ASN1Util.newObject, d = j.x509, o2 = d.AlgorithmIdentifier, g = a.crypto, n2 = g.ECDSA, c = g.DSA;
        this.getASN1Object = function() {
          if (this.asn1AlgId == null || this.asn1SubjPKey == null) {
            throw "algId and/or subjPubKey not set";
          }
          var p = new e2({ array: [this.asn1AlgId, this.asn1SubjPKey] });
          return p;
        };
        this.tohex = function() {
          var p = this.getASN1Object();
          this.hTLV = p.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setPubKey = function(q) {
          try {
            if (q instanceof RSAKey) {
              var u = h({ seq: [{ "int": { bigint: q.n } }, { "int": { "int": q.e } }] });
              var s = u.tohex();
              this.asn1AlgId = new o2({ name: "rsaEncryption" });
              this.asn1SubjPKey = new b({ hex: "00" + s });
            }
          } catch (p) {
          }
          try {
            if (q instanceof KJUR.crypto.ECDSA) {
              var r2 = new m({ name: q.curveName });
              this.asn1AlgId = new o2({ name: "ecPublicKey", asn1params: r2 });
              this.asn1SubjPKey = new b({ hex: "00" + q.pubKeyHex });
            }
          } catch (p) {
          }
          try {
            if (q instanceof KJUR.crypto.DSA) {
              var r2 = new h({ seq: [{ "int": { bigint: q.p } }, { "int": { bigint: q.q } }, { "int": { bigint: q.g } }] });
              this.asn1AlgId = new o2({ name: "dsa", asn1params: r2 });
              var t3 = new i({ bigint: q.y });
              this.asn1SubjPKey = new b({ hex: "00" + t3.tohex() });
            }
          } catch (p) {
          }
        };
        if (f !== void 0) {
          this.setPubKey(f);
        }
      };
      extendClass(KJUR.asn1.x509.SubjectPublicKeyInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.Time = function(f) {
        KJUR.asn1.x509.Time.superclass.constructor.call(this);
        var e2 = null, a = null, d = KJUR, c = d.asn1, b = c.DERUTCTime, g = c.DERGeneralizedTime;
        this.params = null;
        this.type = null;
        this.setTimeParams = function(h) {
          this.timeParams = h;
        };
        this.setByParam = function(h) {
          this.params = h;
        };
        this.getType = function(h) {
          if (h.match(/^[0-9]{12}Z$/)) {
            return "utc";
          }
          if (h.match(/^[0-9]{14}Z$/)) {
            return "gen";
          }
          if (h.match(/^[0-9]{12}\.[0-9]+Z$/)) {
            return "utc";
          }
          if (h.match(/^[0-9]{14}\.[0-9]+Z$/)) {
            return "gen";
          }
          return null;
        };
        this.tohex = function() {
          var i = this.params;
          var h = null;
          if (typeof i == "string") {
            i = { str: i };
          }
          if (i != null && i.str && (i.type == null || i.type == void 0)) {
            i.type = this.getType(i.str);
          }
          if (i != null && i.str) {
            if (i.type == "utc") {
              h = new b(i.str);
            }
            if (i.type == "gen") {
              h = new g(i.str);
            }
          } else {
            if (this.type == "gen") {
              h = new g();
            } else {
              h = new b();
            }
          }
          if (h == null) {
            throw new Error("wrong setting for Time");
          }
          this.TLV = h.tohex();
          return this.TLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      KJUR.asn1.x509.Time_bak = function(f) {
        KJUR.asn1.x509.Time_bak.superclass.constructor.call(this);
        var e2 = null, a = null, d = KJUR, c = d.asn1, b = c.DERUTCTime, g = c.DERGeneralizedTime;
        this.setTimeParams = function(h) {
          this.timeParams = h;
        };
        this.tohex = function() {
          var h = null;
          if (this.timeParams != null) {
            if (this.type == "utc") {
              h = new b(this.timeParams);
            } else {
              h = new g(this.timeParams);
            }
          } else {
            if (this.type == "utc") {
              h = new b();
            } else {
              h = new g();
            }
          }
          this.TLV = h.tohex();
          return this.TLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.type = "utc";
        if (f !== void 0) {
          if (f.type !== void 0) {
            this.type = f.type;
          } else {
            if (f.str !== void 0) {
              if (f.str.match(/^[0-9]{12}Z$/)) {
                this.type = "utc";
              }
              if (f.str.match(/^[0-9]{14}Z$/)) {
                this.type = "gen";
              }
            }
          }
          this.timeParams = f;
        }
      };
      extendClass(KJUR.asn1.x509.Time, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.AlgorithmIdentifier = function(e2) {
        KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);
        this.nameAlg = null;
        this.asn1Alg = null;
        this.asn1Params = null;
        this.paramEmpty = false;
        var b = KJUR, a = b.asn1, c = a.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
        this.tohex = function() {
          if (this.nameAlg === null && this.asn1Alg === null) {
            throw new Error("algorithm not specified");
          }
          if (this.nameAlg !== null) {
            var f = null;
            for (var h in c) {
              if (h === this.nameAlg) {
                f = c[h];
              }
            }
            if (f !== null) {
              this.hTLV = f;
              return this.hTLV;
            }
          }
          if (this.nameAlg !== null && this.asn1Alg === null) {
            this.asn1Alg = a.x509.OID.name2obj(this.nameAlg);
          }
          var g = [this.asn1Alg];
          if (this.asn1Params !== null) {
            g.push(this.asn1Params);
          }
          var i = new a.DERSequence({ array: g });
          this.hTLV = i.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          if (e2.name !== void 0) {
            this.nameAlg = e2.name;
          }
          if (e2.asn1params !== void 0) {
            this.asn1Params = e2.asn1params;
          }
          if (e2.paramempty !== void 0) {
            this.paramEmpty = e2.paramempty;
          }
        }
        if (this.asn1Params === null && this.paramEmpty === false && this.nameAlg !== null) {
          if (this.nameAlg.name !== void 0) {
            this.nameAlg = this.nameAlg.name;
          }
          var d = this.nameAlg.toLowerCase();
          if (d.substr(-7, 7) !== "withdsa" && d.substr(-9, 9) !== "withecdsa") {
            this.asn1Params = new a.DERNull();
          }
        }
      };
      extendClass(KJUR.asn1.x509.AlgorithmIdentifier, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = { SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000", SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120", SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130", SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140" };
      KJUR.asn1.x509.GeneralName = function(f) {
        KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);
        var l = { rfc822: "81", dns: "82", dn: "a4", uri: "86", ip: "87", otherName: "a0" }, b = KJUR, h = b.asn1, d = h.x509, a = d.X500Name, g = d.OtherName, e2 = h.DERIA5String, i = h.DERPrintableString, k = h.DEROctetString, c = h.DERTaggedObject, m = h.ASN1Object, j = Error;
        this.params = null;
        this.setByParam = function(n2) {
          this.params = n2;
        };
        this.tohex = function() {
          var p = this.params;
          var A, y, q;
          var y = false;
          if (p.other !== void 0) {
            A = "a0", q = new g(p.other);
          } else {
            if (p.rfc822 !== void 0) {
              A = "81";
              q = new e2({ str: p.rfc822 });
            } else {
              if (p.dns !== void 0) {
                A = "82";
                q = new e2({ str: p.dns });
              } else {
                if (p.dn !== void 0) {
                  A = "a4";
                  y = true;
                  if (typeof p.dn === "string") {
                    q = new a({ str: p.dn });
                  } else {
                    if (p.dn instanceof KJUR.asn1.x509.X500Name) {
                      q = p.dn;
                    } else {
                      q = new a(p.dn);
                    }
                  }
                } else {
                  if (p.ldapdn !== void 0) {
                    A = "a4";
                    y = true;
                    q = new a({ ldapstr: p.ldapdn });
                  } else {
                    if (p.certissuer !== void 0 || p.certsubj !== void 0) {
                      A = "a4";
                      y = true;
                      var n2, o2;
                      var z2 = null;
                      if (p.certsubj !== void 0) {
                        n2 = false;
                        o2 = p.certsubj;
                      } else {
                        n2 = true;
                        o2 = p.certissuer;
                      }
                      if (o2.match(/^[0-9A-Fa-f]+$/)) {
                        z2 == o2;
                      }
                      if (o2.indexOf("-----BEGIN ") != -1) {
                        z2 = pemtohex(o2);
                      }
                      if (z2 == null) {
                        throw new Error("certsubj/certissuer not cert");
                      }
                      var w = new X509();
                      w.hex = z2;
                      var s;
                      if (n2) {
                        s = w.getIssuerHex();
                      } else {
                        s = w.getSubjectHex();
                      }
                      q = new m();
                      q.hTLV = s;
                    } else {
                      if (p.uri !== void 0) {
                        A = "86";
                        q = new e2({ str: p.uri });
                      } else {
                        if (p.ip !== void 0) {
                          A = "87";
                          var v;
                          var t3 = p.ip;
                          try {
                            if (t3.match(/^[0-9a-f]+$/)) {
                              var r2 = t3.length;
                              if (r2 == 8 || r2 == 16 || r2 == 32 || r2 == 64) {
                                v = t3;
                              } else {
                                throw "err";
                              }
                            } else {
                              v = iptohex(t3);
                            }
                          } catch (u) {
                            throw new j("malformed IP address: " + p.ip + ":" + u.message);
                          }
                          q = new k({ hex: v });
                        } else {
                          throw new j("improper params");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          var B = new c({ tag: A, explicit: y, obj: q });
          return B.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.x509.GeneralName, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.GeneralNames = function(d) {
        KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);
        var a = null, c = KJUR, b = c.asn1;
        this.setByParamArray = function(g) {
          for (var e2 = 0; e2 < g.length; e2++) {
            var f = new b.x509.GeneralName(g[e2]);
            this.asn1Array.push(f);
          }
        };
        this.tohex = function() {
          var e2 = new b.DERSequence({ array: this.asn1Array });
          return e2.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.asn1Array = new Array();
        if (typeof d != "undefined") {
          this.setByParamArray(d);
        }
      };
      extendClass(KJUR.asn1.x509.GeneralNames, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.OtherName = function(g) {
        KJUR.asn1.x509.OtherName.superclass.constructor.call(this);
        var f = null, e2 = null, d = KJUR, c = d.asn1, h = c.DERObjectIdentifier, a = c.DERSequence, b = c.ASN1Util.newObject;
        this.params = null;
        this.setByParam = function(i) {
          this.params = i;
        };
        this.tohex = function() {
          var k = this.params;
          if (k.oid == void 0 || k.value == void 0) {
            throw new Error("oid or value not specified");
          }
          var l = new h({ oid: k.oid });
          var i = b({ tag: { tag: "a0", explicit: true, obj: k.value } });
          var j = new a({ array: [l, i] });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g !== void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.x509.OtherName, KJUR.asn1.ASN1Object);
      KJUR.asn1.x509.OID = new function() {
        var a = KJUR.asn1.DERObjectIdentifier;
        this.name2oidList = { sha1: "1.3.14.3.2.26", sha256: "2.16.840.1.101.3.4.2.1", sha384: "2.16.840.1.101.3.4.2.2", sha512: "2.16.840.1.101.3.4.2.3", sha224: "2.16.840.1.101.3.4.2.4", md5: "1.2.840.113549.2.5", md2: "1.3.14.7.2.2.1", ripemd160: "1.3.36.3.2.1", MD2withRSA: "1.2.840.113549.1.1.2", MD4withRSA: "1.2.840.113549.1.1.3", MD5withRSA: "1.2.840.113549.1.1.4", SHA1withRSA: "1.2.840.113549.1.1.5", "pkcs1-MGF": "1.2.840.113549.1.1.8", rsaPSS: "1.2.840.113549.1.1.10", SHA224withRSA: "1.2.840.113549.1.1.14", SHA256withRSA: "1.2.840.113549.1.1.11", SHA384withRSA: "1.2.840.113549.1.1.12", SHA512withRSA: "1.2.840.113549.1.1.13", SHA1withECDSA: "1.2.840.10045.4.1", SHA224withECDSA: "1.2.840.10045.4.3.1", SHA256withECDSA: "1.2.840.10045.4.3.2", SHA384withECDSA: "1.2.840.10045.4.3.3", SHA512withECDSA: "1.2.840.10045.4.3.4", dsa: "1.2.840.10040.4.1", SHA1withDSA: "1.2.840.10040.4.3", SHA224withDSA: "2.16.840.1.101.3.4.3.1", SHA256withDSA: "2.16.840.1.101.3.4.3.2", rsaEncryption: "1.2.840.113549.1.1.1", commonName: "2.5.4.3", countryName: "2.5.4.6", localityName: "2.5.4.7", stateOrProvinceName: "2.5.4.8", streetAddress: "2.5.4.9", organizationName: "2.5.4.10", organizationalUnitName: "2.5.4.11", domainComponent: "0.9.2342.19200300.100.1.25", userId: "0.9.2342.19200300.100.1.1", surname: "2.5.4.4", givenName: "2.5.4.42", title: "2.5.4.12", distinguishedName: "2.5.4.49", emailAddress: "1.2.840.113549.1.9.1", description: "2.5.4.13", businessCategory: "2.5.4.15", postalCode: "2.5.4.17", uniqueIdentifier: "2.5.4.45", organizationIdentifier: "2.5.4.97", jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1", jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2", jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3", subjectDirectoryAttributes: "2.5.29.9", subjectKeyIdentifier: "2.5.29.14", keyUsage: "2.5.29.15", subjectAltName: "2.5.29.17", issuerAltName: "2.5.29.18", basicConstraints: "2.5.29.19", cRLNumber: "2.5.29.20", cRLReason: "2.5.29.21", nameConstraints: "2.5.29.30", cRLDistributionPoints: "2.5.29.31", certificatePolicies: "2.5.29.32", anyPolicy: "2.5.29.32.0", policyMappings: "2.5.29.33", authorityKeyIdentifier: "2.5.29.35", policyConstraints: "2.5.29.36", extKeyUsage: "2.5.29.37", inhibitAnyPolicy: "2.5.29.54", authorityInfoAccess: "1.3.6.1.5.5.7.1.1", ocsp: "1.3.6.1.5.5.7.48.1", ocspBasic: "1.3.6.1.5.5.7.48.1.1", ocspNonce: "1.3.6.1.5.5.7.48.1.2", ocspNoCheck: "1.3.6.1.5.5.7.48.1.5", caIssuers: "1.3.6.1.5.5.7.48.2", anyExtendedKeyUsage: "2.5.29.37.0", serverAuth: "1.3.6.1.5.5.7.3.1", clientAuth: "1.3.6.1.5.5.7.3.2", codeSigning: "1.3.6.1.5.5.7.3.3", emailProtection: "1.3.6.1.5.5.7.3.4", timeStamping: "1.3.6.1.5.5.7.3.8", ocspSigning: "1.3.6.1.5.5.7.3.9", smtpUTF8Mailbox: "1.3.6.1.5.5.7.8.9", dateOfBirth: "1.3.6.1.5.5.7.9.1", placeOfBirth: "1.3.6.1.5.5.7.9.2", gender: "1.3.6.1.5.5.7.9.3", countryOfCitizenship: "1.3.6.1.5.5.7.9.4", countryOfResidence: "1.3.6.1.5.5.7.9.5", ecPublicKey: "1.2.840.10045.2.1", "P-256": "1.2.840.10045.3.1.7", secp256r1: "1.2.840.10045.3.1.7", secp256k1: "1.3.132.0.10", secp384r1: "1.3.132.0.34", secp521r1: "1.3.132.0.35", pkcs5PBES2: "1.2.840.113549.1.5.13", pkcs5PBKDF2: "1.2.840.113549.1.5.12", "des-EDE3-CBC": "1.2.840.113549.3.7", data: "1.2.840.113549.1.7.1", "signed-data": "1.2.840.113549.1.7.2", "enveloped-data": "1.2.840.113549.1.7.3", "digested-data": "1.2.840.113549.1.7.5", "encrypted-data": "1.2.840.113549.1.7.6", "authenticated-data": "1.2.840.113549.1.9.16.1.2", tstinfo: "1.2.840.113549.1.9.16.1.4", signingCertificate: "1.2.840.113549.1.9.16.2.12", timeStampToken: "1.2.840.113549.1.9.16.2.14", signaturePolicyIdentifier: "1.2.840.113549.1.9.16.2.15", etsArchiveTimeStamp: "1.2.840.113549.1.9.16.2.27", signingCertificateV2: "1.2.840.113549.1.9.16.2.47", etsArchiveTimeStampV2: "1.2.840.113549.1.9.16.2.48", extensionRequest: "1.2.840.113549.1.9.14", contentType: "1.2.840.113549.1.9.3", messageDigest: "1.2.840.113549.1.9.4", signingTime: "1.2.840.113549.1.9.5", counterSignature: "1.2.840.113549.1.9.6", archiveTimeStampV3: "0.4.0.1733.2.4", pdfRevocationInfoArchival: "1.2.840.113583.1.1.8", adobeTimeStamp: "1.2.840.113583.1.1.9.1" };
        this.atype2oidList = { CN: "2.5.4.3", L: "2.5.4.7", ST: "2.5.4.8", O: "2.5.4.10", OU: "2.5.4.11", C: "2.5.4.6", STREET: "2.5.4.9", DC: "0.9.2342.19200300.100.1.25", UID: "0.9.2342.19200300.100.1.1", SN: "2.5.4.4", T: "2.5.4.12", DN: "2.5.4.49", E: "1.2.840.113549.1.9.1", description: "2.5.4.13", businessCategory: "2.5.4.15", postalCode: "2.5.4.17", serialNumber: "2.5.4.5", uniqueIdentifier: "2.5.4.45", organizationIdentifier: "2.5.4.97", jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1", jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2", jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3" };
        this.objCache = {};
        this.name2obj = function(b) {
          if (typeof this.objCache[b] != "undefined") {
            return this.objCache[b];
          }
          if (typeof this.name2oidList[b] == "undefined") {
            throw "Name of ObjectIdentifier not defined: " + b;
          }
          var c = this.name2oidList[b];
          var d = new a({ oid: c });
          this.objCache[b] = d;
          return d;
        };
        this.atype2obj = function(b) {
          if (this.objCache[b] !== void 0) {
            return this.objCache[b];
          }
          var c;
          if (b.match(/^\d+\.\d+\.[0-9.]+$/)) {
            c = b;
          } else {
            if (this.atype2oidList[b] !== void 0) {
              c = this.atype2oidList[b];
            } else {
              if (this.name2oidList[b] !== void 0) {
                c = this.name2oidList[b];
              } else {
                throw new Error("AttributeType name undefined: " + b);
              }
            }
          }
          var d = new a({ oid: c });
          this.objCache[b] = d;
          return d;
        };
        this.registerOIDs = function(b) {
          if (!this.checkOIDs(b)) {
            return;
          }
          for (var c in b) {
            this.name2oidList[c] = b[c];
          }
        };
        this.checkOIDs = function(b) {
          try {
            var d = Object.keys(b);
            if (d.length == 0) {
              return false;
            }
            d.map(function(g, e2, h) {
              var f = this[g];
              if (!f.match(/^[0-2]\.[0-9.]+$/)) {
                throw new Error("value is not OID");
              }
            }, b);
            return true;
          } catch (c) {
            return false;
          }
        };
      }();
      KJUR.asn1.x509.OID.oid2name = function(b) {
        var c = KJUR.asn1.x509.OID.name2oidList;
        for (var a in c) {
          if (c[a] == b) {
            return a;
          }
        }
        return "";
      };
      KJUR.asn1.x509.OID.oid2atype = function(b) {
        var c = KJUR.asn1.x509.OID.atype2oidList;
        for (var a in c) {
          if (c[a] == b) {
            return a;
          }
        }
        return b;
      };
      KJUR.asn1.x509.OID.name2oid = function(a) {
        if (a.match(/^[0-9.]+$/)) {
          return a;
        }
        var b = KJUR.asn1.x509.OID.name2oidList;
        if (b[a] === void 0) {
          return "";
        }
        return b[a];
      };
      KJUR.asn1.x509.X509Util = {};
      KJUR.asn1.x509.X509Util.newCertPEM = function(e2) {
        var d = KJUR.asn1.x509, b = d.TBSCertificate, a = d.Certificate;
        var c = new a(e2);
        return c.getPEM();
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      if (typeof KJUR.asn1.cms == "undefined" || !KJUR.asn1.cms) {
        KJUR.asn1.cms = {};
      }
      KJUR.asn1.cms.Attribute = function(f) {
        var e2 = Error, d = KJUR, c = d.asn1, b = c.DERSequence, a = c.DERSet, g = c.DERObjectIdentifier;
        this.params = null;
        this.typeOid = null;
        this.setByParam = function(h) {
          this.params = h;
        };
        this.getValueArray = function() {
          throw new e2("not yet implemented abstract");
        };
        this.tohex = function() {
          var j = new g({ oid: this.typeOid });
          var h = new a({ array: this.getValueArray() });
          var i = new b({ array: [j, h] });
          return i.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
      };
      extendClass(KJUR.asn1.cms.Attribute, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.ContentType = function(c) {
        var b = KJUR, a = b.asn1;
        a.cms.ContentType.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.3";
        this.getValueArray = function() {
          var d = new a.DERObjectIdentifier(this.params.type);
          return [d];
        };
        if (c != void 0) {
          this.setByParam(c);
        }
      };
      extendClass(KJUR.asn1.cms.ContentType, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cms.MessageDigest = function(e2) {
        var b = KJUR, a = b.asn1, c = a.DEROctetString, d = a.cms;
        d.MessageDigest.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.4";
        this.getValueArray = function() {
          var f = new c(this.params);
          return [f];
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cms.MessageDigest, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cms.SigningTime = function(c) {
        var b = KJUR, a = b.asn1;
        a.cms.SigningTime.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.5";
        this.getValueArray = function() {
          var d = new a.x509.Time(this.params);
          return [d];
        };
        if (c != void 0) {
          this.setByParam(c);
        }
      };
      extendClass(KJUR.asn1.cms.SigningTime, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cms.SigningCertificate = function(h) {
        var e2 = Error, d = KJUR, c = d.asn1, b = c.DERSequence, g = c.cms, a = g.ESSCertID, f = d.crypto;
        g.SigningCertificate.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.16.2.12";
        this.getValueArray = function() {
          if (this.params == null || this.params == void 0 || this.params.array == void 0) {
            throw new e2("parameter 'array' not specified");
          }
          var o2 = this.params.array;
          var k = [];
          for (var l = 0; l < o2.length; l++) {
            var n2 = o2[l];
            if (h.hasis == false && (typeof n2 == "string" && (n2.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n2)))) {
              n2 = { cert: n2 };
            }
            if (n2.hasis != false && h.hasis == false) {
              n2.hasis = false;
            }
            k.push(new a(n2));
          }
          var j = new b({ array: k });
          var m = new b({ array: [j] });
          return [m];
        };
        if (h != void 0) {
          this.setByParam(h);
        }
      };
      extendClass(KJUR.asn1.cms.SigningCertificate, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cms.ESSCertID = function(g) {
        KJUR.asn1.cms.ESSCertID.superclass.constructor.call(this);
        var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e2 = b.cms.IssuerSerial;
        this.params = null;
        this.getCertHash = function(k, h) {
          if (k.hash != void 0) {
            return k.hash;
          }
          if (typeof k == "string" && k.indexOf("-----BEGIN") == -1 && !ASN1HEX.isASN1HEX(k)) {
            return k;
          }
          var i;
          if (typeof k == "string") {
            i = k;
          } else {
            if (k.cert != void 0) {
              i = k.cert;
            } else {
              throw new d("hash nor cert unspecified");
            }
          }
          var j;
          if (i.indexOf("-----BEGIN") != -1) {
            j = pemtohex(i);
          } else {
            j = i;
          }
          if (typeof k == "string") {
            if (k.indexOf("-----BEGIN") != -1) {
              j = pemtohex(k);
            } else {
              if (ASN1HEX.isASN1HEX(k)) {
                j = k;
              }
            }
          }
          var l;
          if (k.alg != void 0) {
            l = k.alg;
          } else {
            if (h != void 0) {
              l = h;
            } else {
              throw new d("hash alg unspecified");
            }
          }
          return c.crypto.Util.hashHex(j, l);
        };
        this.tohex = function() {
          var k = this.params;
          var j = this.getCertHash(k, "sha1");
          var h = [];
          h.push(new f({ hex: j }));
          if (typeof k == "string" && k.indexOf("-----BEGIN") != -1 || k.cert != void 0 && k.hasis != false || k.issuer != void 0 && k.serial != void 0) {
            h.push(new e2(k));
          }
          var i = new a({ array: h });
          return i.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cms.ESSCertID, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.SigningCertificateV2 = function(d) {
        var h = Error, a = KJUR, g = a.asn1, e2 = g.DERSequence, b = g.x509, i = g.cms, c = i.ESSCertIDv2, f = a.crypto;
        i.SigningCertificateV2.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.16.2.47";
        this.getValueArray = function() {
          if (this.params == null || this.params == void 0 || this.params.array == void 0) {
            throw new h("parameter 'array' not specified");
          }
          var o2 = this.params.array;
          var l = [];
          for (var m = 0; m < o2.length; m++) {
            var n2 = o2[m];
            if ((d.alg != void 0 || d.hasis == false) && (typeof n2 == "string" && (n2.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n2)))) {
              n2 = { cert: n2 };
            }
            if (n2.alg == void 0 && d.alg != void 0) {
              n2.alg = d.alg;
            }
            if (n2.hasis != false && d.hasis == false) {
              n2.hasis = false;
            }
            l.push(new c(n2));
          }
          var k = new e2({ array: l });
          var j = new e2({ array: [k] });
          return [j];
        };
        if (d != void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.cms.SigningCertificateV2, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cms.ESSCertIDv2 = function(h) {
        KJUR.asn1.cms.ESSCertIDv2.superclass.constructor.call(this);
        var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e2 = b.cms.IssuerSerial, g = b.x509.AlgorithmIdentifier;
        this.params = null;
        this.tohex = function() {
          var l = this.params;
          var k = this.getCertHash(l, "sha256");
          var i = [];
          if (l.alg != void 0 && l.alg != "sha256") {
            i.push(new g({ name: l.alg }));
          }
          i.push(new f({ hex: k }));
          if (typeof l == "string" && l.indexOf("-----BEGIN") != -1 || l.cert != void 0 && l.hasis != false || l.issuer != void 0 && l.serial != void 0) {
            i.push(new e2(l));
          }
          var j = new a({ array: i });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (h != void 0) {
          this.setByParam(h);
        }
      };
      extendClass(KJUR.asn1.cms.ESSCertIDv2, KJUR.asn1.cms.ESSCertID);
      KJUR.asn1.cms.IssuerSerial = function(e2) {
        var i = Error, c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.GeneralNames, b = X509;
        j.IssuerSerial.superclass.constructor.call(this);
        this.setByParam = function(k) {
          this.params = k;
        };
        this.tohex = function() {
          var p = this.params;
          var l, r2;
          if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != void 0) {
            var n2;
            if (p.cert != void 0) {
              n2 = p.cert;
            } else {
              n2 = p;
            }
            var k = new b();
            k.readCertPEM(n2);
            l = k.getIssuer();
            r2 = { hex: k.getSerialNumberHex() };
          } else {
            if (p.issuer != void 0 && p.serial) {
              l = p.issuer;
              r2 = p.serial;
            } else {
              throw new i("cert or issuer and serial parameter not specified");
            }
          }
          var q = new a([{ dn: l }]);
          var o2 = new g(r2);
          var m = new f({ array: [q, o2] });
          return m.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cms.IssuerSerial, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.SignerIdentifier = function(f) {
        var c = KJUR, i = c.asn1, h = i.DERInteger, g = i.DERSequence, l = i.cms, k = l.IssuerAndSerialNumber, d = l.SubjectKeyIdentifier, e2 = i.x509, a = e2.X500Name, b = X509, j = Error;
        l.SignerIdentifier.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var o2 = this.params;
          if (o2.type == "isssn") {
            var m = new k(o2);
            return m.tohex();
          } else {
            if (o2.type == "skid") {
              var n2 = new d(o2);
              return n2.tohex();
            } else {
              throw new Error("wrong property for isssn or skid");
            }
          }
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.cms.SignerIdentifier, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.IssuerAndSerialNumber = function(e2) {
        var c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.X500Name, b = X509, i = Error;
        j.IssuerAndSerialNumber.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var p = this.params;
          var l, r2;
          if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != void 0) {
            var n2;
            if (p.cert != void 0) {
              n2 = p.cert;
            } else {
              n2 = p;
            }
            var k = new b();
            k.readCertPEM(n2);
            l = k.getIssuer();
            r2 = { hex: k.getSerialNumberHex() };
          } else {
            if (p.issuer != void 0 && p.serial) {
              l = p.issuer;
              r2 = p.serial;
            } else {
              throw new i("cert or issuer and serial parameter not specified");
            }
          }
          var q = new a(l);
          var o2 = new g(r2);
          var m = new f({ array: [q, o2] });
          return m.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(k) {
          this.params = k;
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cms.IssuerAndSerialNumber, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.SubjectKeyIdentifier = function(g) {
        var d = KJUR, k = d.asn1, i = k.DERInteger, h = k.DERSequence, j = k.ASN1Util.newObject, m = k.cms, f = m.IssuerAndSerialName, c = m.SubjectKeyIdentifier, e2 = k.x509, a = e2.X500Name, b = X509, l = Error;
        m.SubjectKeyIdentifier.superclass.constructor.call(this);
        this.tohex = function() {
          var r2 = this.params;
          if (r2.cert == void 0 && r2.skid == void 0) {
            throw new l("property cert nor skid undefined");
          }
          var q;
          if (r2.cert != void 0) {
            var n2 = new b(r2.cert);
            var o2 = n2.getExtSubjectKeyIdentifier();
            q = o2.kid.hex;
          } else {
            if (r2.skid != void 0) {
              q = r2.skid;
            }
          }
          var p = j({ tag: { tage: "a0", obj: { octstr: { hex: q } } } });
          return p.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cms.SubjectKeyIdentifier, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.AttributeList = function(f) {
        var d = Error, c = KJUR, b = c.asn1, a = b.DERSet, e2 = b.cms;
        e2.AttributeList.superclass.constructor.call(this);
        this.params = null;
        this.hTLV = null;
        this.setByParam = function(g) {
          this.params = g;
        };
        this.tohex = function() {
          var o2 = this.params;
          if (this.hTLV != null) {
            return this.hTLV;
          }
          var m = true;
          if (o2.sortflag != void 0) {
            m = o2.sortflag;
          }
          var j = o2.array;
          var g = [];
          for (var l = 0; l < j.length; l++) {
            var n2 = j[l];
            var k = n2.attr;
            if (k == "contentType") {
              g.push(new e2.ContentType(n2));
            } else {
              if (k == "messageDigest") {
                g.push(new e2.MessageDigest(n2));
              } else {
                if (k == "signingTime") {
                  g.push(new e2.SigningTime(n2));
                } else {
                  if (k == "signingCertificate") {
                    g.push(new e2.SigningCertificate(n2));
                  } else {
                    if (k == "signingCertificateV2") {
                      g.push(new e2.SigningCertificateV2(n2));
                    } else {
                      if (k == "signaturePolicyIdentifier") {
                        g.push(new KJUR.asn1.cades.SignaturePolicyIdentifier(n2));
                      } else {
                        if (k == "signatureTimeStamp" || k == "timeStampToken") {
                          g.push(new KJUR.asn1.cades.SignatureTimeStamp(n2));
                        } else {
                          throw new d("unknown attr: " + k);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          var h = new a({ array: g, sortflag: m });
          this.hTLV = h.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.cms.AttributeList, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.SignerInfo = function(q) {
        var n2 = Error, r2 = KJUR, i = r2.asn1, c = i.DERInteger, f = i.DEROctetString, h = i.DERSequence, m = i.DERTaggedObject, k = i.cms, p = k.SignerIdentifier, l = k.AttributeList, g = k.ContentType, e2 = k.EncapsulatedContentInfo, d = k.MessageDigest, j = k.SignedData, a = i.x509, s = a.AlgorithmIdentifier, b = r2.crypto, o2 = KEYUTIL;
        k.SignerInfo.superclass.constructor.call(this);
        this.params = null;
        this.sign = function() {
          var y = this.params;
          var x = y.sigalg;
          var u = new l(y.sattrs).tohex();
          var v = o2.getKey(y.signkey);
          var w = new b.Signature({ alg: x });
          w.init(v);
          w.updateHex(u);
          var t3 = w.sign();
          y.sighex = t3;
        };
        this.tohex = function() {
          var w = this.params;
          var t3 = [];
          t3.push(new c({ "int": w.version }));
          t3.push(new p(w.id));
          t3.push(new s({ name: w.hashalg }));
          if (w.sattrs != void 0) {
            var x = new l(w.sattrs);
            try {
              t3.push(new m({ tag: "a0", explicit: false, obj: x }));
            } catch (v) {
              throw new n2("si sattr error: " + v);
            }
          }
          if (w.sigalgfield != void 0) {
            t3.push(new s({ name: w.sigalgfield }));
          } else {
            t3.push(new s({ name: w.sigalg }));
          }
          if (w.sighex == void 0 && w.signkey != void 0) {
            this.sign();
          }
          t3.push(new f({ hex: w.sighex }));
          if (w.uattrs != void 0) {
            var x = new l(w.uattrs);
            try {
              t3.push(new m({ tag: "a1", explicit: false, obj: x }));
            } catch (v) {
              throw new n2("si uattr error: " + v);
            }
          }
          var u = new h({ array: t3 });
          return u.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (q != void 0) {
          this.setByParam(q);
        }
      };
      extendClass(KJUR.asn1.cms.SignerInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.EncapsulatedContentInfo = function(g) {
        var c = KJUR, b = c.asn1, e2 = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, d = b.DEROctetString, f = b.cms;
        f.EncapsulatedContentInfo.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var m = this.params;
          var i = [];
          i.push(new h(m.type));
          if (m.content != void 0 && (m.content.hex != void 0 || m.content.str != void 0) && m.isDetached != true) {
            var k = new d(m.content);
            var l = new e2({ tag: "a0", explicit: true, obj: k });
            i.push(l);
          }
          var j = new a({ array: i });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(i) {
          this.params = i;
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cms.EncapsulatedContentInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.ContentInfo = function(g) {
        var c = KJUR, b = c.asn1, d = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, f = b.x509, e2 = f.OID.name2obj;
        KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var l = this.params;
          var i = [];
          i.push(new h(l.type));
          var k = new d({ tag: "a0", explicit: true, obj: l.obj });
          i.push(k);
          var j = new a({ array: i });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(i) {
          this.params = i;
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cms.ContentInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.SignedData = function(e2) {
        var j = Error, a = KJUR, h = a.asn1, m = h.ASN1Object, g = h.DERInteger, p = h.DERSet, f = h.DERSequence, b = h.DERTaggedObject, o2 = h.cms, l = o2.EncapsulatedContentInfo, d = o2.SignerInfo, q = o2.ContentInfo, k = o2.CertificateSet, i = o2.RevocationInfoChoices, c = h.x509, n2 = c.AlgorithmIdentifier;
        KJUR.asn1.cms.SignedData.superclass.constructor.call(this);
        this.params = null;
        this.checkAndFixParam = function() {
          var r2 = this.params;
          this._setDigestAlgs(r2);
          this._setContentTypeByEContent(r2);
          this._setMessageDigestByEContent(r2);
          this._setSignerInfoVersion(r2);
          this._setSignedDataVersion(r2);
        };
        this._setDigestAlgs = function(v) {
          var u = {};
          var t3 = v.sinfos;
          for (var r2 = 0; r2 < t3.length; r2++) {
            var s = t3[r2];
            u[s.hashalg] = 1;
          }
          v.hashalgs = Object.keys(u).sort();
        };
        this._setContentTypeByEContent = function(w) {
          var u = w.econtent.type;
          var v = w.sinfos;
          for (var r2 = 0; r2 < v.length; r2++) {
            var t3 = v[r2];
            var s = this._getAttrParamByName(t3, "contentType");
            s.type = u;
          }
        };
        this._setMessageDigestByEContent = function(r2) {
          var v = r2.econtent;
          var y = r2.econtent.type;
          var x = v.content.hex;
          if (x == void 0 && v.type == "data" && v.content.str != void 0) {
            x = rstrtohex(v.content.str);
          }
          var A = r2.sinfos;
          for (var u = 0; u < A.length; u++) {
            var t3 = A[u];
            var s = t3.hashalg;
            var z2 = this._getAttrParamByName(t3, "messageDigest");
            var w = KJUR.crypto.Util.hashHex(x, s);
            z2.hex = w;
          }
        };
        this._getAttrParamByName = function(t3, s) {
          var u = t3.sattrs.array;
          for (var r2 = 0; r2 < u.length; r2++) {
            if (u[r2].attr == s) {
              return u[r2];
            }
          }
        };
        this._setSignerInfoVersion = function(v) {
          var t3 = v.sinfos;
          for (var r2 = 0; r2 < t3.length; r2++) {
            var s = t3[r2];
            var u = 1;
            if (s.id.type == "skid") {
              u = 3;
            }
            s.version = u;
          }
        };
        this._setSignedDataVersion = function(s) {
          var r2 = this._getSignedDataVersion(s);
          s.version = r2;
        };
        this._getSignedDataVersion = function(w) {
          if (w.revinfos != void 0) {
            var r2 = w.revinfos;
            for (var t3 = 0; t3 < r2.length; t3++) {
              var s = r2[t3];
              if (s.ocsp != void 0) {
                return 5;
              }
            }
          }
          var v = w.sinfos;
          for (var t3 = 0; t3 < v.length; t3++) {
            var u = w.sinfos[t3];
            if (u.version == 3) {
              return 3;
            }
          }
          if (w.econtent.type != "data") {
            return 3;
          }
          return 1;
        };
        this.tohex = function() {
          var y = this.params;
          if (this.getEncodedHexPrepare != void 0) {
            this.getEncodedHexPrepare();
          }
          if (y.fixed != true) {
            this.checkAndFixParam();
          }
          var r2 = [];
          r2.push(new g({ "int": y.version }));
          var w = [];
          for (var v = 0; v < y.hashalgs.length; v++) {
            var t3 = y.hashalgs[v];
            w.push(new n2({ name: t3 }));
          }
          r2.push(new p({ array: w }));
          r2.push(new l(y.econtent));
          if (y.certs != void 0) {
            r2.push(new k(y.certs));
          }
          if (y.revinfos != void 0) {
            r2.push(new i(y.revinfos));
          }
          var u = [];
          for (var v = 0; v < y.sinfos.length; v++) {
            var x = y.sinfos[v];
            u.push(new d(x));
          }
          r2.push(new p({ array: u }));
          var s = new f({ array: r2 });
          return s.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.getContentInfo = function() {
          var r2 = new q({ type: "signed-data", obj: this });
          return r2;
        };
        this.getContentInfoEncodedHex = function() {
          return this.getContentInfo().tohex();
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cms.SignedData, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.CertificateSet = function(f) {
        KJUR.asn1.cms.CertificateSet.superclass.constructor.call(this);
        var c = Error, b = KJUR.asn1, e2 = b.DERTaggedObject, a = b.DERSet, d = b.ASN1Object;
        this.params = null;
        this.tohex = function() {
          var j = this.params;
          var p = [];
          var q;
          if (j instanceof Array) {
            q = j;
          } else {
            if (j.array != void 0) {
              q = j.array;
            } else {
              throw new c("cert array not specified");
            }
          }
          for (var k = 0; k < q.length; k++) {
            var l = q[k];
            var n2 = pemtohex(l);
            var g = new d();
            g.hTLV = n2;
            p.push(g);
          }
          var m = { array: p };
          if (j.sortflag == false) {
            m.sortflag = false;
          }
          var o2 = new a(m);
          var h = new e2({ tag: "a0", explicit: false, obj: o2 });
          return h.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.cms.CertificateSet, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.RevocationInfoChoices = function(a) {
        KJUR.asn1.cms.RevocationInfoChoices.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var e2 = this.params;
          if (!e2 instanceof Array) {
            throw new Error("params is not array");
          }
          var b = [];
          for (var c = 0; c < e2.length; c++) {
            b.push(new KJUR.asn1.cms.RevocationInfoChoice(e2[c]));
          }
          var d = KJUR.asn1.ASN1Util.newObject({ tag: { tagi: "a1", obj: { set: b } } });
          return d.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (a != void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.cms.RevocationInfoChoices, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.RevocationInfoChoice = function(a) {
        KJUR.asn1.cms.RevocationInfoChoice.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var d = this.params;
          if (d.crl != void 0 && typeof d.crl == "string") {
            var b = d.crl;
            if (d.crl.indexOf("-----BEGIN") != -1) {
              b = pemtohex(d.crl);
            }
            return b;
          } else {
            if (d.ocsp != void 0) {
              var c = KJUR.asn1.ASN1Util.newObject({ tag: { tagi: "a1", obj: new KJUR.asn1.cms.OtherRevocationFormat(d) } });
              return c.tohex();
            } else {
              throw new Error("property crl or ocsp undefined");
            }
          }
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (a != void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.cms.RevocationInfoChoice, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.OtherRevocationFormat = function(f) {
        KJUR.asn1.cms.OtherRevocationFormat.superclass.constructor.call(this);
        var d = Error, c = KJUR, b = c.asn1, a = b.ASN1Util.newObject, e2 = c.lang.String.isHex;
        this.params = null;
        this.tohex = function() {
          var h = this.params;
          if (h.ocsp == void 0) {
            throw new d("property ocsp not specified");
          }
          if (!e2(h.ocsp) || !ASN1HEX.isASN1HEX(h.ocsp)) {
            throw new d("ocsp value not ASN.1 hex string");
          }
          var g = a({ seq: [{ oid: "1.3.6.1.5.5.7.16.2" }, { asn1: { tlv: h.ocsp } }] });
          return g.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.cms.OtherRevocationFormat, KJUR.asn1.ASN1Object);
      KJUR.asn1.cms.CMSUtil = new function() {
      }();
      KJUR.asn1.cms.CMSUtil.newSignedData = function(a) {
        return new KJUR.asn1.cms.SignedData(a);
      };
      KJUR.asn1.cms.CMSUtil.verifySignedData = function(n2) {
        var C = KJUR, p = C.asn1, s = p.cms, D = s.SignerInfo, q = s.SignedData, y = s.SigningTime, b = s.SigningCertificate, d = s.SigningCertificateV2, A = p.cades, u = A.SignaturePolicyIdentifier, i = C.lang.String.isHex, v = ASN1HEX, h = v.getVbyList, a = v.getTLVbyList, t3 = v.getIdxbyList, z2 = v.getChildIdx, c = v.getTLV, B = v.oidname, j = C.crypto.Util.hashHex;
        if (n2.cms === void 0 && !i(n2.cms)) {
        }
        var E = n2.cms;
        var g = function(J, H) {
          var G;
          for (var I = 3; I < 6; I++) {
            G = t3(J, 0, [1, 0, I]);
            if (G !== void 0) {
              var F = J.substr(G, 2);
              if (F === "a0") {
                H.certsIdx = G;
              }
              if (F === "a1") {
                H.revinfosIdx = G;
              }
              if (F === "31") {
                H.signerinfosIdx = G;
              }
            }
          }
        };
        var l = function(I, F) {
          var H = F.signerinfosIdx;
          if (H === void 0) {
            return;
          }
          var L = z2(I, H);
          F.signerInfoIdxList = L;
          for (var G = 0; G < L.length; G++) {
            var K = L[G];
            var J = { idx: K };
            k(I, J);
            F.signerInfos.push(J);
          }
        };
        var k = function(I, J) {
          var F = J.idx;
          J.signerid_issuer1 = a(I, F, [1, 0], "30");
          J.signerid_serial1 = h(I, F, [1, 1], "02");
          J.hashalg = B(h(I, F, [2, 0], "06"));
          var H = t3(I, F, [3], "a0");
          J.idxSignedAttrs = H;
          f(I, J, H);
          var G = z2(I, F);
          var K = G.length;
          if (K < 6) {
            throw "malformed SignerInfo";
          }
          J.sigalg = B(h(I, F, [K - 2, 0], "06"));
          J.sigval = h(I, F, [K - 1], "04");
        };
        var f = function(L, M, F) {
          var J = z2(L, F);
          M.signedAttrIdxList = J;
          for (var K = 0; K < J.length; K++) {
            var I = J[K];
            var G = h(L, I, [0], "06");
            var H;
            if (G === "2a864886f70d010905") {
              H = hextoutf8(h(L, I, [1, 0]));
              M.saSigningTime = H;
            } else {
              if (G === "2a864886f70d010904") {
                H = h(L, I, [1, 0], "04");
                M.saMessageDigest = H;
              }
            }
          }
        };
        var w = function(G, F) {
          if (h(G, 0, [0], "06") !== "2a864886f70d010702") {
            return F;
          }
          F.cmsType = "signedData";
          F.econtent = h(G, 0, [1, 0, 2, 1, 0]);
          g(G, F);
          F.signerInfos = [];
          l(G, F);
        };
        var o2 = function(J, F) {
          var G = F.parse.signerInfos;
          var L = G.length;
          var K = true;
          for (var I = 0; I < L; I++) {
            var H = G[I];
            e2(J, F, H, I);
            if (!H.isValid) {
              K = false;
            }
          }
          F.isValid = K;
        };
        var x = function(F, Q, J, P) {
          var N = Q.parse.certsIdx;
          var H;
          if (Q.certs === void 0) {
            H = [];
            Q.certkeys = [];
            var K = z2(F, N);
            for (var I = 0; I < K.length; I++) {
              var M = c(F, K[I]);
              var O = new X509();
              O.readCertHex(M);
              H[I] = O;
              Q.certkeys[I] = O.getPublicKey();
            }
            Q.certs = H;
          } else {
            H = Q.certs;
          }
          Q.cccc = H.length;
          Q.cccci = K.length;
          for (var I = 0; I < H.length; I++) {
            var L = O.getIssuerHex();
            var G = O.getSerialNumberHex();
            if (J.signerid_issuer1 === L && J.signerid_serial1 === G) {
              J.certkey_idx = I;
            }
          }
        };
        var e2 = function(F, R, I, N) {
          I.verifyDetail = {};
          var Q = I.verifyDetail;
          var K = R.parse.econtent;
          var G = I.hashalg;
          var L = I.saMessageDigest;
          Q.validMessageDigest = false;
          if (j(K, G) === L) {
            Q.validMessageDigest = true;
          }
          x(F, R, I, N);
          Q.validSignatureValue = false;
          var H = I.sigalg;
          var M = "31" + c(F, I.idxSignedAttrs).substr(2);
          I.signedattrshex = M;
          var J = R.certs[I.certkey_idx].getPublicKey();
          var P = new KJUR.crypto.Signature({ alg: H });
          P.init(J);
          P.updateHex(M);
          var O = P.verify(I.sigval);
          Q.validSignatureValue_isValid = O;
          if (O === true) {
            Q.validSignatureValue = true;
          }
          I.isValid = false;
          if (Q.validMessageDigest && Q.validSignatureValue) {
            I.isValid = true;
          }
        };
        var m = function() {
        };
        var r2 = { isValid: false, parse: {} };
        w(E, r2.parse);
        o2(E, r2);
        return r2;
      };
      KJUR.asn1.cms.CMSParser = function() {
        var g = Error, a = X509, h = new a(), l = ASN1HEX, i = l.getV, b = l.getTLV, f = l.getIdxbyList, c = l.getTLVbyList, d = l.getTLVbyListEx, e2 = l.getVbyList, k = l.getVbyListEx, j = l.getChildIdx;
        this.getCMSSignedData = function(m) {
          var o2 = c(m, 0, [1, 0]);
          var n2 = this.getSignedData(o2);
          return n2;
        };
        this.getSignedData = function(o2) {
          var q = j(o2, 0);
          var v = {};
          var p = i(o2, q[0]);
          var n2 = parseInt(p, 16);
          v.version = n2;
          var r2 = b(o2, q[1]);
          v.hashalgs = this.getHashAlgArray(r2);
          var t3 = b(o2, q[2]);
          v.econtent = this.getEContent(t3);
          var m = d(o2, 0, ["[0]"]);
          if (m != null) {
            v.certs = this.getCertificateSet(m);
          }
          var u = d(o2, 0, ["[1]"]);
          if (u != null) {
          }
          var s = d(o2, 0, [3]);
          v.sinfos = this.getSignerInfos(s);
          return v;
        };
        this.getHashAlgArray = function(s) {
          var q = j(s, 0);
          var m = new a();
          var n2 = [];
          for (var r2 = 0; r2 < q.length; r2++) {
            var p = b(s, q[r2]);
            var o2 = m.getAlgorithmIdentifierName(p);
            n2.push(o2);
          }
          return n2;
        };
        this.getEContent = function(m) {
          var n2 = {};
          var p = e2(m, 0, [0]);
          var o2 = e2(m, 0, [1, 0]);
          n2.type = KJUR.asn1.x509.OID.oid2name(ASN1HEX.hextooidstr(p));
          n2.content = { hex: o2 };
          return n2;
        };
        this.getSignerInfos = function(p) {
          var r2 = [];
          var m = j(p, 0);
          for (var n2 = 0; n2 < m.length; n2++) {
            var o2 = b(p, m[n2]);
            var q = this.getSignerInfo(o2);
            r2.push(q);
          }
          return r2;
        };
        this.getSignerInfo = function(s) {
          var y = {};
          var u = j(s, 0);
          var q = l.getInt(s, u[0], -1);
          if (q != -1) {
            y.version = q;
          }
          var t3 = b(s, u[1]);
          var p = this.getIssuerAndSerialNumber(t3);
          y.id = p;
          var z2 = b(s, u[2]);
          var n2 = h.getAlgorithmIdentifierName(z2);
          y.hashalg = n2;
          var w = d(s, 0, ["[0]"]);
          if (w != null) {
            var A = this.getAttributeList(w);
            y.sattrs = A;
          }
          var m = d(s, 0, [3]);
          var x = h.getAlgorithmIdentifierName(m);
          y.sigalg = x;
          var o2 = k(s, 0, [4]);
          y.sighex = o2;
          var r2 = d(s, 0, ["[1]"]);
          if (r2 != null) {
            var v = this.getAttributeList(r2);
            y.uattrs = v;
          }
          return y;
        };
        this.getSignerIdentifier = function(m) {
          if (m.substr(0, 2) == "30") {
            return this.getIssuerAndSerialNumber(m);
          } else {
            throw new Error("SKID of signerIdentifier not supported");
          }
        };
        this.getIssuerAndSerialNumber = function(n2) {
          var o2 = { type: "isssn" };
          var m = j(n2, 0);
          var p = b(n2, m[0]);
          o2.issuer = h.getX500Name(p);
          var q = i(n2, m[1]);
          o2.serial = { hex: q };
          return o2;
        };
        this.getAttributeList = function(q) {
          var m = [];
          var n2 = j(q, 0);
          for (var o2 = 0; o2 < n2.length; o2++) {
            var p = b(q, n2[o2]);
            var r2 = this.getAttribute(p);
            m.push(r2);
          }
          return { array: m };
        };
        this.getAttribute = function(p) {
          var t3 = {};
          var q = j(p, 0);
          var o2 = l.getOID(p, q[0]);
          var m = KJUR.asn1.x509.OID.oid2name(o2);
          t3.attr = m;
          var r2 = b(p, q[1]);
          var u = j(r2, 0);
          if (u.length == 1) {
            t3.valhex = b(r2, u[0]);
          } else {
            var s = [];
            for (var n2 = 0; n2 < u.length; n2++) {
              s.push(b(r2, u[n2]));
            }
            t3.valhex = s;
          }
          if (m == "contentType") {
            this.setContentType(t3);
          } else {
            if (m == "messageDigest") {
              this.setMessageDigest(t3);
            } else {
              if (m == "signingTime") {
                this.setSigningTime(t3);
              } else {
                if (m == "signingCertificate") {
                  this.setSigningCertificate(t3);
                } else {
                  if (m == "signingCertificateV2") {
                    this.setSigningCertificateV2(t3);
                  } else {
                    if (m == "signaturePolicyIdentifier") {
                      this.setSignaturePolicyIdentifier(t3);
                    }
                  }
                }
              }
            }
          }
          return t3;
        };
        this.setContentType = function(m) {
          var n2 = l.getOIDName(m.valhex, 0, null);
          if (n2 != null) {
            m.type = n2;
            delete m.valhex;
          }
        };
        this.setSigningTime = function(o2) {
          var n2 = i(o2.valhex, 0);
          var m = hextoutf8(n2);
          o2.str = m;
          delete o2.valhex;
        };
        this.setMessageDigest = function(m) {
          var n2 = i(m.valhex, 0);
          m.hex = n2;
          delete m.valhex;
        };
        this.setSigningCertificate = function(n2) {
          var q = j(n2.valhex, 0);
          if (q.length > 0) {
            var m = b(n2.valhex, q[0]);
            var p = j(m, 0);
            var t3 = [];
            for (var o2 = 0; o2 < p.length; o2++) {
              var s = b(m, p[o2]);
              var u = this.getESSCertID(s);
              t3.push(u);
            }
            n2.array = t3;
          }
          if (q.length > 1) {
            var r2 = b(n2.valhex, q[1]);
            n2.polhex = r2;
          }
          delete n2.valhex;
        };
        this.setSignaturePolicyIdentifier = function(s) {
          var q = j(s.valhex, 0);
          if (q.length > 0) {
            var r2 = l.getOID(s.valhex, q[0]);
            s.oid = r2;
          }
          if (q.length > 1) {
            var m = new a();
            var t3 = j(s.valhex, q[1]);
            var p = b(s.valhex, t3[0]);
            var o2 = m.getAlgorithmIdentifierName(p);
            s.alg = o2;
            var n2 = i(s.valhex, t3[1]);
            s.hash = n2;
          }
          delete s.valhex;
        };
        this.setSigningCertificateV2 = function(o2) {
          var s = j(o2.valhex, 0);
          if (s.length > 0) {
            var n2 = b(o2.valhex, s[0]);
            var r2 = j(n2, 0);
            var u = [];
            for (var q = 0; q < r2.length; q++) {
              var m = b(n2, r2[q]);
              var p = this.getESSCertIDv2(m);
              u.push(p);
            }
            o2.array = u;
          }
          if (s.length > 1) {
            var t3 = b(o2.valhex, s[1]);
            o2.polhex = t3;
          }
          delete o2.valhex;
        };
        this.getESSCertID = function(o2) {
          var p = {};
          var n2 = j(o2, 0);
          if (n2.length > 0) {
            var q = i(o2, n2[0]);
            p.hash = q;
          }
          if (n2.length > 1) {
            var m = b(o2, n2[1]);
            var r2 = this.getIssuerSerial(m);
            if (r2.serial != void 0) {
              p.serial = r2.serial;
            }
            if (r2.issuer != void 0) {
              p.issuer = r2.issuer;
            }
          }
          return p;
        };
        this.getESSCertIDv2 = function(q) {
          var s = {};
          var p = j(q, 0);
          if (p.length < 1 || 3 < p.length) {
            throw new g("wrong number of elements");
          }
          var r2 = 0;
          if (q.substr(p[0], 2) == "30") {
            var o2 = b(q, p[0]);
            s.alg = h.getAlgorithmIdentifierName(o2);
            r2++;
          } else {
            s.alg = "sha256";
          }
          var n2 = i(q, p[r2]);
          s.hash = n2;
          if (p.length > r2 + 1) {
            var m = b(q, p[r2 + 1]);
            var t3 = this.getIssuerSerial(m);
            s.issuer = t3.issuer;
            s.serial = t3.serial;
          }
          return s;
        };
        this.getIssuerSerial = function(q) {
          var r2 = {};
          var n2 = j(q, 0);
          var m = b(q, n2[0]);
          var p = h.getGeneralNames(m);
          var o2 = p[0].dn;
          r2.issuer = o2;
          var s = i(q, n2[1]);
          r2.serial = { hex: s };
          return r2;
        };
        this.getCertificateSet = function(p) {
          var n2 = j(p, 0);
          var m = [];
          for (var o2 = 0; o2 < n2.length; o2++) {
            var r2 = b(p, n2[o2]);
            if (r2.substr(0, 2) == "30") {
              var q = hextopem(r2, "CERTIFICATE");
              m.push(q);
            }
          }
          return { array: m, sortflag: false };
        };
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      if (typeof KJUR.asn1.tsp == "undefined" || !KJUR.asn1.tsp) {
        KJUR.asn1.tsp = {};
      }
      KJUR.asn1.tsp.TimeStampToken = function(d) {
        var c = KJUR, b = c.asn1, a = b.tsp;
        a.TimeStampToken.superclass.constructor.call(this);
        this.params = null;
        this.getEncodedHexPrepare = function() {
          var e2 = new a.TSTInfo(this.params.econtent.content);
          this.params.econtent.content.hex = e2.tohex();
        };
        if (d != void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.tsp.TimeStampToken, KJUR.asn1.cms.SignedData);
      KJUR.asn1.tsp.TSTInfo = function(f) {
        var m = Error, c = KJUR, j = c.asn1, g = j.DERSequence, i = j.DERInteger, l = j.DERBoolean, h = j.DERGeneralizedTime, n2 = j.DERObjectIdentifier, e2 = j.DERTaggedObject, k = j.tsp, d = k.MessageImprint, b = k.Accuracy, a = j.x509.X500Name, o2 = j.x509.GeneralName;
        k.TSTInfo.superclass.constructor.call(this);
        this.dVersion = new i({ "int": 1 });
        this.dPolicy = null;
        this.dMessageImprint = null;
        this.dSerial = null;
        this.dGenTime = null;
        this.dAccuracy = null;
        this.dOrdering = null;
        this.dNonce = null;
        this.dTsa = null;
        this.tohex = function() {
          var p = [this.dVersion];
          if (this.dPolicy == null) {
            throw new Error("policy shall be specified.");
          }
          p.push(this.dPolicy);
          if (this.dMessageImprint == null) {
            throw new Error("messageImprint shall be specified.");
          }
          p.push(this.dMessageImprint);
          if (this.dSerial == null) {
            throw new Error("serialNumber shall be specified.");
          }
          p.push(this.dSerial);
          if (this.dGenTime == null) {
            throw new Error("genTime shall be specified.");
          }
          p.push(this.dGenTime);
          if (this.dAccuracy != null) {
            p.push(this.dAccuracy);
          }
          if (this.dOrdering != null) {
            p.push(this.dOrdering);
          }
          if (this.dNonce != null) {
            p.push(this.dNonce);
          }
          if (this.dTsa != null) {
            p.push(this.dTsa);
          }
          var q = new g({ array: p });
          this.hTLV = q.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          if (typeof f.policy == "string") {
            if (!f.policy.match(/^[0-9.]+$/)) {
              throw "policy shall be oid like 0.1.4.134";
            }
            this.dPolicy = new n2({ oid: f.policy });
          }
          if (f.messageImprint !== void 0) {
            this.dMessageImprint = new d(f.messageImprint);
          }
          if (f.serial !== void 0) {
            this.dSerial = new i(f.serial);
          }
          if (f.genTime !== void 0) {
            this.dGenTime = new h(f.genTime);
          }
          if (f.accuracy !== void 0) {
            this.dAccuracy = new b(f.accuracy);
          }
          if (f.ordering !== void 0 && f.ordering == true) {
            this.dOrdering = new l();
          }
          if (f.nonce !== void 0) {
            this.dNonce = new i(f.nonce);
          }
          if (f.tsa !== void 0) {
            this.dTsa = new e2({ tag: "a0", explicit: true, obj: new o2({ dn: f.tsa }) });
          }
        }
      };
      extendClass(KJUR.asn1.tsp.TSTInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.Accuracy = function(d) {
        var c = KJUR, b = c.asn1, a = b.ASN1Util.newObject;
        b.tsp.Accuracy.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var f = this.params;
          var e2 = [];
          if (f.seconds != void 0 && typeof f.seconds == "number") {
            e2.push({ "int": f.seconds });
          }
          if (f.millis != void 0 && typeof f.millis == "number") {
            e2.push({ tag: { tagi: "80", obj: { "int": f.millis } } });
          }
          if (f.micros != void 0 && typeof f.micros == "number") {
            e2.push({ tag: { tagi: "81", obj: { "int": f.micros } } });
          }
          return a({ seq: e2 }).tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d != void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.tsp.Accuracy, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.MessageImprint = function(g) {
        var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.DEROctetString, f = b.x509, e2 = f.AlgorithmIdentifier;
        b.tsp.MessageImprint.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var k = this.params;
          var j = new e2({ name: k.alg });
          var h = new d({ hex: k.hash });
          var i = new a({ array: [j, h] });
          return i.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g !== void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.tsp.MessageImprint, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.TimeStampReq = function(c) {
        var a = KJUR, f = a.asn1, d = f.DERSequence, e2 = f.DERInteger, h = f.DERBoolean, j = f.ASN1Object, i = f.DERObjectIdentifier, g = f.tsp, b = g.MessageImprint;
        g.TimeStampReq.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var m = this.params;
          var k = [];
          k.push(new e2({ "int": 1 }));
          if (m.messageImprint instanceof KJUR.asn1.ASN1Object) {
            k.push(m.messageImprint);
          } else {
            k.push(new b(m.messageImprint));
          }
          if (m.policy != void 0) {
            k.push(new i(m.policy));
          }
          if (m.nonce != void 0) {
            k.push(new e2(m.nonce));
          }
          if (m.certreq == true) {
            k.push(new h());
          }
          var l = new d({ array: k });
          return l.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (c != void 0) {
          this.setByParam(c);
        }
      };
      extendClass(KJUR.asn1.tsp.TimeStampReq, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.TimeStampResp = function(g) {
        var e2 = KJUR, d = e2.asn1, c = d.DERSequence, f = d.ASN1Object, a = d.tsp, b = a.PKIStatusInfo;
        a.TimeStampResp.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var j = this.params;
          var h = [];
          if (j.econtent != void 0 || j.tst != void 0) {
            if (j.statusinfo != void 0) {
              h.push(new b(j.statusinfo));
            } else {
              h.push(new b("granted"));
            }
            if (j.econtent != void 0) {
              h.push(new a.TimeStampToken(j).getContentInfo());
            } else {
              if (j.tst instanceof d.ASN1Object) {
                h.push(j.tst);
              } else {
                throw new Error("improper member tst value");
              }
            }
          } else {
            if (j.statusinfo != void 0) {
              h.push(new b(j.statusinfo));
            } else {
              throw new Error("parameter for token nor statusinfo not specified");
            }
          }
          var i = new c({ array: h });
          return i.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.tsp.TimeStampResp, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.PKIStatusInfo = function(d) {
        var h = Error, a = KJUR, g = a.asn1, e2 = g.DERSequence, i = g.tsp, f = i.PKIStatus, c = i.PKIFreeText, b = i.PKIFailureInfo;
        i.PKIStatusInfo.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var l = this.params;
          var j = [];
          if (typeof l == "string") {
            j.push(new f(l));
          } else {
            if (l.status == void 0) {
              throw new h("property 'status' unspecified");
            }
            j.push(new f(l.status));
            if (l.statusstr != void 0) {
              j.push(new c(l.statusstr));
            }
            if (l.failinfo != void 0) {
              j.push(new b(l.failinfo));
            }
          }
          var k = new e2({ array: j });
          return k.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d != void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.tsp.PKIStatusInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.PKIStatus = function(g) {
        var e2 = Error, d = KJUR, c = d.asn1, f = c.DERInteger, b = c.tsp;
        b.PKIStatus.superclass.constructor.call(this);
        var a = { granted: 0, grantedWithMods: 1, rejection: 2, waiting: 3, revocationWarning: 4, revocationNotification: 5 };
        this.params = null;
        this.tohex = function() {
          var k = this.params;
          var h, j;
          if (typeof k == "string") {
            try {
              j = a[k];
            } catch (i) {
              throw new e2("undefined name: " + k);
            }
          } else {
            if (typeof k == "number") {
              j = k;
            } else {
              throw new e2("unsupported params");
            }
          }
          return new f({ "int": j }).tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.tsp.PKIStatus, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.PKIFreeText = function(g) {
        var f = Error, e2 = KJUR, d = e2.asn1, b = d.DERSequence, c = d.DERUTF8String, a = d.tsp;
        a.PKIFreeText.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var l = this.params;
          if (!l instanceof Array) {
            throw new f("wrong params: not array");
          }
          var h = [];
          for (var k = 0; k < l.length; k++) {
            h.push(new c({ str: l[k] }));
          }
          var j = new b({ array: h });
          return j.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.tsp.PKIFreeText, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.PKIFailureInfo = function(h) {
        var f = Error, e2 = KJUR, d = e2.asn1, g = d.DERBitString, b = d.tsp, c = b.PKIFailureInfo;
        var a = { badAlg: 0, badRequest: 2, badDataFormat: 5, timeNotAvailable: 14, unacceptedPolicy: 15, unacceptedExtension: 16, addInfoNotAvailable: 17, systemFailure: 25 };
        c.superclass.constructor.call(this);
        this.params = null;
        this.getBinValue = function() {
          var n2 = this.params;
          var m = 0;
          if (typeof n2 == "number" && 0 <= n2 && n2 <= 25) {
            m |= 1 << n2;
            var k = m.toString(2);
            var l = "";
            for (var j = k.length - 1; j >= 0; j--) {
              l += k[j];
            }
            return l;
          } else {
            if (typeof n2 == "string" && a[n2] != void 0) {
              return namearraytobinstr([n2], a);
            } else {
              if (typeof n2 == "object" && n2.length != void 0) {
                return namearraytobinstr(n2, a);
              } else {
                throw new f("wrong params");
              }
            }
          }
          return;
        };
        this.tohex = function() {
          var j = this.params;
          var i = this.getBinValue();
          return new g({ bin: i }).tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (h != void 0) {
          this.setByParam(h);
        }
      };
      extendClass(KJUR.asn1.tsp.PKIFailureInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.tsp.AbstractTSAAdapter = function(a) {
        this.getTSTHex = function(c, b) {
          throw "not implemented yet";
        };
      };
      KJUR.asn1.tsp.SimpleTSAAdapter = function(e2) {
        var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
        a.SimpleTSAAdapter.superclass.constructor.call(this);
        this.params = null;
        this.serial = 0;
        this.getTSTHex = function(g, f) {
          var i = b(g, f);
          this.params.econtent.content.messageImprint = { alg: f, hash: i };
          this.params.econtent.content.serial = { "int": this.serial++ };
          var h = Math.floor(Math.random() * 1e9);
          this.params.econtent.content.nonce = { "int": h };
          var j = new a.TimeStampToken(this.params);
          return j.getContentInfoEncodedHex();
        };
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.tsp.SimpleTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
      KJUR.asn1.tsp.FixedTSAAdapter = function(e2) {
        var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
        a.FixedTSAAdapter.superclass.constructor.call(this);
        this.params = null;
        this.getTSTHex = function(g, f) {
          var h = b(g, f);
          this.params.econtent.content.messageImprint = { alg: f, hash: h };
          var i = new a.TimeStampToken(this.params);
          return i.getContentInfoEncodedHex();
        };
        if (e2 !== void 0) {
          this.params = e2;
        }
      };
      extendClass(KJUR.asn1.tsp.FixedTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
      KJUR.asn1.tsp.TSPUtil = new function() {
      }();
      KJUR.asn1.tsp.TSPUtil.newTimeStampToken = function(a) {
        return new KJUR.asn1.tsp.TimeStampToken(a);
      };
      KJUR.asn1.tsp.TSPUtil.parseTimeStampReq = function(a) {
        var b = new KJUR.asn1.tsp.TSPParser();
        return b.getTimeStampReq(a);
      };
      KJUR.asn1.tsp.TSPUtil.parseMessageImprint = function(a) {
        var b = new KJUR.asn1.tsp.TSPParser();
        return b.getMessageImprint(a);
      };
      KJUR.asn1.tsp.TSPParser = function() {
        var e2 = Error, a = X509, f = new a(), k = ASN1HEX, g = k.getV, b = k.getTLV, d = k.getIdxbyList, c = k.getTLVbyListEx, i = k.getChildIdx;
        var j = ["granted", "grantedWithMods", "rejection", "waiting", "revocationWarning", "revocationNotification"];
        var h = { 0: "badAlg", 2: "badRequest", 5: "badDataFormat", 14: "timeNotAvailable", 15: "unacceptedPolicy", 16: "unacceptedExtension", 17: "addInfoNotAvailable", 25: "systemFailure" };
        this.getResponse = function(n2) {
          var l = i(n2, 0);
          if (l.length == 1) {
            return this.getPKIStatusInfo(b(n2, l[0]));
          } else {
            if (l.length > 1) {
              var o2 = this.getPKIStatusInfo(b(n2, l[0]));
              var m = b(n2, l[1]);
              var p = this.getToken(m);
              p.statusinfo = o2;
              return p;
            }
          }
        };
        this.getToken = function(m) {
          var l = new KJUR.asn1.cms.CMSParser();
          var n2 = l.getCMSSignedData(m);
          this.setTSTInfo(n2);
          return n2;
        };
        this.setTSTInfo = function(l) {
          var o2 = l.econtent;
          if (o2.type == "tstinfo") {
            var n2 = o2.content.hex;
            var m = this.getTSTInfo(n2);
            o2.content = m;
          }
        };
        this.getTSTInfo = function(r2) {
          var x = {};
          var s = i(r2, 0);
          var p = g(r2, s[1]);
          x.policy = hextooid(p);
          var o2 = b(r2, s[2]);
          x.messageImprint = this.getMessageImprint(o2);
          var u = g(r2, s[3]);
          x.serial = { hex: u };
          var y = g(r2, s[4]);
          x.genTime = { str: hextoutf8(y) };
          var q = 0;
          if (s.length > 5 && r2.substr(s[5], 2) == "30") {
            var v = b(r2, s[5]);
            x.accuracy = this.getAccuracy(v);
            q++;
          }
          if (s.length > 5 + q && r2.substr(s[5 + q], 2) == "01") {
            var z2 = g(r2, s[5 + q]);
            if (z2 == "ff") {
              x.ordering = true;
            }
            q++;
          }
          if (s.length > 5 + q && r2.substr(s[5 + q], 2) == "02") {
            var n2 = g(r2, s[5 + q]);
            x.nonce = { hex: n2 };
            q++;
          }
          if (s.length > 5 + q && r2.substr(s[5 + q], 2) == "a0") {
            var m = b(r2, s[5 + q]);
            m = "30" + m.substr(2);
            pGeneralNames = f.getGeneralNames(m);
            var t3 = pGeneralNames[0].dn;
            x.tsa = t3;
            q++;
          }
          if (s.length > 5 + q && r2.substr(s[5 + q], 2) == "a1") {
            var l = b(r2, s[5 + q]);
            l = "30" + l.substr(2);
            var w = f.getExtParamArray(l);
            x.ext = w;
            q++;
          }
          return x;
        };
        this.getAccuracy = function(q) {
          var r2 = {};
          var o2 = i(q, 0);
          for (var p = 0; p < o2.length; p++) {
            var m = q.substr(o2[p], 2);
            var l = g(q, o2[p]);
            var n2 = parseInt(l, 16);
            if (m == "02") {
              r2.seconds = n2;
            } else {
              if (m == "80") {
                r2.millis = n2;
              } else {
                if (m == "81") {
                  r2.micros = n2;
                }
              }
            }
          }
          return r2;
        };
        this.getMessageImprint = function(n2) {
          if (n2.substr(0, 2) != "30") {
            throw new Error("head of messageImprint hex shall be x30");
          }
          var s = {};
          var l = i(n2, 0);
          var t3 = d(n2, 0, [0, 0]);
          var o2 = g(n2, t3);
          var p = k.hextooidstr(o2);
          var r2 = KJUR.asn1.x509.OID.oid2name(p);
          if (r2 == "") {
            throw new Error("hashAlg name undefined: " + p);
          }
          var m = r2;
          var q = d(n2, 0, [1]);
          s.alg = m;
          s.hash = g(n2, q);
          return s;
        };
        this.getPKIStatusInfo = function(o2) {
          var t3 = {};
          var r2 = i(o2, 0);
          var n2 = 0;
          try {
            var l = g(o2, r2[0]);
            var p = parseInt(l, 16);
            t3.status = j[p];
          } catch (s) {
          }
          if (r2.length > 1 && o2.substr(r2[1], 2) == "30") {
            var m = b(o2, r2[1]);
            t3.statusstr = this.getPKIFreeText(m);
            n2++;
          }
          if (r2.length > n2 && o2.substr(r2[1 + n2], 2) == "03") {
            var q = b(o2, r2[1 + n2]);
            t3.failinfo = this.getPKIFailureInfo(q);
          }
          return t3;
        };
        this.getPKIFreeText = function(n2) {
          var o2 = [];
          var l = i(n2, 0);
          for (var m = 0; m < l.length; m++) {
            o2.push(k.getString(n2, l[m]));
          }
          return o2;
        };
        this.getPKIFailureInfo = function(l) {
          var m = k.getInt(l, 0);
          if (h[m] != void 0) {
            return h[m];
          } else {
            return m;
          }
        };
        this.getTimeStampReq = function(q) {
          var p = {};
          p.certreq = false;
          var s = i(q, 0);
          if (s.length < 2) {
            throw new Error("TimeStampReq must have at least 2 items");
          }
          var n2 = b(q, s[1]);
          p.messageImprint = KJUR.asn1.tsp.TSPUtil.parseMessageImprint(n2);
          for (var o2 = 2; o2 < s.length; o2++) {
            var m = s[o2];
            var l = q.substr(m, 2);
            if (l == "06") {
              var r2 = g(q, m);
              p.policy = k.hextooidstr(r2);
            }
            if (l == "02") {
              p.nonce = g(q, m);
            }
            if (l == "01") {
              p.certreq = true;
            }
          }
          return p;
        };
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      if (typeof KJUR.asn1.cades == "undefined" || !KJUR.asn1.cades) {
        KJUR.asn1.cades = {};
      }
      KJUR.asn1.cades.SignaturePolicyIdentifier = function(e2) {
        var c = KJUR, b = c.asn1, a = b.cades, d = a.SignaturePolicyId;
        a.SignaturePolicyIdentifier.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.16.2.15";
        this.params = null;
        this.getValueArray = function() {
          return [new d(this.params)];
        };
        this.setByParam = function(f) {
          this.params = f;
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cades.SignaturePolicyIdentifier, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cades.SignaturePolicyId = function(e2) {
        var a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DERObjectIdentifier, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, h = c.SignaturePolicyId, b = c.OtherHashAlgAndValue;
        h.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var m = this.params;
          var k = [];
          k.push(new i(m.oid));
          k.push(new b(m));
          var l = new f({ array: k });
          return l.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(k) {
          this.params = k;
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cades.SignaturePolicyId, KJUR.asn1.ASN1Object);
      KJUR.asn1.cades.OtherHashAlgAndValue = function(e2) {
        var h = Error, a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DEROctetString, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, b = c.OtherHashAlgAndValue;
        b.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var o2 = this.params;
          if (o2.alg == void 0) {
            throw new h("property 'alg' not specified");
          }
          if (o2.hash == void 0 && o2.cert == void 0) {
            throw new h("property 'hash' nor 'cert' not specified");
          }
          var m = null;
          if (o2.hash != void 0) {
            m = o2.hash;
          } else {
            if (o2.cert != void 0) {
              if (typeof o2.cert != "string") {
                throw new h("cert not string");
              }
              var n2 = o2.cert;
              if (o2.cert.indexOf("-----BEGIN") != -1) {
                n2 = pemtohex(o2.cert);
              }
              m = KJUR.crypto.Util.hashHex(n2, o2.alg);
            }
          }
          var k = [];
          k.push(new j({ name: o2.alg }));
          k.push(new i({ hex: m }));
          var l = new f({ array: k });
          return l.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cades.OtherHashAlgAndValue, KJUR.asn1.ASN1Object);
      KJUR.asn1.cades.OtherHashValue = function(g) {
        KJUR.asn1.cades.OtherHashValue.superclass.constructor.call(this);
        var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e2 = b.DEROctetString, a = c.crypto.Util.hashHex;
        this.params = null;
        this.tohex = function() {
          var j = this.params;
          if (j.hash == void 0 && j.cert == void 0) {
            throw new d("hash or cert not specified");
          }
          var h = null;
          if (j.hash != void 0) {
            h = j.hash;
          } else {
            if (j.cert != void 0) {
              if (typeof j.cert != "string") {
                throw new d("cert not string");
              }
              var i = j.cert;
              if (j.cert.indexOf("-----BEGIN") != -1) {
                i = pemtohex(j.cert);
              }
              h = KJUR.crypto.Util.hashHex(i, "sha1");
            }
          }
          return new e2({ hex: h }).tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cades.OtherHashValue, KJUR.asn1.ASN1Object);
      KJUR.asn1.cades.SignatureTimeStamp = function(h) {
        var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e2 = b.ASN1Object, g = b.x509, a = b.cades;
        a.SignatureTimeStamp.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.16.2.14";
        this.params = null;
        this.getValueArray = function() {
          var l = this.params;
          if (l.tst != void 0) {
            if (f(l.tst)) {
              var j = new e2();
              j.hTLV = l.tst;
              return [j];
            } else {
              if (l.tst instanceof e2) {
                return [l.tst];
              } else {
                throw new d("params.tst has wrong value");
              }
            }
          } else {
            if (l.res != void 0) {
              var k = l.res;
              if (k instanceof e2) {
                k = k.tohex();
              }
              if (typeof k != "string" || !f(k)) {
                throw new d("params.res has wrong value");
              }
              var i = ASN1HEX.getTLVbyList(k, 0, [1]);
              var j = new e2();
              j.hTLV = l.tst;
              return [j];
            }
          }
        };
        if (h != null) {
          this.setByParam(h);
        }
      };
      extendClass(KJUR.asn1.cades.SignatureTimeStamp, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cades.CompleteCertificateRefs = function(h) {
        var f = Error, e2 = KJUR, d = e2.asn1, b = d.DERSequence, c = d.cades, a = c.OtherCertID, g = e2.lang.String.isHex;
        c.CompleteCertificateRefs.superclass.constructor.call(this);
        this.typeOid = "1.2.840.113549.1.9.16.2.21";
        this.params = null;
        this.getValueArray = function() {
          var o2 = this.params;
          var k = [];
          for (var m = 0; m < o2.array.length; m++) {
            var n2 = o2.array[m];
            if (typeof n2 == "string") {
              if (n2.indexOf("-----BEGIN") != -1) {
                n2 = { cert: n2 };
              } else {
                if (g(n2)) {
                  n2 = { hash: n2 };
                } else {
                  throw new f("unsupported value: " + n2);
                }
              }
            }
            if (o2.alg != void 0 && n2.alg == void 0) {
              n2.alg = o2.alg;
            }
            if (o2.hasis != void 0 && n2.hasis == void 0) {
              n2.hasis = o2.hasis;
            }
            var j = new a(n2);
            k.push(j);
          }
          var l = new b({ array: k });
          return [l];
        };
        if (h != void 0) {
          this.setByParam(h);
        }
      };
      extendClass(KJUR.asn1.cades.CompleteCertificateRefs, KJUR.asn1.cms.Attribute);
      KJUR.asn1.cades.OtherCertID = function(e2) {
        var a = KJUR, h = a.asn1, f = h.DERSequence, i = h.cms, g = i.IssuerSerial, c = h.cades, d = c.OtherHashValue, b = c.OtherHashAlgAndValue;
        c.OtherCertID.superclass.constructor.call(this);
        this.params = e2;
        this.tohex = function() {
          var n2 = this.params;
          if (typeof n2 == "string") {
            if (n2.indexOf("-----BEGIN") != -1) {
              n2 = { cert: n2 };
            } else {
              if (_isHex(n2)) {
                n2 = { hash: n2 };
              }
            }
          }
          var j = [];
          var m = null;
          if (n2.alg != void 0) {
            m = new b(n2);
          } else {
            m = new d(n2);
          }
          j.push(m);
          if (n2.cert != void 0 && n2.hasis == true || n2.issuer != void 0 && n2.serial != void 0) {
            var l = new g(n2);
            j.push(l);
          }
          var k = new f({ array: j });
          return k.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 != void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.cades.OtherCertID, KJUR.asn1.ASN1Object);
      KJUR.asn1.cades.OtherHash = function(g) {
        var i = Error, a = KJUR, h = a.asn1, j = h.cms, c = h.cades, b = c.OtherHashAlgAndValue, e2 = c.OtherHashValue, d = a.crypto.Util.hashHex, f = a.lang.String.isHex;
        c.OtherHash.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var l = this.params;
          if (typeof l == "string") {
            if (l.indexOf("-----BEGIN") != -1) {
              l = { cert: l };
            } else {
              if (f(l)) {
                l = { hash: l };
              }
            }
          }
          var k = null;
          if (l.alg != void 0) {
            k = new b(l);
          } else {
            k = new e2(l);
          }
          return k.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g != void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.cades.OtherHash, KJUR.asn1.ASN1Object);
      KJUR.asn1.cades.CAdESUtil = new function() {
      }();
      KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function(a) {
        var c = new KJUR.asn1.cms.CMSParser();
        var b = c.getCMSSignedData(a);
        return b;
      };
      KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function(g, q, c) {
        var p = ASN1HEX, s = p.getChildIdx, a = p.getTLV, l = p.getV, v = KJUR, h = v.asn1, n2 = h.ASN1Object, j = h.cms, k = j.AttributeList, w = j.SignerInfo;
        var o2 = {};
        var t3 = s(g, q);
        if (t3.length != 6) {
          throw "not supported items for SignerInfo (!=6)";
        }
        var d = t3.shift();
        o2.version = a(g, d);
        var e2 = t3.shift();
        o2.si = a(g, e2);
        var m = t3.shift();
        o2.digalg = a(g, m);
        var f = t3.shift();
        o2.sattrs = a(g, f);
        var i = t3.shift();
        o2.sigalg = a(g, i);
        var b = t3.shift();
        o2.sig = a(g, b);
        o2.sigval = l(g, b);
        var u = null;
        o2.obj = new w();
        u = new n2();
        u.hTLV = o2.version;
        o2.obj.dCMSVersion = u;
        u = new n2();
        u.hTLV = o2.si;
        o2.obj.dSignerIdentifier = u;
        u = new n2();
        u.hTLV = o2.digalg;
        o2.obj.dDigestAlgorithm = u;
        u = new n2();
        u.hTLV = o2.sattrs;
        o2.obj.dSignedAttrs = u;
        u = new n2();
        u.hTLV = o2.sigalg;
        o2.obj.dSigAlg = u;
        u = new n2();
        u.hTLV = o2.sig;
        o2.obj.dSig = u;
        o2.obj.dUnsignedAttrs = new k();
        return o2;
      };
      if (typeof KJUR.asn1.csr == "undefined" || !KJUR.asn1.csr) {
        KJUR.asn1.csr = {};
      }
      KJUR.asn1.csr.CertificationRequest = function(g) {
        var d = KJUR, c = d.asn1, e2 = c.DERBitString, b = c.DERSequence, a = c.csr, f = c.x509, h = a.CertificationRequestInfo;
        a.CertificationRequest.superclass.constructor.call(this);
        this.setByParam = function(i) {
          this.params = i;
        };
        this.sign = function() {
          var j = new h(this.params).tohex();
          var k = new KJUR.crypto.Signature({ alg: this.params.sigalg });
          k.init(this.params.sbjprvkey);
          k.updateHex(j);
          var i = k.sign();
          this.params.sighex = i;
        };
        this.getPEM = function() {
          return hextopem(this.tohex(), "CERTIFICATE REQUEST");
        };
        this.tohex = function() {
          var l = this.params;
          var j = new KJUR.asn1.csr.CertificationRequestInfo(this.params);
          var m = new KJUR.asn1.x509.AlgorithmIdentifier({ name: l.sigalg });
          if (l.sighex == void 0 && l.sbjprvkey != void 0) {
            this.sign();
          }
          if (l.sighex == void 0) {
            throw new Error("sighex or sbjprvkey parameter not defined");
          }
          var k = new e2({ hex: "00" + l.sighex });
          var i = new b({ array: [j, m, k] });
          return i.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (g !== void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.csr.CertificationRequest, KJUR.asn1.ASN1Object);
      KJUR.asn1.csr.CertificationRequestInfo = function(f) {
        var b = KJUR, j = b.asn1, c = j.DERBitString, g = j.DERSequence, i = j.DERInteger, p = j.DERUTF8String, d = j.DERTaggedObject, h = j.ASN1Util.newObject, n2 = j.csr, e2 = j.x509, a = e2.X500Name, l = e2.Extensions, o2 = e2.SubjectPublicKeyInfo, k = n2.AttributeList;
        n2.CertificationRequestInfo.superclass.constructor.call(this);
        this.params = null;
        this.setByParam = function(q) {
          if (q != void 0) {
            this.params = q;
          }
        };
        this.tohex = function() {
          var v = this.params;
          var r2 = [];
          r2.push(new i({ "int": 0 }));
          r2.push(new a(v.subject));
          r2.push(new o2(KEYUTIL.getKey(v.sbjpubkey)));
          if (v.attrs != void 0) {
            var u = m(v.attrs);
            var t3 = h({ tag: { tage: "a0", obj: u } });
            r2.push(t3);
          } else {
            if (v.extreq != void 0) {
              var q = new l(v.extreq);
              var t3 = h({ tag: { tage: "a0", obj: { seq: [{ oid: "1.2.840.113549.1.9.14" }, { set: [q] }] } } });
              r2.push(t3);
            } else {
              r2.push(new d({ tag: "a0", explicit: false, obj: new p({ str: "" }) }));
            }
          }
          var s = new g({ array: r2 });
          return s.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        function m(s) {
          var w = Error, v = KJUR.asn1.x509.Extensions;
          var y = [];
          for (var u = 0; u < s.length; u++) {
            var r2 = s[u];
            var x = r2.attr;
            if (x == "extensionRequest") {
              var t3 = new v(r2.ext);
              var q = { seq: [{ oid: "1.2.840.113549.1.9.14" }, { set: [t3] }] };
              y.push(q);
            } else {
              if (x == "unstructuredName") {
                var q = { seq: [{ oid: "1.2.840.113549.1.9.2" }, { set: r2.names }] };
                y.push(q);
              } else {
                if (x == "challengePassword") {
                  var q = { seq: [{ oid: "1.2.840.113549.1.9.7" }, { set: [{ utf8str: r2.password }] }] };
                  y.push(q);
                } else {
                  throw new w("unknown CSR attribute");
                }
              }
            }
          }
          return { set: y };
        }
        if (f != void 0) {
          this.setByParam(f);
        }
      };
      extendClass(KJUR.asn1.csr.CertificationRequestInfo, KJUR.asn1.ASN1Object);
      KJUR.asn1.csr.AttributeList = function(b) {
        function a(c) {
        }
      };
      extendClass(KJUR.asn1.csr.AttributeList, KJUR.asn1.ASN1Object);
      KJUR.asn1.csr.CSRUtil = new function() {
      }();
      KJUR.asn1.csr.CSRUtil.newCSRPEM = function(e2) {
        var b = KEYUTIL, a = KJUR.asn1.csr;
        var c = new a.CertificationRequest(e2);
        var d = c.getPEM();
        return d;
      };
      KJUR.asn1.csr.CSRUtil.getParam = function(d, a) {
        var m = ASN1HEX, i = m.getV, j = m.getIdxbyList, b = m.getTLVbyList, o2 = m.getTLVbyListEx, n2 = m.getVbyListEx;
        var l = function(u) {
          var t3 = j(u, 0, [0, 3, 0, 0], "06");
          if (i(u, t3) != "2a864886f70d01090e") {
            return null;
          }
          return b(u, 0, [0, 3, 0, 1, 0], "30");
        };
        var g = {};
        if (d.indexOf("-----BEGIN CERTIFICATE REQUEST") == -1) {
          throw new Error("argument is not PEM file");
        }
        var e2 = pemtohex(d, "CERTIFICATE REQUEST");
        if (a) {
          g.tbs = b(e2, 0, [0]);
        }
        try {
          var p = o2(e2, 0, [0, 1]);
          if (p == "3000") {
            g.subject = {};
          } else {
            var f = new X509();
            g.subject = f.getX500Name(p);
          }
        } catch (q) {
        }
        var k = o2(e2, 0, [0, 2]);
        var r2 = KEYUTIL.getKey(k, null, "pkcs8pub");
        g.sbjpubkey = KEYUTIL.getPEM(r2, "PKCS8PUB");
        var c = l(e2);
        var f = new X509();
        if (c != null) {
          g.extreq = f.getExtParamArray(c);
        }
        try {
          var h = o2(e2, 0, [1], "30");
          var f = new X509();
          g.sigalg = f.getAlgorithmIdentifierName(h);
        } catch (q) {
        }
        try {
          var s = n2(e2, 0, [2]);
          g.sighex = s;
        } catch (q) {
        }
        return g;
      };
      KJUR.asn1.csr.CSRUtil.verifySignature = function(b) {
        try {
          var c = null;
          if (typeof b == "string" && b.indexOf("-----BEGIN CERTIFICATE REQUEST") != -1) {
            c = KJUR.asn1.csr.CSRUtil.getParam(b, true);
          } else {
            if (typeof b == "object" && b.sbjpubkey != void 0 && b.sigalg != void 0 && b.sighex != void 0 && b.tbs != void 0) {
              c = b;
            }
          }
          if (c == null) {
            return false;
          }
          var d = new KJUR.crypto.Signature({ alg: c.sigalg });
          d.init(c.sbjpubkey);
          d.updateHex(c.tbs);
          return d.verify(c.sighex);
        } catch (a) {
          alert(a);
          return false;
        }
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
        KJUR.asn1 = {};
      }
      if (typeof KJUR.asn1.ocsp == "undefined" || !KJUR.asn1.ocsp) {
        KJUR.asn1.ocsp = {};
      }
      KJUR.asn1.ocsp.DEFAULT_HASH = "sha1";
      KJUR.asn1.ocsp.OCSPResponse = function(e2) {
        KJUR.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);
        var a = KJUR.asn1.DEREnumerated, b = KJUR.asn1.ASN1Util.newObject, c = KJUR.asn1.ocsp.ResponseBytes;
        var d = ["successful", "malformedRequest", "internalError", "tryLater", "_not_used_", "sigRequired", "unauthorized"];
        this.params = null;
        this._getStatusCode = function() {
          var f = this.params.resstatus;
          if (typeof f == "number") {
            return f;
          }
          if (typeof f != "string") {
            return -1;
          }
          return d.indexOf(f);
        };
        this.setByParam = function(f) {
          this.params = f;
        };
        this.tohex = function() {
          var h = this.params;
          var g = this._getStatusCode();
          if (g == -1) {
            throw new Error("responseStatus not supported: " + h.resstatus);
          }
          if (g != 0) {
            return b({ seq: [{ "enum": { "int": g } }] }).tohex();
          }
          var f = new c(h);
          return b({ seq: [{ "enum": { "int": 0 } }, { tag: { tag: "a0", explicit: true, obj: f } }] }).tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.ocsp.OCSPResponse, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.ResponseBytes = function(e2) {
        KJUR.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);
        var b = KJUR.asn1, a = b.DERSequence, f = b.DERObjectIdentifier, c = b.DEROctetString, d = b.ocsp.BasicOCSPResponse;
        this.params = null;
        this.setByParam = function(g) {
          this.params = g;
        };
        this.tohex = function() {
          var j = this.params;
          if (j.restype != "ocspBasic") {
            throw new Error("not supported responseType: " + j.restype);
          }
          var i = new d(j);
          var g = [];
          g.push(new f({ name: "ocspBasic" }));
          g.push(new c({ hex: i.tohex() }));
          var h = new a({ array: g });
          return h.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.ocsp.ResponseBytes, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.BasicOCSPResponse = function(d) {
        KJUR.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);
        var i = Error, g = KJUR.asn1, j = g.ASN1Object, e2 = g.DERSequence, f = g.DERGeneralizedTime, c = g.DERTaggedObject, b = g.DERBitString, h = g.x509.Extensions, k = g.x509.AlgorithmIdentifier, l = g.ocsp, a = l.ResponderID;
        _SingleResponseList = l.SingleResponseList, _ResponseData = l.ResponseData;
        this.params = null;
        this.setByParam = function(m) {
          this.params = m;
        };
        this.sign = function() {
          var o2 = this.params;
          var m = o2.tbsresp.tohex();
          var n2 = new KJUR.crypto.Signature({ alg: o2.sigalg });
          n2.init(o2.reskey);
          n2.updateHex(m);
          o2.sighex = n2.sign();
        };
        this.tohex = function() {
          var t3 = this.params;
          if (t3.tbsresp == void 0) {
            t3.tbsresp = new _ResponseData(t3);
          }
          if (t3.sighex == void 0 && t3.reskey != void 0) {
            this.sign();
          }
          var n2 = [];
          n2.push(t3.tbsresp);
          n2.push(new k({ name: t3.sigalg }));
          n2.push(new b({ hex: "00" + t3.sighex }));
          if (t3.certs != void 0 && t3.certs.length != void 0) {
            var m = [];
            for (var q = 0; q < t3.certs.length; q++) {
              var s = t3.certs[q];
              var r2 = null;
              if (ASN1HEX.isASN1HEX(s)) {
                r2 = s;
              } else {
                if (s.match(/-----BEGIN/)) {
                  r2 = pemtohex(s);
                } else {
                  throw new i("certs[" + q + "] not hex or PEM");
                }
              }
              m.push(new j({ tlv: r2 }));
            }
            var p = new e2({ array: m });
            n2.push(new c({ tag: "a0", explicit: true, obj: p }));
          }
          var o2 = new e2({ array: n2 });
          return o2.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (d !== void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.ocsp.BasicOCSPResponse, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.ResponseData = function(c) {
        KJUR.asn1.ocsp.ResponseData.superclass.constructor.call(this);
        var h = Error, f = KJUR.asn1, d = f.DERSequence, e2 = f.DERGeneralizedTime, b = f.DERTaggedObject, g = f.x509.Extensions, i = f.ocsp, a = i.ResponderID;
        _SingleResponseList = i.SingleResponseList;
        this.params = null;
        this.tohex = function() {
          var m = this.params;
          if (m.respid != void 0) {
            new h("respid not specified");
          }
          if (m.prodat != void 0) {
            new h("prodat not specified");
          }
          if (m.array != void 0) {
            new h("array not specified");
          }
          var j = [];
          j.push(new a(m.respid));
          j.push(new e2(m.prodat));
          j.push(new _SingleResponseList(m.array));
          if (m.ext != void 0) {
            var l = new g(m.ext);
            j.push(new b({ tag: "a1", explicit: true, obj: l }));
          }
          var k = new d({ array: j });
          return k.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(j) {
          this.params = j;
        };
        if (c !== void 0) {
          this.setByParam(c);
        }
      };
      extendClass(KJUR.asn1.ocsp.ResponseData, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.ResponderID = function(g) {
        KJUR.asn1.ocsp.ResponderID.superclass.constructor.call(this);
        var d = KJUR, c = d.asn1, b = c.ASN1Util.newObject, f = c.x509.X500Name, e2 = d.lang.String.isHex, a = Error;
        this.params = null;
        this.tohex = function() {
          var m = this.params;
          if (m.key != void 0) {
            var l = null;
            if (typeof m.key == "string") {
              if (e2(m.key)) {
                l = m.key;
              }
              if (m.key.match(/-----BEGIN CERTIFICATE/)) {
                var h = new X509(m.key);
                var k = h.getExtSubjectKeyIdentifier();
                if (k != null) {
                  l = k.kid.hex;
                }
              }
            } else {
              if (m.key instanceof X509) {
                var k = m.key.getExtSubjectKeyIdentifier();
                if (k != null) {
                  l = k.kid.hex;
                }
              }
            }
            if (l == null) {
              throw new a("wrong key member value");
            }
            var j = b({ tag: { tag: "a2", explicit: true, obj: { octstr: { hex: l } } } });
            return j.tohex();
          } else {
            if (m.name != void 0) {
              var i = null;
              if (typeof m.name == "string" && m.name.match(/-----BEGIN CERTIFICATE/)) {
                var h = new X509(m.name);
                i = h.getSubject();
              } else {
                if (m.name instanceof X509) {
                  i = m.name.getSubject();
                } else {
                  if (typeof m.name == "object" && (m.name.array != void 0 || m.name.str != void 0)) {
                    i = m.name;
                  }
                }
              }
              if (i == null) {
                throw new a("wrong name member value");
              }
              var j = b({ tag: { tag: "a1", explicit: true, obj: new f(i) } });
              return j.tohex();
            }
          }
          throw new a("key or name not specified");
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(h) {
          this.params = h;
        };
        if (g !== void 0) {
          this.setByParam(g);
        }
      };
      extendClass(KJUR.asn1.ocsp.ResponderID, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.SingleResponseList = function(d) {
        KJUR.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);
        var c = KJUR.asn1, b = c.DERSequence, a = c.ocsp.SingleResponse;
        this.params = null;
        this.tohex = function() {
          var h = this.params;
          if (typeof h != "object" || h.length == void 0) {
            throw new Error("params not specified properly");
          }
          var e2 = [];
          for (var g = 0; g < h.length; g++) {
            e2.push(new a(h[g]));
          }
          var f = new b({ array: e2 });
          return f.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(e2) {
          this.params = e2;
        };
        if (d !== void 0) {
          this.setByParam(d);
        }
      };
      extendClass(KJUR.asn1.ocsp.SingleResponseList, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.SingleResponse = function(e2) {
        var k = Error, a = KJUR, i = a.asn1, f = i.DERSequence, g = i.DERGeneralizedTime, b = i.DERTaggedObject, l = i.ocsp, h = l.CertID, c = l.CertStatus, d = i.x509, j = d.Extensions;
        l.SingleResponse.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var q = this.params;
          var n2 = [];
          if (q.certid == void 0) {
            throw new k("certid unspecified");
          }
          if (q.status == void 0) {
            throw new k("status unspecified");
          }
          if (q.thisupdate == void 0) {
            throw new k("thisupdate unspecified");
          }
          n2.push(new h(q.certid));
          n2.push(new c(q.status));
          n2.push(new g(q.thisupdate));
          if (q.nextupdate != void 0) {
            var m = new g(q.nextupdate);
            n2.push(new b({ tag: "a0", explicit: true, obj: m }));
          }
          if (q.ext != void 0) {
            var p = new j(q.ext);
            n2.push(new b({ tag: "a1", explicit: true, obj: p }));
          }
          var o2 = new f({ array: n2 });
          return o2.tohex();
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(m) {
          this.params = m;
        };
        if (e2 !== void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.ocsp.SingleResponse, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.CertID = function(e2) {
        var b = KJUR, i = b.asn1, l = i.DEROctetString, h = i.DERInteger, f = i.DERSequence, d = i.x509, m = d.AlgorithmIdentifier, n2 = i.ocsp, k = n2.DEFAULT_HASH, g = b.crypto, c = g.Util.hashHex, a = X509, o2 = ASN1HEX, j = o2.getVbyList;
        n2.CertID.superclass.constructor.call(this);
        this.DEFAULT_HASH = "sha1";
        this.params = null;
        this.setByValue = function(s, r2, p, q) {
          if (q == void 0) {
            q = this.DEFAULT_HASH;
          }
          this.params = { alg: q, issname: s, isskey: r2, sbjsn: p };
        };
        this.setByCert = function(p, q, r2) {
          if (r2 == void 0) {
            r2 = this.DEFAULT_HASH;
          }
          this.params = { alg: r2, issuerCert: p, subjectCert: q };
        };
        this.getParamByCerts = function(y, x, t3) {
          if (t3 == void 0) {
            t3 = this.DEFAULT_HASH;
          }
          var q = new a(y);
          var v = new a(x);
          var s = c(q.getSubjectHex(), t3);
          var u = q.getPublicKeyHex();
          var p = c(j(u, 0, [1], "03", true), t3);
          var w = v.getSerialNumberHex();
          var r2 = { alg: t3, issname: s, isskey: p, sbjsn: w };
          return r2;
        };
        this.tohex = function() {
          if (typeof this.params != "object") {
            throw new Error("params not set");
          }
          var s = this.params;
          var u, r2, y, q;
          if (s.alg == void 0) {
            q = this.DEFAULT_HASH;
          } else {
            q = s.alg;
          }
          if (s.issuerCert != void 0 && s.subjectCert != void 0) {
            var t3 = this.getParamByCerts(s.issuerCert, s.subjectCert, q);
            u = t3.issname;
            r2 = t3.isskey;
            y = t3.sbjsn;
          } else {
            if (s.issname != void 0 && s.isskey != void 0 && s.sbjsn != void 0) {
              u = s.issname;
              r2 = s.isskey;
              y = s.sbjsn;
            } else {
              throw new Error("required param members not defined");
            }
          }
          var A = new m({ name: q });
          var v = new l({ hex: u });
          var x = new l({ hex: r2 });
          var w = new h({ hex: y });
          var z2 = new f({ array: [A, v, x, w] });
          this.hTLV = z2.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          this.setByParam(e2);
        }
      };
      extendClass(KJUR.asn1.ocsp.CertID, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.CertStatus = function(a) {
        KJUR.asn1.ocsp.CertStatus.superclass.constructor.call(this);
        this.params = null;
        this.tohex = function() {
          var d = this.params;
          if (d.status == "good") {
            return "8000";
          }
          if (d.status == "unknown") {
            return "8200";
          }
          if (d.status == "revoked") {
            var c = [{ gentime: { str: d.time } }];
            if (d.reason != void 0) {
              c.push({ tag: { tag: "a0", explicit: true, obj: { "enum": { "int": d.reason } } } });
            }
            var b = { tag: "a1", explicit: false, obj: { seq: c } };
            return KJUR.asn1.ASN1Util.newObject({ tag: b }).tohex();
          }
          throw new Error("bad status");
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        this.setByParam = function(b) {
          this.params = b;
        };
        if (a !== void 0) {
          this.setByParam(a);
        }
      };
      extendClass(KJUR.asn1.ocsp.CertStatus, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.Request = function(f) {
        var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
        d.Request.superclass.constructor.call(this);
        this.dReqCert = null;
        this.dExt = null;
        this.tohex = function() {
          var g = [];
          if (this.dReqCert === null) {
            throw "reqCert not set";
          }
          g.push(this.dReqCert);
          var h = new a({ array: g });
          this.hTLV = h.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (typeof f !== "undefined") {
          var e2 = new d.CertID(f);
          this.dReqCert = e2;
        }
      };
      extendClass(KJUR.asn1.ocsp.Request, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.TBSRequest = function(e2) {
        var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
        d.TBSRequest.superclass.constructor.call(this);
        this.version = 0;
        this.dRequestorName = null;
        this.dRequestList = [];
        this.dRequestExt = null;
        this.setRequestListByParam = function(h) {
          var f = [];
          for (var g = 0; g < h.length; g++) {
            var j = new d.Request(h[0]);
            f.push(j);
          }
          this.dRequestList = f;
        };
        this.tohex = function() {
          var f = [];
          if (this.version !== 0) {
            throw "not supported version: " + this.version;
          }
          if (this.dRequestorName !== null) {
            throw "requestorName not supported";
          }
          var h = new a({ array: this.dRequestList });
          f.push(h);
          if (this.dRequestExt !== null) {
            throw "requestExtensions not supported";
          }
          var g = new a({ array: f });
          this.hTLV = g.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (e2 !== void 0) {
          if (e2.reqList !== void 0) {
            this.setRequestListByParam(e2.reqList);
          }
        }
      };
      extendClass(KJUR.asn1.ocsp.TBSRequest, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.OCSPRequest = function(f) {
        var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
        d.OCSPRequest.superclass.constructor.call(this);
        this.dTbsRequest = null;
        this.dOptionalSignature = null;
        this.tohex = function() {
          var g = [];
          if (this.dTbsRequest !== null) {
            g.push(this.dTbsRequest);
          } else {
            throw "tbsRequest not set";
          }
          if (this.dOptionalSignature !== null) {
            throw "optionalSignature not supported";
          }
          var h = new a({ array: g });
          this.hTLV = h.tohex();
          return this.hTLV;
        };
        this.getEncodedHex = function() {
          return this.tohex();
        };
        if (f !== void 0) {
          if (f.reqList !== void 0) {
            var e2 = new d.TBSRequest(f);
            this.dTbsRequest = e2;
          }
        }
      };
      extendClass(KJUR.asn1.ocsp.OCSPRequest, KJUR.asn1.ASN1Object);
      KJUR.asn1.ocsp.OCSPUtil = {};
      KJUR.asn1.ocsp.OCSPUtil.getRequestHex = function(a, b, h) {
        var d = KJUR, c = d.asn1, e2 = c.ocsp;
        if (h === void 0) {
          h = e2.DEFAULT_HASH;
        }
        var g = { alg: h, issuerCert: a, subjectCert: b };
        var f = new e2.OCSPRequest({ reqList: [g] });
        return f.tohex();
      };
      KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function(b) {
        var m = ASN1HEX, c = m.getVbyList, k = m.getVbyListEx, e2 = m.getIdxbyList, d = m.getIdxbyListEx, g = m.getV;
        var n2 = {};
        try {
          var j = k(b, 0, [0], "0a");
          n2.responseStatus = parseInt(j, 16);
        } catch (f) {
        }
        if (n2.responseStatus !== 0) {
          return n2;
        }
        try {
          var i = e2(b, 0, [1, 0, 1, 0, 0, 2, 0, 1]);
          if (b.substr(i, 2) === "80") {
            n2.certStatus = "good";
          } else {
            if (b.substr(i, 2) === "a1") {
              n2.certStatus = "revoked";
              n2.revocationTime = hextoutf8(c(b, i, [0]));
            } else {
              if (b.substr(i, 2) === "82") {
                n2.certStatus = "unknown";
              }
            }
          }
        } catch (f) {
        }
        try {
          var a = e2(b, 0, [1, 0, 1, 0, 0, 2, 0, 2]);
          n2.thisUpdate = hextoutf8(g(b, a));
        } catch (f) {
        }
        try {
          var l = e2(b, 0, [1, 0, 1, 0, 0, 2, 0, 3]);
          if (b.substr(l, 2) === "a0") {
            n2.nextUpdate = hextoutf8(c(b, l, [0]));
          }
        } catch (f) {
        }
        return n2;
      };
      KJUR.asn1.ocsp.OCSPParser = function() {
        var g = Error, a = X509, h = new a(), l = ASN1HEX, i = l.getV, b = l.getTLV, f = l.getIdxbyList, e2 = l.getVbyList, c = l.getTLVbyList, k = l.getVbyListEx, d = l.getTLVbyListEx, j = l.getChildIdx;
        this.getOCSPRequest = function(o2) {
          var n2 = j(o2, 0);
          if (n2.length != 1 && n2.length != 2) {
            throw new g("wrong number elements: " + n2.length);
          }
          var m = this.getTBSRequest(b(o2, n2[0]));
          return m;
        };
        this.getTBSRequest = function(o2) {
          var m = {};
          var n2 = d(o2, 0, [0], "30");
          m.array = this.getRequestList(n2);
          var p = d(o2, 0, ["[2]", 0], "30");
          if (p != null) {
            m.ext = h.getExtParamArray(p);
          }
          return m;
        };
        this.getRequestList = function(p) {
          var m = [];
          var n2 = j(p, 0);
          for (var o2 = 0; o2 < n2.length; o2++) {
            var p = b(p, n2[o2]);
            m.push(this.getRequest(p));
          }
          return m;
        };
        this.getRequest = function(n2) {
          var m = j(n2, 0);
          if (m.length != 1 && m.length != 2) {
            throw new g("wrong number elements: " + m.length);
          }
          var p = this.getCertID(b(n2, m[0]));
          if (m.length == 2) {
            var o2 = f(n2, 0, [1, 0]);
            p.ext = h.getExtParamArray(b(n2, o2));
          }
          return p;
        };
        this.getCertID = function(p) {
          var o2 = j(p, 0);
          if (o2.length != 4) {
            throw new g("wrong number elements: " + o2.length);
          }
          var n2 = new a();
          var m = {};
          m.alg = n2.getAlgorithmIdentifierName(b(p, o2[0]));
          m.issname = i(p, o2[1]);
          m.isskey = i(p, o2[2]);
          m.sbjsn = i(p, o2[3]);
          return m;
        };
        this.getOCSPResponse = function(r2) {
          var o2 = j(r2, 0);
          var m;
          var q = i(r2, o2[0]);
          var p = parseInt(q);
          if (o2.length == 1) {
            return { resstatus: p };
          }
          var n2 = c(r2, 0, [1, 0]);
          m = this.getResponseBytes(n2);
          m.resstatus = p;
          return m;
        };
        this.getResponseBytes = function(p) {
          var o2 = j(p, 0);
          var n2;
          var q = c(p, 0, [1, 0]);
          n2 = this.getBasicOCSPResponse(q);
          var m = i(p, o2[0]);
          n2.restype = KJUR.asn1.x509.OID.oid2name(hextooid(m));
          return n2;
        };
        this.getBasicOCSPResponse = function(q) {
          var t3 = j(q, 0);
          var v;
          v = this.getResponseData(b(q, t3[0]));
          var u = new X509();
          v.alg = u.getAlgorithmIdentifierName(b(q, t3[1]));
          var n2 = i(q, t3[2]);
          v.sighex = n2.substr(2);
          var m = k(q, 0, ["[0]"]);
          if (m != null) {
            var r2 = j(m, 0);
            var o2 = [];
            for (var p = 0; p < r2.length; p++) {
              var s = b(m, r2[p]);
              o2.push(s);
            }
            v.certs = o2;
          }
          return v;
        };
        this.getResponseData = function(q) {
          var p = j(q, 0);
          var r2 = p.length;
          var o2 = {};
          var n2 = 0;
          if (q.substr(p[0], 2) == "a0") {
            n2++;
          }
          o2.respid = this.getResponderID(b(q, p[n2++]));
          var t3 = i(q, p[n2++]);
          o2.prodat = hextoutf8(t3);
          o2.array = this.getSingleResponseList(b(q, p[n2++]));
          if (q.substr(p[r2 - 1], 2) == "a1") {
            var s = c(q, p[r2 - 1], [0]);
            var m = new X509();
            o2.ext = m.getExtParamArray(s);
          }
          return o2;
        };
        this.getResponderID = function(o2) {
          var n2 = {};
          if (o2.substr(0, 2) == "a2") {
            var p = e2(o2, 0, [0]);
            n2.key = p;
          }
          if (o2.substr(0, 2) == "a1") {
            var q = c(o2, 0, [0]);
            var m = new X509();
            n2.name = m.getX500Name(q);
          }
          return n2;
        };
        this.getSingleResponseList = function(q) {
          var n2 = j(q, 0);
          var m = [];
          for (var o2 = 0; o2 < n2.length; o2++) {
            var r2 = this.getSingleResponse(b(q, n2[o2]));
            m.push(r2);
          }
          return m;
        };
        this.getSingleResponse = function(p) {
          var t3 = j(p, 0);
          var v = {};
          var r2 = this.getCertID(b(p, t3[0]));
          v.certid = r2;
          var u = this.getCertStatus(b(p, t3[1]));
          v.status = u;
          if (p.substr(t3[2], 2) == "18") {
            var q = i(p, t3[2]);
            v.thisupdate = hextoutf8(q);
          }
          for (var o2 = 3; o2 < t3.length; o2++) {
            if (p.substr(t3[o2], 2) == "a0") {
              var m = e2(p, t3[o2], [0], "18");
              v.nextupdate = hextoutf8(m);
            }
            if (p.substr(t3[o2], 2) == "a1") {
              var s = new X509();
              var n2 = c(p, 0, [o2, 0]);
              v.ext = s.getExtParamArray(n2);
            }
          }
          return v;
        };
        this.getCertStatus = function(p) {
          var m = {};
          if (p == "8000") {
            return { status: "good" };
          }
          if (p == "8200") {
            return { status: "unknown" };
          }
          if (p.substr(0, 2) == "a1") {
            m.status = "revoked";
            var o2 = e2(p, 0, [0]);
            var n2 = hextoutf8(o2);
            m.time = n2;
          }
          return m;
        };
      };
      var KJUR;
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.lang == "undefined" || !KJUR.lang) {
        KJUR.lang = {};
      }
      KJUR.lang.String = function() {
      };
      function stoBA(d) {
        var b = new Array();
        for (var c = 0; c < d.length; c++) {
          b[c] = d.charCodeAt(c);
        }
        return b;
      }
      function BAtos(b) {
        var d = "";
        for (var c = 0; c < b.length; c++) {
          d = d + String.fromCharCode(b[c]);
        }
        return d;
      }
      function BAtohex(b) {
        var e2 = "";
        for (var d = 0; d < b.length; d++) {
          var c = b[d].toString(16);
          if (c.length == 1) {
            c = "0" + c;
          }
          e2 = e2 + c;
        }
        return e2;
      }
      function stohex(a) {
        return BAtohex(stoBA(a));
      }
      function stob64(a) {
        return hex2b64(stohex(a));
      }
      function stob64u(a) {
        return b64tob64u(hex2b64(stohex(a)));
      }
      function b64utos(a) {
        return BAtos(b64toBA(b64utob64(a)));
      }
      function b64tob64u(a) {
        a = a.replace(/\=/g, "");
        a = a.replace(/\+/g, "-");
        a = a.replace(/\//g, "_");
        return a;
      }
      function b64utob64(a) {
        if (a.length % 4 == 2) {
          a = a + "==";
        } else {
          if (a.length % 4 == 3) {
            a = a + "=";
          }
        }
        a = a.replace(/-/g, "+");
        a = a.replace(/_/g, "/");
        return a;
      }
      function hextob64u(a) {
        if (a.length % 2 == 1) {
          a = "0" + a;
        }
        return b64tob64u(hex2b64(a));
      }
      function b64utohex(a) {
        return b64tohex(b64utob64(a));
      }
      var utf8tob64u;
      var b64utoutf8;
      if (typeof Buffer === "function") {
        utf8tob64u = function(a) {
          return b64tob64u(Buffer.from(a, "utf8").toString("base64"));
        };
        b64utoutf8 = function(a) {
          return Buffer.from(b64utob64(a), "base64").toString("utf8");
        };
      } else {
        utf8tob64u = function(a) {
          return hextob64u(uricmptohex(encodeURIComponentAll(a)));
        };
        b64utoutf8 = function(a) {
          return decodeURIComponent(hextouricmp(b64utohex(a)));
        };
      }
      function utf8tob64(a) {
        return hex2b64(uricmptohex(encodeURIComponentAll(a)));
      }
      function b64toutf8(a) {
        return decodeURIComponent(hextouricmp(b64tohex(a)));
      }
      function utf8tohex(a) {
        return uricmptohex(encodeURIComponentAll(a)).toLowerCase();
      }
      function hextoutf8(b) {
        try {
          return decodeURIComponent(hextouricmp(b));
        } catch (a) {
          return null;
        }
      }
      function iso88591hextoutf8(a) {
        return hextoutf8(iso88591hextoutf8hex(a));
      }
      function iso88591hextoutf8hex(e2) {
        var c = e2.match(/.{1,2}/g);
        var b = [];
        for (var d = 0; d < c.length; d++) {
          var f = parseInt(c[d], 16);
          if (161 <= f && f <= 191) {
            b.push("c2");
            b.push(c[d]);
          } else {
            if (192 <= f && f <= 255) {
              b.push("c3");
              b.push((f - 64).toString(16));
            } else {
              b.push(c[d]);
            }
          }
        }
        return b.join("");
      }
      function hextorstr(c) {
        var b = "";
        for (var a = 0; a < c.length - 1; a += 2) {
          b += String.fromCharCode(parseInt(c.substr(a, 2), 16));
        }
        return b;
      }
      function rstrtohex(c) {
        var a = "";
        for (var b = 0; b < c.length; b++) {
          a += ("0" + c.charCodeAt(b).toString(16)).slice(-2);
        }
        return a;
      }
      function hextob64(a) {
        return hex2b64(a);
      }
      function hextob64nl(b) {
        var a = hextob64(b);
        var c = a.replace(/(.{64})/g, "$1\r\n");
        c = c.replace(/\r\n$/, "");
        return c;
      }
      function b64nltohex(b) {
        var a = b.replace(/[^0-9A-Za-z\/+=]*/g, "");
        var c = b64tohex(a);
        return c;
      }
      function hextopem(a, b) {
        var c = hextob64nl(a);
        return "-----BEGIN " + b + "-----\r\n" + c + "\r\n-----END " + b + "-----\r\n";
      }
      function pemtohex(a, b) {
        if (a.indexOf("-----BEGIN ") == -1) {
          throw "can't find PEM header: " + b;
        }
        if (b !== void 0) {
          a = a.replace(new RegExp("^[^]*-----BEGIN " + b + "-----"), "");
          a = a.replace(new RegExp("-----END " + b + "-----[^]*$"), "");
        } else {
          a = a.replace(/^[^]*-----BEGIN [^-]+-----/, "");
          a = a.replace(/-----END [^-]+-----[^]*$/, "");
        }
        return b64nltohex(a);
      }
      function hextoArrayBuffer(d) {
        if (d.length % 2 != 0) {
          throw "input is not even length";
        }
        if (d.match(/^[0-9A-Fa-f]+$/) == null) {
          throw "input is not hexadecimal";
        }
        var b = new ArrayBuffer(d.length / 2);
        var a = new DataView(b);
        for (var c = 0; c < d.length / 2; c++) {
          a.setUint8(c, parseInt(d.substr(c * 2, 2), 16));
        }
        return b;
      }
      function ArrayBuffertohex(b) {
        var d = "";
        var a = new DataView(b);
        for (var c = 0; c < b.byteLength; c++) {
          d += ("00" + a.getUint8(c).toString(16)).slice(-2);
        }
        return d;
      }
      function zulutomsec(n2) {
        var l, j, m, e2, f, i, b, k;
        var a, h, g, c;
        c = n2.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);
        if (c) {
          a = c[1];
          l = parseInt(a);
          if (a.length === 2) {
            if (50 <= l && l < 100) {
              l = 1900 + l;
            } else {
              if (0 <= l && l < 50) {
                l = 2e3 + l;
              }
            }
          }
          j = parseInt(c[2]) - 1;
          m = parseInt(c[3]);
          e2 = parseInt(c[4]);
          f = parseInt(c[5]);
          i = parseInt(c[6]);
          b = 0;
          h = c[7];
          if (h !== "") {
            g = (h.substr(1) + "00").substr(0, 3);
            b = parseInt(g);
          }
          return Date.UTC(l, j, m, e2, f, i, b);
        }
        throw new Error("unsupported zulu format: " + n2);
      }
      function zulutosec(a) {
        return Math.round(zulutomsec(a) / 1e3);
      }
      function zulutodate(a) {
        return new Date(zulutomsec(a));
      }
      function datetozulu(g, e2, f) {
        var b;
        var a = g.getUTCFullYear();
        if (e2) {
          if (a < 1950 || 2049 < a) {
            throw "not proper year for UTCTime: " + a;
          }
          b = ("" + a).slice(-2);
        } else {
          b = ("000" + a).slice(-4);
        }
        b += ("0" + (g.getUTCMonth() + 1)).slice(-2);
        b += ("0" + g.getUTCDate()).slice(-2);
        b += ("0" + g.getUTCHours()).slice(-2);
        b += ("0" + g.getUTCMinutes()).slice(-2);
        b += ("0" + g.getUTCSeconds()).slice(-2);
        if (f) {
          var c = g.getUTCMilliseconds();
          if (c !== 0) {
            c = ("00" + c).slice(-3);
            c = c.replace(/0+$/g, "");
            b += "." + c;
          }
        }
        b += "Z";
        return b;
      }
      function uricmptohex(a) {
        return a.replace(/%/g, "");
      }
      function hextouricmp(a) {
        return a.replace(/(..)/g, "%$1");
      }
      function ipv6tohex(g) {
        var b = "malformed IPv6 address";
        if (!g.match(/^[0-9A-Fa-f:]+$/)) {
          throw b;
        }
        g = g.toLowerCase();
        var d = g.split(":").length - 1;
        if (d < 2) {
          throw b;
        }
        var e2 = ":".repeat(7 - d + 2);
        g = g.replace("::", e2);
        var c = g.split(":");
        if (c.length != 8) {
          throw b;
        }
        for (var f = 0; f < 8; f++) {
          c[f] = ("0000" + c[f]).slice(-4);
        }
        return c.join("");
      }
      function hextoipv6(d) {
        if (!d.match(/^[0-9A-Fa-f]{32}$/)) {
          throw new Error("malformed IPv6 address: " + d);
        }
        d = d.toLowerCase();
        var b = d.match(/.{1,4}/g);
        b = b.map(function(a) {
          return a.replace(/^0+/, "");
        });
        b = b.map(function(a) {
          return a == "" ? "0" : a;
        });
        d = ":" + b.join(":") + ":";
        var c = d.match(/:(0:){2,}/g);
        if (c == null) {
          return d.slice(1, -1);
        }
        var e2 = c.sort().slice(-1)[0];
        d = d.replace(e2.substr(0, e2.length - 1), ":");
        if (d.substr(0, 2) != "::") {
          d = d.substr(1);
        }
        if (d.substr(-2, 2) != "::") {
          d = d.substr(0, d.length - 1);
        }
        return d;
      }
      function hextoip(b) {
        var c = new Error("malformed hex value");
        if (!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) {
          throw c;
        }
        if (b.length == 8) {
          var d;
          try {
            d = parseInt(b.substr(0, 2), 16) + "." + parseInt(b.substr(2, 2), 16) + "." + parseInt(b.substr(4, 2), 16) + "." + parseInt(b.substr(6, 2), 16);
            return d;
          } catch (a) {
            throw c;
          }
        } else {
          if (b.length == 16) {
            try {
              return hextoip(b.substr(0, 8)) + "/" + ipprefixlen(b.substr(8));
            } catch (a) {
              throw c;
            }
          } else {
            if (b.length == 32) {
              return hextoipv6(b);
            } else {
              if (b.length == 64) {
                try {
                  return hextoipv6(b.substr(0, 32)) + "/" + ipprefixlen(b.substr(32));
                } catch (a) {
                  throw c;
                }
                return;
              } else {
                return b;
              }
            }
          }
        }
      }
      function ipprefixlen(c) {
        var d = new Error("malformed mask");
        var a;
        try {
          a = new BigInteger(c, 16).toString(2);
        } catch (b) {
          throw d;
        }
        if (!a.match(/^1*0*$/)) {
          throw d;
        }
        return a.replace(/0+$/, "").length;
      }
      function iptohex(g) {
        var j = new Error("malformed IP address");
        g = g.toLowerCase(g);
        if (!g.match(/^[0-9a-f.:/]+$/)) {
          throw j;
        }
        if (g.match(/^[0-9.]+$/)) {
          var b = g.split(".");
          if (b.length !== 4) {
            throw j;
          }
          var h = "";
          try {
            for (var f = 0; f < 4; f++) {
              var k = parseInt(b[f]);
              h += ("0" + k.toString(16)).slice(-2);
            }
            return h;
          } catch (e2) {
            throw j;
          }
        } else {
          if (g.match(/^[0-9.]+\/[0-9]+$/)) {
            var c = g.split("/");
            return iptohex(c[0]) + ipnetmask(parseInt(c[1]), 32);
          } else {
            if (g.match(/^[0-9a-f:]+$/) && g.indexOf(":") !== -1) {
              return ipv6tohex(g);
            } else {
              if (g.match(/^[0-9a-f:]+\/[0-9]+$/) && g.indexOf(":") !== -1) {
                var c = g.split("/");
                return ipv6tohex(c[0]) + ipnetmask(parseInt(c[1]), 128);
              } else {
                throw j;
              }
            }
          }
        }
      }
      function ipnetmask(d, c) {
        if (c == 32 && d == 0) {
          return "00000000";
        }
        if (c == 128 && d == 0) {
          return "00000000000000000000000000000000";
        }
        var a = Array(d + 1).join("1") + Array(c - d + 1).join("0");
        return new BigInteger(a, 2).toString(16);
      }
      function ucs2hextoutf8(d) {
        function e2(f) {
          var h = parseInt(f.substr(0, 2), 16);
          var a = parseInt(f.substr(2), 16);
          if (h == 0 & a < 128) {
            return String.fromCharCode(a);
          }
          if (h < 8) {
            var j = 192 | (h & 7) << 3 | (a & 192) >> 6;
            var i = 128 | a & 63;
            return hextoutf8(j.toString(16) + i.toString(16));
          }
          var j = 224 | (h & 240) >> 4;
          var i = 128 | (h & 15) << 2 | (a & 192) >> 6;
          var g = 128 | a & 63;
          return hextoutf8(j.toString(16) + i.toString(16) + g.toString(16));
        }
        var c = d.match(/.{4}/g);
        var b = c.map(e2);
        return b.join("");
      }
      function encodeURIComponentAll(a) {
        var d = encodeURIComponent(a);
        var b = "";
        for (var c = 0; c < d.length; c++) {
          if (d[c] == "%") {
            b = b + d.substr(c, 3);
            c = c + 2;
          } else {
            b = b + "%" + stohex(d[c]);
          }
        }
        return b;
      }
      function newline_toUnix(a) {
        a = a.replace(/\r\n/mg, "\n");
        return a;
      }
      function newline_toDos(a) {
        a = a.replace(/\r\n/mg, "\n");
        a = a.replace(/\n/mg, "\r\n");
        return a;
      }
      KJUR.lang.String.isInteger = function(a) {
        if (a.match(/^[0-9]+$/)) {
          return true;
        } else {
          if (a.match(/^-[0-9]+$/)) {
            return true;
          } else {
            return false;
          }
        }
      };
      KJUR.lang.String.isHex = function(a) {
        return ishex(a);
      };
      function ishex(a) {
        if (a.length % 2 == 0 && (a.match(/^[0-9a-f]+$/) || a.match(/^[0-9A-F]+$/))) {
          return true;
        } else {
          return false;
        }
      }
      KJUR.lang.String.isBase64 = function(a) {
        a = a.replace(/\s+/g, "");
        if (a.match(/^[0-9A-Za-z+\/]+={0,3}$/) && a.length % 4 == 0) {
          return true;
        } else {
          return false;
        }
      };
      KJUR.lang.String.isBase64URL = function(a) {
        if (a.match(/[+/=]/)) {
          return false;
        }
        a = b64utob64(a);
        return KJUR.lang.String.isBase64(a);
      };
      function isBase64URLDot(a) {
        if (a.match(/^[0-9A-Za-z-_.]+$/)) {
          return true;
        }
        return false;
      }
      KJUR.lang.String.isIntegerArray = function(a) {
        a = a.replace(/\s+/g, "");
        if (a.match(/^\[[0-9,]+\]$/)) {
          return true;
        } else {
          return false;
        }
      };
      KJUR.lang.String.isPrintable = function(a) {
        if (a.match(/^[0-9A-Za-z '()+,-./:=?]*$/) !== null) {
          return true;
        }
        return false;
      };
      KJUR.lang.String.isIA5 = function(a) {
        if (a.match(/^[\x20-\x21\x23-\x7f]*$/) !== null) {
          return true;
        }
        return false;
      };
      KJUR.lang.String.isMail = function(a) {
        if (a.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/) !== null) {
          return true;
        }
        return false;
      };
      function hextoposhex(a) {
        if (a.length % 2 == 1) {
          return "0" + a;
        }
        if (a.substr(0, 1) > "7") {
          return "00" + a;
        }
        return a;
      }
      function intarystrtohex(b) {
        b = b.replace(/^\s*\[\s*/, "");
        b = b.replace(/\s*\]\s*$/, "");
        b = b.replace(/\s*/g, "");
        try {
          var c = b.split(/,/).map(function(g, e2, h) {
            var f = parseInt(g);
            if (f < 0 || 255 < f) {
              throw "integer not in range 0-255";
            }
            var d = ("00" + f.toString(16)).slice(-2);
            return d;
          }).join("");
          return c;
        } catch (a) {
          throw "malformed integer array string: " + a;
        }
      }
      var strdiffidx = function(c, a) {
        var d = c.length;
        if (c.length > a.length) {
          d = a.length;
        }
        for (var b = 0; b < d; b++) {
          if (c.charCodeAt(b) != a.charCodeAt(b)) {
            return b;
          }
        }
        if (c.length != a.length) {
          return d;
        }
        return -1;
      };
      function oidtohex(g) {
        var f = function(a) {
          var l = a.toString(16);
          if (l.length == 1) {
            l = "0" + l;
          }
          return l;
        };
        var e2 = function(p) {
          var o2 = "";
          var l = parseInt(p, 10);
          var a = l.toString(2);
          var m = 7 - a.length % 7;
          if (m == 7) {
            m = 0;
          }
          var r2 = "";
          for (var n2 = 0; n2 < m; n2++) {
            r2 += "0";
          }
          a = r2 + a;
          for (var n2 = 0; n2 < a.length - 1; n2 += 7) {
            var q = a.substr(n2, 7);
            if (n2 != a.length - 7) {
              q = "1" + q;
            }
            o2 += f(parseInt(q, 2));
          }
          return o2;
        };
        try {
          if (!g.match(/^[0-9.]+$/)) {
            return null;
          }
          var j = "";
          var b = g.split(".");
          var k = parseInt(b[0], 10) * 40 + parseInt(b[1], 10);
          j += f(k);
          b.splice(0, 2);
          for (var d = 0; d < b.length; d++) {
            j += e2(b[d]);
          }
          return j;
        } catch (c) {
          return null;
        }
      }
      function hextooid(g) {
        if (!ishex(g)) {
          return null;
        }
        try {
          var m = [];
          var p = g.substr(0, 2);
          var e2 = parseInt(p, 16);
          m[0] = new String(Math.floor(e2 / 40));
          m[1] = new String(e2 % 40);
          var n2 = g.substr(2);
          var l = [];
          for (var f = 0; f < n2.length / 2; f++) {
            l.push(parseInt(n2.substr(f * 2, 2), 16));
          }
          var k = [];
          var d = "";
          for (var f = 0; f < l.length; f++) {
            if (l[f] & 128) {
              d = d + strpad((l[f] & 127).toString(2), 7);
            } else {
              d = d + strpad((l[f] & 127).toString(2), 7);
              k.push(new String(parseInt(d, 2)));
              d = "";
            }
          }
          var o2 = m.join(".");
          if (k.length > 0) {
            o2 = o2 + "." + k.join(".");
          }
          return o2;
        } catch (j) {
          return null;
        }
      }
      var strpad = function(c, b, a) {
        if (a == void 0) {
          a = "0";
        }
        if (c.length >= b) {
          return c;
        }
        return new Array(b - c.length + 1).join(a) + c;
      };
      function bitstrtoint(e2) {
        if (e2.length % 2 != 0) {
          return -1;
        }
        e2 = e2.toLowerCase();
        if (e2.match(/^[0-9a-f]+$/) == null) {
          return -1;
        }
        try {
          var a = e2.substr(0, 2);
          if (a == "00") {
            return parseInt(e2.substr(2), 16);
          }
          var b = parseInt(a, 16);
          if (b > 7) {
            return -1;
          }
          var g = e2.substr(2);
          var d = parseInt(g, 16).toString(2);
          if (d == "0") {
            d = "00000000";
          }
          d = d.slice(0, 0 - b);
          var f = parseInt(d, 2);
          if (f == NaN) {
            return -1;
          }
          return f;
        } catch (c) {
          return -1;
        }
      }
      function inttobitstr(e2) {
        if (typeof e2 != "number") {
          return null;
        }
        if (e2 < 0) {
          return null;
        }
        var c = Number(e2).toString(2);
        var b = 8 - c.length % 8;
        if (b == 8) {
          b = 0;
        }
        c = c + strpad("", b, "0");
        var d = parseInt(c, 2).toString(16);
        if (d.length % 2 == 1) {
          d = "0" + d;
        }
        var a = "0" + b;
        return a + d;
      }
      function bitstrtobinstr(g) {
        if (typeof g != "string") {
          return null;
        }
        if (g.length % 2 != 0) {
          return null;
        }
        if (!g.match(/^[0-9a-f]+$/)) {
          return null;
        }
        try {
          var c = parseInt(g.substr(0, 2), 16);
          if (c < 0 || 7 < c) {
            return null;
          }
          var j = g.substr(2);
          var f = "";
          for (var e2 = 0; e2 < j.length; e2 += 2) {
            var b = j.substr(e2, 2);
            var a = parseInt(b, 16).toString(2);
            a = ("0000000" + a).slice(-8);
            f += a;
          }
          return f.substr(0, f.length - c);
        } catch (d) {
          return null;
        }
      }
      function binstrtobitstr(b) {
        if (typeof b != "string") {
          return null;
        }
        if (b.match(/^[01]+$/) == null) {
          return null;
        }
        try {
          var c = parseInt(b, 2);
          return inttobitstr(c);
        } catch (a) {
          return null;
        }
      }
      function namearraytobinstr(e2, g) {
        var f = 0;
        for (var a = 0; a < e2.length; a++) {
          f |= 1 << g[e2[a]];
        }
        var b = f.toString(2);
        var c = "";
        for (var a = b.length - 1; a >= 0; a--) {
          c += b[a];
        }
        return c;
      }
      function extendClass(c, a) {
        var b = function() {
        };
        b.prototype = a.prototype;
        c.prototype = new b();
        c.prototype.constructor = c;
        c.superclass = a.prototype;
        if (a.prototype.constructor == Object.prototype.constructor) {
          a.prototype.constructor = a;
        }
      }
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
        KJUR.crypto = {};
      }
      KJUR.crypto.Util = new function() {
        this.DIGESTINFOHEAD = { sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", ripemd160: "3021300906052b2403020105000414" };
        this.DEFAULTPROVIDER = { md5: "cryptojs", sha1: "cryptojs", sha224: "cryptojs", sha256: "cryptojs", sha384: "cryptojs", sha512: "cryptojs", ripemd160: "cryptojs", hmacmd5: "cryptojs", hmacsha1: "cryptojs", hmacsha224: "cryptojs", hmacsha256: "cryptojs", hmacsha384: "cryptojs", hmacsha512: "cryptojs", hmacripemd160: "cryptojs", MD5withRSA: "cryptojs/jsrsa", SHA1withRSA: "cryptojs/jsrsa", SHA224withRSA: "cryptojs/jsrsa", SHA256withRSA: "cryptojs/jsrsa", SHA384withRSA: "cryptojs/jsrsa", SHA512withRSA: "cryptojs/jsrsa", RIPEMD160withRSA: "cryptojs/jsrsa", MD5withECDSA: "cryptojs/jsrsa", SHA1withECDSA: "cryptojs/jsrsa", SHA224withECDSA: "cryptojs/jsrsa", SHA256withECDSA: "cryptojs/jsrsa", SHA384withECDSA: "cryptojs/jsrsa", SHA512withECDSA: "cryptojs/jsrsa", RIPEMD160withECDSA: "cryptojs/jsrsa", SHA1withDSA: "cryptojs/jsrsa", SHA224withDSA: "cryptojs/jsrsa", SHA256withDSA: "cryptojs/jsrsa", MD5withRSAandMGF1: "cryptojs/jsrsa", SHAwithRSAandMGF1: "cryptojs/jsrsa", SHA1withRSAandMGF1: "cryptojs/jsrsa", SHA224withRSAandMGF1: "cryptojs/jsrsa", SHA256withRSAandMGF1: "cryptojs/jsrsa", SHA384withRSAandMGF1: "cryptojs/jsrsa", SHA512withRSAandMGF1: "cryptojs/jsrsa", RIPEMD160withRSAandMGF1: "cryptojs/jsrsa" };
        this.CRYPTOJSMESSAGEDIGESTNAME = { md5: CryptoJS.algo.MD5, sha1: CryptoJS.algo.SHA1, sha224: CryptoJS.algo.SHA224, sha256: CryptoJS.algo.SHA256, sha384: CryptoJS.algo.SHA384, sha512: CryptoJS.algo.SHA512, ripemd160: CryptoJS.algo.RIPEMD160 };
        this.getDigestInfoHex = function(a, b) {
          if (typeof this.DIGESTINFOHEAD[b] == "undefined") {
            throw "alg not supported in Util.DIGESTINFOHEAD: " + b;
          }
          return this.DIGESTINFOHEAD[b] + a;
        };
        this.getPaddedDigestInfoHex = function(h, a, j) {
          var c = this.getDigestInfoHex(h, a);
          var d = j / 4;
          if (c.length + 22 > d) {
            throw "key is too short for SigAlg: keylen=" + j + "," + a;
          }
          var b = "0001";
          var k = "00" + c;
          var g = "";
          var l = d - b.length - k.length;
          for (var f = 0; f < l; f += 2) {
            g += "ff";
          }
          var e2 = b + g + k;
          return e2;
        };
        this.hashString = function(a, c) {
          var b = new KJUR.crypto.MessageDigest({ alg: c });
          return b.digestString(a);
        };
        this.hashHex = function(b, c) {
          var a = new KJUR.crypto.MessageDigest({ alg: c });
          return a.digestHex(b);
        };
        this.sha1 = function(a) {
          return this.hashString(a, "sha1");
        };
        this.sha256 = function(a) {
          return this.hashString(a, "sha256");
        };
        this.sha256Hex = function(a) {
          return this.hashHex(a, "sha256");
        };
        this.sha512 = function(a) {
          return this.hashString(a, "sha512");
        };
        this.sha512Hex = function(a) {
          return this.hashHex(a, "sha512");
        };
        this.isKey = function(a) {
          if (a instanceof RSAKey || a instanceof KJUR.crypto.DSA || a instanceof KJUR.crypto.ECDSA) {
            return true;
          } else {
            return false;
          }
        };
      }();
      KJUR.crypto.Util.md5 = function(a) {
        var b = new KJUR.crypto.MessageDigest({ alg: "md5", prov: "cryptojs" });
        return b.digestString(a);
      };
      KJUR.crypto.Util.ripemd160 = function(a) {
        var b = new KJUR.crypto.MessageDigest({ alg: "ripemd160", prov: "cryptojs" });
        return b.digestString(a);
      };
      KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom();
      KJUR.crypto.Util.getRandomHexOfNbytes = function(b) {
        var a = new Array(b);
        KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);
        return BAtohex(a);
      };
      KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function(a) {
        return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a), 16);
      };
      KJUR.crypto.Util.getRandomHexOfNbits = function(d) {
        var c = d % 8;
        var a = (d - c) / 8;
        var b = new Array(a + 1);
        KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);
        b[0] = (255 << c & 255 ^ 255) & b[0];
        return BAtohex(b);
      };
      KJUR.crypto.Util.getRandomBigIntegerOfNbits = function(a) {
        return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a), 16);
      };
      KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function(b) {
        var a = b.bitLength();
        while (1) {
          var c = KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);
          if (b.compareTo(c) != -1) {
            return c;
          }
        }
      };
      KJUR.crypto.Util.getRandomBigIntegerMinToMax = function(e2, b) {
        var c = e2.compareTo(b);
        if (c == 1) {
          throw "biMin is greater than biMax";
        }
        if (c == 0) {
          return e2;
        }
        var a = b.subtract(e2);
        var d = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);
        return d.add(e2);
      };
      KJUR.crypto.MessageDigest = function(c) {
        var b = null;
        var a = null;
        var d = null;
        this.setAlgAndProvider = function(g, f) {
          g = KJUR.crypto.MessageDigest.getCanonicalAlgName(g);
          if (g !== null && f === void 0) {
            f = KJUR.crypto.Util.DEFAULTPROVIDER[g];
          }
          if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && f == "cryptojs") {
            try {
              this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create();
            } catch (e2) {
              throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e2;
            }
            this.updateString = function(h) {
              this.md.update(h);
            };
            this.updateHex = function(h) {
              var i = CryptoJS.enc.Hex.parse(h);
              this.md.update(i);
            };
            this.digest = function() {
              var h = this.md.finalize();
              return h.toString(CryptoJS.enc.Hex);
            };
            this.digestString = function(h) {
              this.updateString(h);
              return this.digest();
            };
            this.digestHex = function(h) {
              this.updateHex(h);
              return this.digest();
            };
          }
          if (":sha256:".indexOf(g) != -1 && f == "sjcl") {
            try {
              this.md = new sjcl.hash.sha256();
            } catch (e2) {
              throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e2;
            }
            this.updateString = function(h) {
              this.md.update(h);
            };
            this.updateHex = function(i) {
              var h = sjcl.codec.hex.toBits(i);
              this.md.update(h);
            };
            this.digest = function() {
              var h = this.md.finalize();
              return sjcl.codec.hex.fromBits(h);
            };
            this.digestString = function(h) {
              this.updateString(h);
              return this.digest();
            };
            this.digestHex = function(h) {
              this.updateHex(h);
              return this.digest();
            };
          }
        };
        this.updateString = function(e2) {
          throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
        };
        this.updateHex = function(e2) {
          throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
        };
        this.digest = function() {
          throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
        };
        this.digestString = function(e2) {
          throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
        };
        this.digestHex = function(e2) {
          throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
        };
        if (c !== void 0) {
          if (c.alg !== void 0) {
            this.algName = c.alg;
            if (c.prov === void 0) {
              this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            }
            this.setAlgAndProvider(this.algName, this.provName);
          }
        }
      };
      KJUR.crypto.MessageDigest.getCanonicalAlgName = function(a) {
        if (typeof a === "string") {
          a = a.toLowerCase();
          a = a.replace(/-/, "");
        }
        return a;
      };
      KJUR.crypto.MessageDigest.getHashLength = function(c) {
        var b = KJUR.crypto.MessageDigest;
        var a = b.getCanonicalAlgName(c);
        if (b.HASHLENGTH[a] === void 0) {
          throw "not supported algorithm: " + c;
        }
        return b.HASHLENGTH[a];
      };
      KJUR.crypto.MessageDigest.HASHLENGTH = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, ripemd160: 20 };
      KJUR.crypto.Mac = function(d) {
        var f = null;
        var c = null;
        var a = null;
        var e2 = null;
        var b = null;
        this.setAlgAndProvider = function(k, i) {
          k = k.toLowerCase();
          if (k == null) {
            k = "hmacsha1";
          }
          k = k.toLowerCase();
          if (k.substr(0, 4) != "hmac") {
            throw "setAlgAndProvider unsupported HMAC alg: " + k;
          }
          if (i === void 0) {
            i = KJUR.crypto.Util.DEFAULTPROVIDER[k];
          }
          this.algProv = k + "/" + i;
          var g = k.substr(4);
          if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && i == "cryptojs") {
            try {
              var j = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];
              this.mac = CryptoJS.algo.HMAC.create(j, this.pass);
            } catch (h) {
              throw "setAlgAndProvider hash alg set fail hashAlg=" + g + "/" + h;
            }
            this.updateString = function(l) {
              this.mac.update(l);
            };
            this.updateHex = function(l) {
              var m = CryptoJS.enc.Hex.parse(l);
              this.mac.update(m);
            };
            this.doFinal = function() {
              var l = this.mac.finalize();
              return l.toString(CryptoJS.enc.Hex);
            };
            this.doFinalString = function(l) {
              this.updateString(l);
              return this.doFinal();
            };
            this.doFinalHex = function(l) {
              this.updateHex(l);
              return this.doFinal();
            };
          }
        };
        this.updateString = function(g) {
          throw "updateString(str) not supported for this alg/prov: " + this.algProv;
        };
        this.updateHex = function(g) {
          throw "updateHex(hex) not supported for this alg/prov: " + this.algProv;
        };
        this.doFinal = function() {
          throw "digest() not supported for this alg/prov: " + this.algProv;
        };
        this.doFinalString = function(g) {
          throw "digestString(str) not supported for this alg/prov: " + this.algProv;
        };
        this.doFinalHex = function(g) {
          throw "digestHex(hex) not supported for this alg/prov: " + this.algProv;
        };
        this.setPassword = function(h) {
          if (typeof h == "string") {
            var g = h;
            if (h.length % 2 == 1 || !h.match(/^[0-9A-Fa-f]+$/)) {
              g = rstrtohex(h);
            }
            this.pass = CryptoJS.enc.Hex.parse(g);
            return;
          }
          if (typeof h != "object") {
            throw "KJUR.crypto.Mac unsupported password type: " + h;
          }
          var g = null;
          if (h.hex !== void 0) {
            if (h.hex.length % 2 != 0 || !h.hex.match(/^[0-9A-Fa-f]+$/)) {
              throw "Mac: wrong hex password: " + h.hex;
            }
            g = h.hex;
          }
          if (h.utf8 !== void 0) {
            g = utf8tohex(h.utf8);
          }
          if (h.rstr !== void 0) {
            g = rstrtohex(h.rstr);
          }
          if (h.b64 !== void 0) {
            g = b64tohex(h.b64);
          }
          if (h.b64u !== void 0) {
            g = b64utohex(h.b64u);
          }
          if (g == null) {
            throw "KJUR.crypto.Mac unsupported password type: " + h;
          }
          this.pass = CryptoJS.enc.Hex.parse(g);
        };
        if (d !== void 0) {
          if (d.pass !== void 0) {
            this.setPassword(d.pass);
          }
          if (d.alg !== void 0) {
            this.algName = d.alg;
            if (d.prov === void 0) {
              this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            }
            this.setAlgAndProvider(this.algName, this.provName);
          }
        }
      };
      KJUR.crypto.Signature = function(o2) {
        var q = null;
        var n2 = null;
        var r2 = null;
        var c = null;
        var l = null;
        var d = null;
        var k = null;
        var h = null;
        var p = null;
        var e2 = null;
        var b = -1;
        var g = null;
        var j = null;
        var a = null;
        var i = null;
        var f = null;
        this._setAlgNames = function() {
          var s = this.algName.match(/^(.+)with(.+)$/);
          if (s) {
            this.mdAlgName = s[1].toLowerCase();
            this.pubkeyAlgName = s[2].toLowerCase();
            if (this.pubkeyAlgName == "rsaandmgf1" && this.mdAlgName == "sha") {
              this.mdAlgName = "sha1";
            }
          }
        };
        this._zeroPaddingOfSignature = function(x, w) {
          var v = "";
          var t3 = w / 4 - x.length;
          for (var u = 0; u < t3; u++) {
            v = v + "0";
          }
          return v + x;
        };
        this.setAlgAndProvider = function(u, t3) {
          this._setAlgNames();
          if (t3 != "cryptojs/jsrsa") {
            throw new Error("provider not supported: " + t3);
          }
          if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) {
            try {
              this.md = new KJUR.crypto.MessageDigest({ alg: this.mdAlgName });
            } catch (s) {
              throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + s);
            }
            this.init = function(w, x) {
              var y = null;
              try {
                if (x === void 0) {
                  y = KEYUTIL.getKey(w);
                } else {
                  y = KEYUTIL.getKey(w, x);
                }
              } catch (v) {
                throw "init failed:" + v;
              }
              if (y.isPrivate === true) {
                this.prvKey = y;
                this.state = "SIGN";
              } else {
                if (y.isPublic === true) {
                  this.pubKey = y;
                  this.state = "VERIFY";
                } else {
                  throw "init failed.:" + y;
                }
              }
            };
            this.updateString = function(v) {
              this.md.updateString(v);
            };
            this.updateHex = function(v) {
              this.md.updateHex(v);
            };
            this.sign = function() {
              this.sHashHex = this.md.digest();
              if (this.prvKey === void 0 && this.ecprvhex !== void 0 && this.eccurvename !== void 0 && KJUR.crypto.ECDSA !== void 0) {
                this.prvKey = new KJUR.crypto.ECDSA({ curve: this.eccurvename, prv: this.ecprvhex });
              }
              if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
                this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen);
              } else {
                if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
                  this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName);
                } else {
                  if (this.prvKey instanceof KJUR.crypto.ECDSA) {
                    this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                  } else {
                    if (this.prvKey instanceof KJUR.crypto.DSA) {
                      this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                    } else {
                      throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
                    }
                  }
                }
              }
              return this.hSign;
            };
            this.signString = function(v) {
              this.updateString(v);
              return this.sign();
            };
            this.signHex = function(v) {
              this.updateHex(v);
              return this.sign();
            };
            this.verify = function(v) {
              this.sHashHex = this.md.digest();
              if (this.pubKey === void 0 && this.ecpubhex !== void 0 && this.eccurvename !== void 0 && KJUR.crypto.ECDSA !== void 0) {
                this.pubKey = new KJUR.crypto.ECDSA({ curve: this.eccurvename, pub: this.ecpubhex });
              }
              if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
                return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, v, this.mdAlgName, this.pssSaltLen);
              } else {
                if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
                  return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                } else {
                  if (KJUR.crypto.ECDSA !== void 0 && this.pubKey instanceof KJUR.crypto.ECDSA) {
                    return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                  } else {
                    if (KJUR.crypto.DSA !== void 0 && this.pubKey instanceof KJUR.crypto.DSA) {
                      return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                    } else {
                      throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
                    }
                  }
                }
              }
            };
          }
        };
        this.init = function(s, t3) {
          throw "init(key, pass) not supported for this alg:prov=" + this.algProvName;
        };
        this.updateString = function(s) {
          throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
        };
        this.updateHex = function(s) {
          throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
        };
        this.sign = function() {
          throw "sign() not supported for this alg:prov=" + this.algProvName;
        };
        this.signString = function(s) {
          throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
        };
        this.signHex = function(s) {
          throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
        };
        this.verify = function(s) {
          throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
        };
        this.initParams = o2;
        if (o2 !== void 0) {
          if (o2.alg !== void 0) {
            this.algName = o2.alg;
            if (o2.prov === void 0) {
              this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            } else {
              this.provName = o2.prov;
            }
            this.algProvName = this.algName + ":" + this.provName;
            this.setAlgAndProvider(this.algName, this.provName);
            this._setAlgNames();
          }
          if (o2.psssaltlen !== void 0) {
            this.pssSaltLen = o2.psssaltlen;
          }
          if (o2.prvkeypem !== void 0) {
            if (o2.prvkeypas !== void 0) {
              throw "both prvkeypem and prvkeypas parameters not supported";
            } else {
              try {
                var q = KEYUTIL.getKey(o2.prvkeypem);
                this.init(q);
              } catch (m) {
                throw "fatal error to load pem private key: " + m;
              }
            }
          }
        }
      };
      KJUR.crypto.Cipher = function(a) {
      };
      KJUR.crypto.Cipher.encrypt = function(e2, f, d) {
        if (f instanceof RSAKey && f.isPublic) {
          var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
          if (c === "RSA") {
            return f.encrypt(e2);
          }
          if (c === "RSAOAEP") {
            return f.encryptOAEP(e2, "sha1");
          }
          var b = c.match(/^RSAOAEP(\d+)$/);
          if (b !== null) {
            return f.encryptOAEP(e2, "sha" + b[1]);
          }
          throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + d;
        } else {
          throw "Cipher.encrypt: unsupported key or algorithm";
        }
      };
      KJUR.crypto.Cipher.decrypt = function(e2, f, d) {
        if (f instanceof RSAKey && f.isPrivate) {
          var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
          if (c === "RSA") {
            return f.decrypt(e2);
          }
          if (c === "RSAOAEP") {
            return f.decryptOAEP(e2, "sha1");
          }
          var b = c.match(/^RSAOAEP(\d+)$/);
          if (b !== null) {
            return f.decryptOAEP(e2, "sha" + b[1]);
          }
          throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + d;
        } else {
          throw "Cipher.decrypt: unsupported key or algorithm";
        }
      };
      KJUR.crypto.Cipher.getAlgByKeyAndName = function(b, a) {
        if (b instanceof RSAKey) {
          if (":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a) != -1) {
            return a;
          }
          if (a === null || a === void 0) {
            return "RSA";
          }
          throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + a;
        }
        throw "getAlgByKeyAndName: not supported algorithm name: " + a;
      };
      KJUR.crypto.OID = new function() {
        this.oidhex2name = { "2a864886f70d010101": "rsaEncryption", "2a8648ce3d0201": "ecPublicKey", "2a8648ce380401": "dsa", "2a8648ce3d030107": "secp256r1", "2b8104001f": "secp192k1", "2b81040021": "secp224r1", "2b8104000a": "secp256k1", "2b81040022": "secp384r1", "2b81040023": "secp521r1", "2a8648ce380403": "SHA1withDSA", "608648016503040301": "SHA224withDSA", "608648016503040302": "SHA256withDSA" };
      }();
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
        KJUR.crypto = {};
      }
      KJUR.crypto.ECDSA = function(e2) {
        var g = "secp256r1";
        var p = null;
        var b = null;
        var i = null;
        var j = Error, f = BigInteger, h = ECPointFp, m = KJUR.crypto.ECDSA, c = KJUR.crypto.ECParameterDB, d = m.getName, q = ASN1HEX, n2 = q.getVbyListEx, k = q.isASN1HEX;
        var a = new SecureRandom();
        var o2 = null;
        this.type = "EC";
        this.isPrivate = false;
        this.isPublic = false;
        function l(x, t3, w, s) {
          var r2 = Math.max(t3.bitLength(), s.bitLength());
          var y = x.add2D(w);
          var v = x.curve.getInfinity();
          for (var u = r2 - 1; u >= 0; --u) {
            v = v.twice2D();
            v.z = f.ONE;
            if (t3.testBit(u)) {
              if (s.testBit(u)) {
                v = v.add2D(y);
              } else {
                v = v.add2D(x);
              }
            } else {
              if (s.testBit(u)) {
                v = v.add2D(w);
              }
            }
          }
          return v;
        }
        this.getBigRandom = function(r2) {
          return new f(r2.bitLength(), a).mod(r2.subtract(f.ONE)).add(f.ONE);
        };
        this.setNamedCurve = function(r2) {
          this.ecparams = c.getByName(r2);
          this.prvKeyHex = null;
          this.pubKeyHex = null;
          this.curveName = r2;
        };
        this.setPrivateKeyHex = function(r2) {
          this.isPrivate = true;
          this.prvKeyHex = r2;
        };
        this.setPublicKeyHex = function(r2) {
          this.isPublic = true;
          this.pubKeyHex = r2;
        };
        this.getPublicKeyXYHex = function() {
          var t3 = this.pubKeyHex;
          if (t3.substr(0, 2) !== "04") {
            throw "this method supports uncompressed format(04) only";
          }
          var s = this.ecparams.keycharlen;
          if (t3.length !== 2 + s * 2) {
            throw "malformed public key hex length";
          }
          var r2 = {};
          r2.x = t3.substr(2, s);
          r2.y = t3.substr(2 + s);
          return r2;
        };
        this.getShortNISTPCurveName = function() {
          var r2 = this.curveName;
          if (r2 === "secp256r1" || r2 === "NIST P-256" || r2 === "P-256" || r2 === "prime256v1") {
            return "P-256";
          }
          if (r2 === "secp384r1" || r2 === "NIST P-384" || r2 === "P-384") {
            return "P-384";
          }
          if (r2 === "secp521r1" || r2 === "NIST P-521" || r2 === "P-521") {
            return "P-521";
          }
          return null;
        };
        this.generateKeyPairHex = function() {
          var s = this.ecparams.n;
          var u = this.getBigRandom(s);
          var r2 = this.ecparams.keycharlen;
          var t3 = ("0000000000" + u.toString(16)).slice(-r2);
          this.setPrivateKeyHex(t3);
          var v = this.generatePublicKeyHex();
          return { ecprvhex: t3, ecpubhex: v };
        };
        this.generatePublicKeyHex = function() {
          var u = new f(this.prvKeyHex, 16);
          var w = this.ecparams.G.multiply(u);
          var t3 = w.getX().toBigInteger();
          var s = w.getY().toBigInteger();
          var r2 = this.ecparams.keycharlen;
          var y = ("0000000000" + t3.toString(16)).slice(-r2);
          var v = ("0000000000" + s.toString(16)).slice(-r2);
          var x = "04" + y + v;
          this.setPublicKeyHex(x);
          return x;
        };
        this.signWithMessageHash = function(r2) {
          return this.signHex(r2, this.prvKeyHex);
        };
        this.signHex = function(x, u) {
          var A = new f(u, 16);
          var v = this.ecparams.n;
          var z2 = new f(x.substring(0, this.ecparams.keycharlen), 16);
          do {
            var w = this.getBigRandom(v);
            var B = this.ecparams.G;
            var y = B.multiply(w);
            var t3 = y.getX().toBigInteger().mod(v);
          } while (t3.compareTo(f.ZERO) <= 0);
          var C = w.modInverse(v).multiply(z2.add(A.multiply(t3))).mod(v);
          return m.biRSSigToASN1Sig(t3, C);
        };
        this.sign = function(w, B) {
          var z2 = B;
          var u = this.ecparams.n;
          var y = f.fromByteArrayUnsigned(w);
          do {
            var v = this.getBigRandom(u);
            var A = this.ecparams.G;
            var x = A.multiply(v);
            var t3 = x.getX().toBigInteger().mod(u);
          } while (t3.compareTo(BigInteger.ZERO) <= 0);
          var C = v.modInverse(u).multiply(y.add(z2.multiply(t3))).mod(u);
          return this.serializeSig(t3, C);
        };
        this.verifyWithMessageHash = function(s, r2) {
          return this.verifyHex(s, r2, this.pubKeyHex);
        };
        this.verifyHex = function(v, y, u) {
          try {
            var t3, B;
            var w = m.parseSigHex(y);
            t3 = w.r;
            B = w.s;
            var x = h.decodeFromHex(this.ecparams.curve, u);
            var z2 = new f(v.substring(0, this.ecparams.keycharlen), 16);
            return this.verifyRaw(z2, t3, B, x);
          } catch (A) {
            return false;
          }
        };
        this.verify = function(z2, A, u) {
          var w, t3;
          if (Bitcoin.Util.isArray(A)) {
            var y = this.parseSig(A);
            w = y.r;
            t3 = y.s;
          } else {
            if ("object" === typeof A && A.r && A.s) {
              w = A.r;
              t3 = A.s;
            } else {
              throw "Invalid value for signature";
            }
          }
          var v;
          if (u instanceof ECPointFp) {
            v = u;
          } else {
            if (Bitcoin.Util.isArray(u)) {
              v = h.decodeFrom(this.ecparams.curve, u);
            } else {
              throw "Invalid format for pubkey value, must be byte array or ECPointFp";
            }
          }
          var x = f.fromByteArrayUnsigned(z2);
          return this.verifyRaw(x, w, t3, v);
        };
        this.verifyRaw = function(z2, t3, E, y) {
          var x = this.ecparams.n;
          var D = this.ecparams.G;
          if (t3.compareTo(f.ONE) < 0 || t3.compareTo(x) >= 0) {
            return false;
          }
          if (E.compareTo(f.ONE) < 0 || E.compareTo(x) >= 0) {
            return false;
          }
          var A = E.modInverse(x);
          var w = z2.multiply(A).mod(x);
          var u = t3.multiply(A).mod(x);
          var B = D.multiply(w).add(y.multiply(u));
          var C = B.getX().toBigInteger().mod(x);
          return C.equals(t3);
        };
        this.serializeSig = function(v, u) {
          var w = v.toByteArraySigned();
          var t3 = u.toByteArraySigned();
          var x = [];
          x.push(2);
          x.push(w.length);
          x = x.concat(w);
          x.push(2);
          x.push(t3.length);
          x = x.concat(t3);
          x.unshift(x.length);
          x.unshift(48);
          return x;
        };
        this.parseSig = function(y) {
          var x;
          if (y[0] != 48) {
            throw new Error("Signature not a valid DERSequence");
          }
          x = 2;
          if (y[x] != 2) {
            throw new Error("First element in signature must be a DERInteger");
          }
          var w = y.slice(x + 2, x + 2 + y[x + 1]);
          x += 2 + y[x + 1];
          if (y[x] != 2) {
            throw new Error("Second element in signature must be a DERInteger");
          }
          var t3 = y.slice(x + 2, x + 2 + y[x + 1]);
          x += 2 + y[x + 1];
          var v = f.fromByteArrayUnsigned(w);
          var u = f.fromByteArrayUnsigned(t3);
          return { r: v, s: u };
        };
        this.parseSigCompact = function(w) {
          if (w.length !== 65) {
            throw "Signature has the wrong length";
          }
          var t3 = w[0] - 27;
          if (t3 < 0 || t3 > 7) {
            throw "Invalid signature type";
          }
          var x = this.ecparams.n;
          var v = f.fromByteArrayUnsigned(w.slice(1, 33)).mod(x);
          var u = f.fromByteArrayUnsigned(w.slice(33, 65)).mod(x);
          return { r: v, s: u, i: t3 };
        };
        this.readPKCS5PrvKeyHex = function(u) {
          if (k(u) === false) {
            throw new Error("not ASN.1 hex string");
          }
          var r2, t3, v;
          try {
            r2 = n2(u, 0, ["[0]", 0], "06");
            t3 = n2(u, 0, [1], "04");
            try {
              v = n2(u, 0, ["[1]", 0], "03");
            } catch (s) {
            }
          } catch (s) {
            throw new Error("malformed PKCS#1/5 plain ECC private key");
          }
          this.curveName = d(r2);
          if (this.curveName === void 0) {
            throw "unsupported curve name";
          }
          this.setNamedCurve(this.curveName);
          this.setPublicKeyHex(v);
          this.setPrivateKeyHex(t3);
          this.isPublic = false;
        };
        this.readPKCS8PrvKeyHex = function(v) {
          if (k(v) === false) {
            throw new j("not ASN.1 hex string");
          }
          var t3, r2, u, w;
          try {
            t3 = n2(v, 0, [1, 0], "06");
            r2 = n2(v, 0, [1, 1], "06");
            u = n2(v, 0, [2, 0, 1], "04");
            try {
              w = n2(v, 0, [2, 0, "[1]", 0], "03");
            } catch (s) {
            }
          } catch (s) {
            throw new j("malformed PKCS#8 plain ECC private key");
          }
          this.curveName = d(r2);
          if (this.curveName === void 0) {
            throw new j("unsupported curve name");
          }
          this.setNamedCurve(this.curveName);
          this.setPublicKeyHex(w);
          this.setPrivateKeyHex(u);
          this.isPublic = false;
        };
        this.readPKCS8PubKeyHex = function(u) {
          if (k(u) === false) {
            throw new j("not ASN.1 hex string");
          }
          var t3, r2, v;
          try {
            t3 = n2(u, 0, [0, 0], "06");
            r2 = n2(u, 0, [0, 1], "06");
            v = n2(u, 0, [1], "03");
          } catch (s) {
            throw new j("malformed PKCS#8 ECC public key");
          }
          this.curveName = d(r2);
          if (this.curveName === null) {
            throw new j("unsupported curve name");
          }
          this.setNamedCurve(this.curveName);
          this.setPublicKeyHex(v);
        };
        this.readCertPubKeyHex = function(t3, v) {
          if (k(t3) === false) {
            throw new j("not ASN.1 hex string");
          }
          var r2, u;
          try {
            r2 = n2(t3, 0, [0, 5, 0, 1], "06");
            u = n2(t3, 0, [0, 5, 1], "03");
          } catch (s) {
            throw new j("malformed X.509 certificate ECC public key");
          }
          this.curveName = d(r2);
          if (this.curveName === null) {
            throw new j("unsupported curve name");
          }
          this.setNamedCurve(this.curveName);
          this.setPublicKeyHex(u);
        };
        if (e2 !== void 0) {
          if (e2.curve !== void 0) {
            this.curveName = e2.curve;
          }
        }
        if (this.curveName === void 0) {
          this.curveName = g;
        }
        this.setNamedCurve(this.curveName);
        if (e2 !== void 0) {
          if (e2.prv !== void 0) {
            this.setPrivateKeyHex(e2.prv);
          }
          if (e2.pub !== void 0) {
            this.setPublicKeyHex(e2.pub);
          }
        }
      };
      KJUR.crypto.ECDSA.parseSigHex = function(a) {
        var b = KJUR.crypto.ECDSA.parseSigHexInHexRS(a);
        var d = new BigInteger(b.r, 16);
        var c = new BigInteger(b.s, 16);
        return { r: d, s: c };
      };
      KJUR.crypto.ECDSA.parseSigHexInHexRS = function(f) {
        var j = ASN1HEX, i = j.getChildIdx, g = j.getV;
        j.checkStrictDER(f, 0);
        if (f.substr(0, 2) != "30") {
          throw new Error("signature is not a ASN.1 sequence");
        }
        var h = i(f, 0);
        if (h.length != 2) {
          throw new Error("signature shall have two elements");
        }
        var e2 = h[0];
        var d = h[1];
        if (f.substr(e2, 2) != "02") {
          throw new Error("1st item not ASN.1 integer");
        }
        if (f.substr(d, 2) != "02") {
          throw new Error("2nd item not ASN.1 integer");
        }
        var c = g(f, e2);
        var b = g(f, d);
        return { r: c, s: b };
      };
      KJUR.crypto.ECDSA.asn1SigToConcatSig = function(d) {
        var e2 = KJUR.crypto.ECDSA.parseSigHexInHexRS(d);
        var b = e2.r;
        var a = e2.s;
        if (b.length >= 130 && b.length <= 134) {
          if (b.length % 2 != 0) {
            throw Error("unknown ECDSA sig r length error");
          }
          if (a.length % 2 != 0) {
            throw Error("unknown ECDSA sig s length error");
          }
          if (b.substr(0, 2) == "00") {
            b = b.substr(2);
          }
          if (a.substr(0, 2) == "00") {
            a = a.substr(2);
          }
          var c = Math.max(b.length, a.length);
          b = ("000000" + b).slice(-c);
          a = ("000000" + a).slice(-c);
          return b + a;
        }
        if (b.substr(0, 2) == "00" && b.length % 32 == 2) {
          b = b.substr(2);
        }
        if (a.substr(0, 2) == "00" && a.length % 32 == 2) {
          a = a.substr(2);
        }
        if (b.length % 32 == 30) {
          b = "00" + b;
        }
        if (a.length % 32 == 30) {
          a = "00" + a;
        }
        if (b.length % 32 != 0) {
          throw Error("unknown ECDSA sig r length error");
        }
        if (a.length % 32 != 0) {
          throw Error("unknown ECDSA sig s length error");
        }
        return b + a;
      };
      KJUR.crypto.ECDSA.concatSigToASN1Sig = function(a) {
        if (a.length % 4 != 0) {
          throw Error("unknown ECDSA concatinated r-s sig length error");
        }
        var c = a.substr(0, a.length / 2);
        var b = a.substr(a.length / 2);
        return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c, b);
      };
      KJUR.crypto.ECDSA.hexRSSigToASN1Sig = function(b, a) {
        var d = new BigInteger(b, 16);
        var c = new BigInteger(a, 16);
        return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d, c);
      };
      KJUR.crypto.ECDSA.biRSSigToASN1Sig = function(f, d) {
        var c = KJUR.asn1;
        var b = new c.DERInteger({ bigint: f });
        var a = new c.DERInteger({ bigint: d });
        var e2 = new c.DERSequence({ array: [b, a] });
        return e2.tohex();
      };
      KJUR.crypto.ECDSA.getName = function(a) {
        if (a === "2b8104001f") {
          return "secp192k1";
        }
        if (a === "2a8648ce3d030107") {
          return "secp256r1";
        }
        if (a === "2b8104000a") {
          return "secp256k1";
        }
        if (a === "2b81040021") {
          return "secp224r1";
        }
        if (a === "2b81040022") {
          return "secp384r1";
        }
        if (a === "2b81040023") {
          return "secp521r1";
        }
        if ("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a) !== -1) {
          return "secp256r1";
        }
        if ("|secp256k1|".indexOf(a) !== -1) {
          return "secp256k1";
        }
        if ("|secp224r1|NIST P-224|P-224|".indexOf(a) !== -1) {
          return "secp224r1";
        }
        if ("|secp384r1|NIST P-384|P-384|".indexOf(a) !== -1) {
          return "secp384r1";
        }
        if ("|secp521r1|NIST P-521|P-521|".indexOf(a) !== -1) {
          return "secp521r1";
        }
        return null;
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
        KJUR.crypto = {};
      }
      KJUR.crypto.ECParameterDB = new function() {
        var b = {};
        var c = {};
        function a(d) {
          return new BigInteger(d, 16);
        }
        this.getByName = function(e2) {
          var d = e2;
          if (typeof c[d] != "undefined") {
            d = c[e2];
          }
          if (typeof b[d] != "undefined") {
            return b[d];
          }
          throw "unregistered EC curve name: " + d;
        };
        this.regist = function(A, l, o2, g, m, e2, j, f, k, u, d, x) {
          b[A] = {};
          var s = a(o2);
          var z2 = a(g);
          var y = a(m);
          var t3 = a(e2);
          var w = a(j);
          var r2 = new ECCurveFp(s, z2, y);
          var q = r2.decodePointHex("04" + f + k);
          b[A]["name"] = A;
          b[A]["keylen"] = l;
          b[A]["keycharlen"] = Math.ceil(l / 8) * 2;
          b[A]["curve"] = r2;
          b[A]["G"] = q;
          b[A]["n"] = t3;
          b[A]["h"] = w;
          b[A]["oid"] = d;
          b[A]["info"] = x;
          for (var v = 0; v < u.length; v++) {
            c[u[v]] = A;
          }
        };
      }();
      KJUR.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field");
      KJUR.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field");
      KJUR.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field");
      KJUR.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []);
      KJUR.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []);
      KJUR.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []);
      KJUR.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []);
      KJUR.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", ["NIST P-256", "P-256", "prime256v1"]);
      KJUR.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", ["NIST P-384", "P-384"]);
      KJUR.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", ["NIST P-521", "P-521"]);
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
        KJUR.crypto = {};
      }
      KJUR.crypto.DSA = function() {
        var b = ASN1HEX, e2 = b.getVbyList, d = b.getVbyListEx, a = b.isASN1HEX, c = BigInteger;
        this.p = null;
        this.q = null;
        this.g = null;
        this.y = null;
        this.x = null;
        this.type = "DSA";
        this.isPrivate = false;
        this.isPublic = false;
        this.setPrivate = function(j, i, h, k, f) {
          this.isPrivate = true;
          this.p = j;
          this.q = i;
          this.g = h;
          this.y = k;
          this.x = f;
        };
        this.setPrivateHex = function(i, g, k, n2, o2) {
          var h, f, j, l, m;
          h = new BigInteger(i, 16);
          f = new BigInteger(g, 16);
          j = new BigInteger(k, 16);
          if (typeof n2 === "string" && n2.length > 1) {
            l = new BigInteger(n2, 16);
          } else {
            l = null;
          }
          m = new BigInteger(o2, 16);
          this.setPrivate(h, f, j, l, m);
        };
        this.setPublic = function(i, h, f, j) {
          this.isPublic = true;
          this.p = i;
          this.q = h;
          this.g = f;
          this.y = j;
          this.x = null;
        };
        this.setPublicHex = function(k, j, i, l) {
          var g, f, m, h;
          g = new BigInteger(k, 16);
          f = new BigInteger(j, 16);
          m = new BigInteger(i, 16);
          h = new BigInteger(l, 16);
          this.setPublic(g, f, m, h);
        };
        this.signWithMessageHash = function(j) {
          var i = this.p;
          var h = this.q;
          var m = this.g;
          var o2 = this.y;
          var t3 = this.x;
          var l = KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE), h.subtract(BigInteger.ONE));
          var u = j.substr(0, h.bitLength() / 4);
          var n2 = new BigInteger(u, 16);
          var f = m.modPow(l, i).mod(h);
          var w = l.modInverse(h).multiply(n2.add(t3.multiply(f))).mod(h);
          var v = KJUR.asn1.ASN1Util.jsonToASN1HEX({ seq: [{ "int": { bigint: f } }, { "int": { bigint: w } }] });
          return v;
        };
        this.verifyWithMessageHash = function(m, l) {
          var j = this.p;
          var h = this.q;
          var o2 = this.g;
          var u = this.y;
          var n2 = this.parseASN1Signature(l);
          var f = n2[0];
          var C = n2[1];
          var B = m.substr(0, h.bitLength() / 4);
          var t3 = new BigInteger(B, 16);
          if (BigInteger.ZERO.compareTo(f) > 0 || f.compareTo(h) > 0) {
            throw "invalid DSA signature";
          }
          if (BigInteger.ZERO.compareTo(C) >= 0 || C.compareTo(h) > 0) {
            throw "invalid DSA signature";
          }
          var x = C.modInverse(h);
          var k = t3.multiply(x).mod(h);
          var i = f.multiply(x).mod(h);
          var A = o2.modPow(k, j).multiply(u.modPow(i, j)).mod(j).mod(h);
          return A.compareTo(f) == 0;
        };
        this.parseASN1Signature = function(f) {
          try {
            var i = new c(d(f, 0, [0], "02"), 16);
            var h = new c(d(f, 0, [1], "02"), 16);
            return [i, h];
          } catch (g) {
            throw new Error("malformed ASN.1 DSA signature");
          }
        };
        this.readPKCS5PrvKeyHex = function(j) {
          var k, i, g, l, m;
          if (a(j) === false) {
            throw new Error("not ASN.1 hex string");
          }
          try {
            k = d(j, 0, [1], "02");
            i = d(j, 0, [2], "02");
            g = d(j, 0, [3], "02");
            l = d(j, 0, [4], "02");
            m = d(j, 0, [5], "02");
          } catch (f) {
            throw new Error("malformed PKCS#1/5 plain DSA private key");
          }
          this.setPrivateHex(k, i, g, l, m);
        };
        this.readPKCS8PrvKeyHex = function(j) {
          var k, i, g, l;
          if (a(j) === false) {
            throw new Error("not ASN.1 hex string");
          }
          try {
            k = d(j, 0, [1, 1, 0], "02");
            i = d(j, 0, [1, 1, 1], "02");
            g = d(j, 0, [1, 1, 2], "02");
            l = d(j, 0, [2, 0], "02");
          } catch (f) {
            throw new Error("malformed PKCS#8 plain DSA private key");
          }
          this.setPrivateHex(k, i, g, null, l);
        };
        this.readPKCS8PubKeyHex = function(j) {
          var k, i, g, l;
          if (a(j) === false) {
            throw new Error("not ASN.1 hex string");
          }
          try {
            k = d(j, 0, [0, 1, 0], "02");
            i = d(j, 0, [0, 1, 1], "02");
            g = d(j, 0, [0, 1, 2], "02");
            l = d(j, 0, [1, 0], "02");
          } catch (f) {
            throw new Error("malformed PKCS#8 DSA public key");
          }
          this.setPublicHex(k, i, g, l);
        };
        this.readCertPubKeyHex = function(j, m) {
          var k, i, g, l;
          if (a(j) === false) {
            throw new Error("not ASN.1 hex string");
          }
          try {
            k = d(j, 0, [0, 5, 0, 1, 0], "02");
            i = d(j, 0, [0, 5, 0, 1, 1], "02");
            g = d(j, 0, [0, 5, 0, 1, 2], "02");
            l = d(j, 0, [0, 5, 1, 0], "02");
          } catch (f) {
            throw new Error("malformed X.509 certificate DSA public key");
          }
          this.setPublicHex(k, i, g, l);
        };
      };
      var KEYUTIL = function() {
        var d = function(p, r2, q) {
          return k(CryptoJS.AES, p, r2, q);
        };
        var e2 = function(p, r2, q) {
          return k(CryptoJS.TripleDES, p, r2, q);
        };
        var a = function(p, r2, q) {
          return k(CryptoJS.DES, p, r2, q);
        };
        var k = function(s, x, u, q) {
          var r2 = CryptoJS.enc.Hex.parse(x);
          var w = CryptoJS.enc.Hex.parse(u);
          var p = CryptoJS.enc.Hex.parse(q);
          var t3 = {};
          t3.key = w;
          t3.iv = p;
          t3.ciphertext = r2;
          var v = s.decrypt(t3, w, { iv: p });
          return CryptoJS.enc.Hex.stringify(v);
        };
        var l = function(p, r2, q) {
          return g(CryptoJS.AES, p, r2, q);
        };
        var o2 = function(p, r2, q) {
          return g(CryptoJS.TripleDES, p, r2, q);
        };
        var f = function(p, r2, q) {
          return g(CryptoJS.DES, p, r2, q);
        };
        var g = function(t3, y, v, q) {
          var s = CryptoJS.enc.Hex.parse(y);
          var x = CryptoJS.enc.Hex.parse(v);
          var p = CryptoJS.enc.Hex.parse(q);
          var w = t3.encrypt(s, x, { iv: p });
          var r2 = CryptoJS.enc.Hex.parse(w.toString());
          var u = CryptoJS.enc.Base64.stringify(r2);
          return u;
        };
        var i = { "AES-256-CBC": { proc: d, eproc: l, keylen: 32, ivlen: 16 }, "AES-192-CBC": { proc: d, eproc: l, keylen: 24, ivlen: 16 }, "AES-128-CBC": { proc: d, eproc: l, keylen: 16, ivlen: 16 }, "DES-EDE3-CBC": { proc: e2, eproc: o2, keylen: 24, ivlen: 8 }, "DES-CBC": { proc: a, eproc: f, keylen: 8, ivlen: 8 } };
        var c = function(p) {
          return i[p]["proc"];
        };
        var m = function(p) {
          var r2 = CryptoJS.lib.WordArray.random(p);
          var q = CryptoJS.enc.Hex.stringify(r2);
          return q;
        };
        var n2 = function(v) {
          var w = {};
          var q = v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
          if (q) {
            w.cipher = q[1];
            w.ivsalt = q[2];
          }
          var p = v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
          if (p) {
            w.type = p[1];
          }
          var u = -1;
          var x = 0;
          if (v.indexOf("\r\n\r\n") != -1) {
            u = v.indexOf("\r\n\r\n");
            x = 2;
          }
          if (v.indexOf("\n\n") != -1) {
            u = v.indexOf("\n\n");
            x = 1;
          }
          var t3 = v.indexOf("-----END");
          if (u != -1 && t3 != -1) {
            var r2 = v.substring(u + x * 2, t3 - x);
            r2 = r2.replace(/\s+/g, "");
            w.data = r2;
          }
          return w;
        };
        var j = function(q, y, p) {
          var v = p.substring(0, 16);
          var t3 = CryptoJS.enc.Hex.parse(v);
          var r2 = CryptoJS.enc.Utf8.parse(y);
          var u = i[q]["keylen"] + i[q]["ivlen"];
          var x = "";
          var w = null;
          for (; ; ) {
            var s = CryptoJS.algo.MD5.create();
            if (w != null) {
              s.update(w);
            }
            s.update(r2);
            s.update(t3);
            w = s.finalize();
            x = x + CryptoJS.enc.Hex.stringify(w);
            if (x.length >= u * 2) {
              break;
            }
          }
          var z2 = {};
          z2.keyhex = x.substr(0, i[q]["keylen"] * 2);
          z2.ivhex = x.substr(i[q]["keylen"] * 2, i[q]["ivlen"] * 2);
          return z2;
        };
        var b = function(p, v, r2, w) {
          var s = CryptoJS.enc.Base64.parse(p);
          var q = CryptoJS.enc.Hex.stringify(s);
          var u = i[v]["proc"];
          var t3 = u(q, r2, w);
          return t3;
        };
        var h = function(p, s, q, u) {
          var r2 = i[s]["eproc"];
          var t3 = r2(p, q, u);
          return t3;
        };
        return { version: "1.0.0", parsePKCS5PEM: function(p) {
          return n2(p);
        }, getKeyAndUnusedIvByPasscodeAndIvsalt: function(q, p, r2) {
          return j(q, p, r2);
        }, decryptKeyB64: function(p, r2, q, s) {
          return b(p, r2, q, s);
        }, getDecryptedKeyHex: function(y, x) {
          var q = n2(y);
          var t3 = q.type;
          var r2 = q.cipher;
          var p = q.ivsalt;
          var s = q.data;
          var w = j(r2, x, p);
          var v = w.keyhex;
          var u = b(s, r2, v, p);
          return u;
        }, getEncryptedPKCS5PEMFromPrvKeyHex: function(x, s, A, t3, r2) {
          var p = "";
          if (typeof t3 == "undefined" || t3 == null) {
            t3 = "AES-256-CBC";
          }
          if (typeof i[t3] == "undefined") {
            throw new Error("KEYUTIL unsupported algorithm: " + t3);
          }
          if (typeof r2 == "undefined" || r2 == null) {
            var v = i[t3]["ivlen"];
            var u = m(v);
            r2 = u.toUpperCase();
          }
          var z2 = j(t3, A, r2);
          var y = z2.keyhex;
          var w = h(s, t3, y, r2);
          var q = w.replace(/(.{64})/g, "$1\r\n");
          var p = "-----BEGIN " + x + " PRIVATE KEY-----\r\n";
          p += "Proc-Type: 4,ENCRYPTED\r\n";
          p += "DEK-Info: " + t3 + "," + r2 + "\r\n";
          p += "\r\n";
          p += q;
          p += "\r\n-----END " + x + " PRIVATE KEY-----\r\n";
          return p;
        }, parseHexOfEncryptedPKCS8: function(y) {
          var B = ASN1HEX;
          var z2 = B.getChildIdx;
          var w = B.getV;
          var t3 = {};
          var r2 = z2(y, 0);
          if (r2.length != 2) {
            throw new Error("malformed format: SEQUENCE(0).items != 2: " + r2.length);
          }
          t3.ciphertext = w(y, r2[1]);
          var A = z2(y, r2[0]);
          if (A.length != 2) {
            throw new Error("malformed format: SEQUENCE(0.0).items != 2: " + A.length);
          }
          if (w(y, A[0]) != "2a864886f70d01050d") {
            throw new Error("this only supports pkcs5PBES2");
          }
          var p = z2(y, A[1]);
          if (A.length != 2) {
            throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: " + p.length);
          }
          var q = z2(y, p[1]);
          if (q.length != 2) {
            throw new Error("malformed format: SEQUENCE(0.0.1.1).items != 2: " + q.length);
          }
          if (w(y, q[0]) != "2a864886f70d0307") {
            throw "this only supports TripleDES";
          }
          t3.encryptionSchemeAlg = "TripleDES";
          t3.encryptionSchemeIV = w(y, q[1]);
          var s = z2(y, p[0]);
          if (s.length != 2) {
            throw new Error("malformed format: SEQUENCE(0.0.1.0).items != 2: " + s.length);
          }
          if (w(y, s[0]) != "2a864886f70d01050c") {
            throw new Error("this only supports pkcs5PBKDF2");
          }
          var x = z2(y, s[1]);
          if (x.length < 2) {
            throw new Error("malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + x.length);
          }
          t3.pbkdf2Salt = w(y, x[0]);
          var u = w(y, x[1]);
          try {
            t3.pbkdf2Iter = parseInt(u, 16);
          } catch (v) {
            throw new Error("malformed format pbkdf2Iter: " + u);
          }
          return t3;
        }, getPBKDF2KeyHexFromParam: function(u, p) {
          var t3 = CryptoJS.enc.Hex.parse(u.pbkdf2Salt);
          var q = u.pbkdf2Iter;
          var s = CryptoJS.PBKDF2(p, t3, { keySize: 192 / 32, iterations: q });
          var r2 = CryptoJS.enc.Hex.stringify(s);
          return r2;
        }, _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(x, y) {
          var r2 = pemtohex(x, "ENCRYPTED PRIVATE KEY");
          var p = this.parseHexOfEncryptedPKCS8(r2);
          var u = KEYUTIL.getPBKDF2KeyHexFromParam(p, y);
          var v = {};
          v.ciphertext = CryptoJS.enc.Hex.parse(p.ciphertext);
          var t3 = CryptoJS.enc.Hex.parse(u);
          var s = CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);
          var w = CryptoJS.TripleDES.decrypt(v, t3, { iv: s });
          var q = CryptoJS.enc.Hex.stringify(w);
          return q;
        }, getKeyFromEncryptedPKCS8PEM: function(s, q) {
          var p = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(s, q);
          var r2 = this.getKeyFromPlainPrivatePKCS8Hex(p);
          return r2;
        }, parsePlainPrivatePKCS8Hex: function(s) {
          var v = ASN1HEX;
          var u = v.getChildIdx;
          var t3 = v.getV;
          var q = {};
          q.algparam = null;
          if (s.substr(0, 2) != "30") {
            throw new Error("malformed plain PKCS8 private key(code:001)");
          }
          var r2 = u(s, 0);
          if (r2.length < 3) {
            throw new Error("malformed plain PKCS8 private key(code:002)");
          }
          if (s.substr(r2[1], 2) != "30") {
            throw new Error("malformed PKCS8 private key(code:003)");
          }
          var p = u(s, r2[1]);
          if (p.length != 2) {
            throw new Error("malformed PKCS8 private key(code:004)");
          }
          if (s.substr(p[0], 2) != "06") {
            throw new Error("malformed PKCS8 private key(code:005)");
          }
          q.algoid = t3(s, p[0]);
          if (s.substr(p[1], 2) == "06") {
            q.algparam = t3(s, p[1]);
          }
          if (s.substr(r2[2], 2) != "04") {
            throw new Error("malformed PKCS8 private key(code:006)");
          }
          q.keyidx = v.getVidx(s, r2[2]);
          return q;
        }, getKeyFromPlainPrivatePKCS8PEM: function(q) {
          var p = pemtohex(q, "PRIVATE KEY");
          var r2 = this.getKeyFromPlainPrivatePKCS8Hex(p);
          return r2;
        }, getKeyFromPlainPrivatePKCS8Hex: function(p) {
          var q = this.parsePlainPrivatePKCS8Hex(p);
          var r2;
          if (q.algoid == "2a864886f70d010101") {
            r2 = new RSAKey();
          } else {
            if (q.algoid == "2a8648ce380401") {
              r2 = new KJUR.crypto.DSA();
            } else {
              if (q.algoid == "2a8648ce3d0201") {
                r2 = new KJUR.crypto.ECDSA();
              } else {
                throw new Error("unsupported private key algorithm");
              }
            }
          }
          r2.readPKCS8PrvKeyHex(p);
          return r2;
        }, _getKeyFromPublicPKCS8Hex: function(q) {
          var p;
          var r2 = ASN1HEX.getVbyList(q, 0, [0, 0], "06");
          if (r2 === "2a864886f70d010101") {
            p = new RSAKey();
          } else {
            if (r2 === "2a8648ce380401") {
              p = new KJUR.crypto.DSA();
            } else {
              if (r2 === "2a8648ce3d0201") {
                p = new KJUR.crypto.ECDSA();
              } else {
                throw new Error("unsupported PKCS#8 public key hex");
              }
            }
          }
          p.readPKCS8PubKeyHex(q);
          return p;
        }, parsePublicRawRSAKeyHex: function(r2) {
          var u = ASN1HEX;
          var t3 = u.getChildIdx;
          var s = u.getV;
          var p = {};
          if (r2.substr(0, 2) != "30") {
            throw new Error("malformed RSA key(code:001)");
          }
          var q = t3(r2, 0);
          if (q.length != 2) {
            throw new Error("malformed RSA key(code:002)");
          }
          if (r2.substr(q[0], 2) != "02") {
            throw new Error("malformed RSA key(code:003)");
          }
          p.n = s(r2, q[0]);
          if (r2.substr(q[1], 2) != "02") {
            throw new Error("malformed RSA key(code:004)");
          }
          p.e = s(r2, q[1]);
          return p;
        }, parsePublicPKCS8Hex: function(t3) {
          var v = ASN1HEX;
          var u = v.getChildIdx;
          var s = v.getV;
          var q = {};
          q.algparam = null;
          var r2 = u(t3, 0);
          if (r2.length != 2) {
            throw new Error("outer DERSequence shall have 2 elements: " + r2.length);
          }
          var w = r2[0];
          if (t3.substr(w, 2) != "30") {
            throw new Error("malformed PKCS8 public key(code:001)");
          }
          var p = u(t3, w);
          if (p.length != 2) {
            throw new Error("malformed PKCS8 public key(code:002)");
          }
          if (t3.substr(p[0], 2) != "06") {
            throw new Error("malformed PKCS8 public key(code:003)");
          }
          q.algoid = s(t3, p[0]);
          if (t3.substr(p[1], 2) == "06") {
            q.algparam = s(t3, p[1]);
          } else {
            if (t3.substr(p[1], 2) == "30") {
              q.algparam = {};
              q.algparam.p = v.getVbyList(t3, p[1], [0], "02");
              q.algparam.q = v.getVbyList(t3, p[1], [1], "02");
              q.algparam.g = v.getVbyList(t3, p[1], [2], "02");
            }
          }
          if (t3.substr(r2[1], 2) != "03") {
            throw new Error("malformed PKCS8 public key(code:004)");
          }
          q.key = s(t3, r2[1]).substr(2);
          return q;
        } };
      }();
      KEYUTIL.getKey = function(l, k, n2) {
        var G = ASN1HEX, L = G.getChildIdx, v = G.getV, d = G.getVbyList, c = KJUR.crypto, i = c.ECDSA, C = c.DSA, w = RSAKey, M = pemtohex, F = KEYUTIL;
        if (typeof w != "undefined" && l instanceof w) {
          return l;
        }
        if (typeof i != "undefined" && l instanceof i) {
          return l;
        }
        if (typeof C != "undefined" && l instanceof C) {
          return l;
        }
        if (l.curve !== void 0 && l.xy !== void 0 && l.d === void 0) {
          return new i({ pub: l.xy, curve: l.curve });
        }
        if (l.curve !== void 0 && l.d !== void 0) {
          return new i({ prv: l.d, curve: l.curve });
        }
        if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d === void 0) {
          var P = new w();
          P.setPublic(l.n, l.e);
          return P;
        }
        if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p !== void 0 && l.q !== void 0 && l.dp !== void 0 && l.dq !== void 0 && l.co !== void 0 && l.qi === void 0) {
          var P = new w();
          P.setPrivateEx(l.n, l.e, l.d, l.p, l.q, l.dp, l.dq, l.co);
          return P;
        }
        if (l.kty === void 0 && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p === void 0) {
          var P = new w();
          P.setPrivate(l.n, l.e, l.d);
          return P;
        }
        if (l.p !== void 0 && l.q !== void 0 && l.g !== void 0 && l.y !== void 0 && l.x === void 0) {
          var P = new C();
          P.setPublic(l.p, l.q, l.g, l.y);
          return P;
        }
        if (l.p !== void 0 && l.q !== void 0 && l.g !== void 0 && l.y !== void 0 && l.x !== void 0) {
          var P = new C();
          P.setPrivate(l.p, l.q, l.g, l.y, l.x);
          return P;
        }
        if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d === void 0) {
          var P = new w();
          P.setPublic(b64utohex(l.n), b64utohex(l.e));
          return P;
        }
        if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d !== void 0 && l.p !== void 0 && l.q !== void 0 && l.dp !== void 0 && l.dq !== void 0 && l.qi !== void 0) {
          var P = new w();
          P.setPrivateEx(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d), b64utohex(l.p), b64utohex(l.q), b64utohex(l.dp), b64utohex(l.dq), b64utohex(l.qi));
          return P;
        }
        if (l.kty === "RSA" && l.n !== void 0 && l.e !== void 0 && l.d !== void 0) {
          var P = new w();
          P.setPrivate(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d));
          return P;
        }
        if (l.kty === "EC" && l.crv !== void 0 && l.x !== void 0 && l.y !== void 0 && l.d === void 0) {
          var j = new i({ curve: l.crv });
          var t3 = j.ecparams.keycharlen;
          var B = ("0000000000" + b64utohex(l.x)).slice(-t3);
          var z2 = ("0000000000" + b64utohex(l.y)).slice(-t3);
          var u = "04" + B + z2;
          j.setPublicKeyHex(u);
          return j;
        }
        if (l.kty === "EC" && l.crv !== void 0 && l.x !== void 0 && l.y !== void 0 && l.d !== void 0) {
          var j = new i({ curve: l.crv });
          var t3 = j.ecparams.keycharlen;
          var B = ("0000000000" + b64utohex(l.x)).slice(-t3);
          var z2 = ("0000000000" + b64utohex(l.y)).slice(-t3);
          var u = "04" + B + z2;
          var b = ("0000000000" + b64utohex(l.d)).slice(-t3);
          j.setPublicKeyHex(u);
          j.setPrivateKeyHex(b);
          return j;
        }
        if (n2 === "pkcs5prv") {
          var J = l, G = ASN1HEX, N, P;
          N = L(J, 0);
          if (N.length === 9) {
            P = new w();
            P.readPKCS5PrvKeyHex(J);
          } else {
            if (N.length === 6) {
              P = new C();
              P.readPKCS5PrvKeyHex(J);
            } else {
              if (N.length > 2 && J.substr(N[1], 2) === "04") {
                P = new i();
                P.readPKCS5PrvKeyHex(J);
              } else {
                throw new Error("unsupported PKCS#1/5 hexadecimal key");
              }
            }
          }
          return P;
        }
        if (n2 === "pkcs8prv") {
          var P = F.getKeyFromPlainPrivatePKCS8Hex(l);
          return P;
        }
        if (n2 === "pkcs8pub") {
          return F._getKeyFromPublicPKCS8Hex(l);
        }
        if (n2 === "x509pub") {
          return X509.getPublicKeyFromCertHex(l);
        }
        if (l.indexOf("-END CERTIFICATE-", 0) != -1 || l.indexOf("-END X509 CERTIFICATE-", 0) != -1 || l.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1) {
          return X509.getPublicKeyFromCertPEM(l);
        }
        if (l.indexOf("-END PUBLIC KEY-") != -1) {
          var O = pemtohex(l, "PUBLIC KEY");
          return F._getKeyFromPublicPKCS8Hex(O);
        }
        if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
          var m = M(l, "RSA PRIVATE KEY");
          return F.getKey(m, null, "pkcs5prv");
        }
        if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
          var I = M(l, "DSA PRIVATE KEY");
          var E = d(I, 0, [1], "02");
          var D = d(I, 0, [2], "02");
          var K = d(I, 0, [3], "02");
          var r2 = d(I, 0, [4], "02");
          var s = d(I, 0, [5], "02");
          var P = new C();
          P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r2, 16), new BigInteger(s, 16));
          return P;
        }
        if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
          var m = M(l, "EC PRIVATE KEY");
          return F.getKey(m, null, "pkcs5prv");
        }
        if (l.indexOf("-END PRIVATE KEY-") != -1) {
          return F.getKeyFromPlainPrivatePKCS8PEM(l);
        }
        if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
          var o2 = F.getDecryptedKeyHex(l, k);
          var H = new RSAKey();
          H.readPKCS5PrvKeyHex(o2);
          return H;
        }
        if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
          var I = F.getDecryptedKeyHex(l, k);
          var P = d(I, 0, [1], "04");
          var f = d(I, 0, [2, 0], "06");
          var A = d(I, 0, [3, 0], "03").substr(2);
          var e2 = "";
          if (KJUR.crypto.OID.oidhex2name[f] !== void 0) {
            e2 = KJUR.crypto.OID.oidhex2name[f];
          } else {
            throw new Error("undefined OID(hex) in KJUR.crypto.OID: " + f);
          }
          var j = new i({ curve: e2 });
          j.setPublicKeyHex(A);
          j.setPrivateKeyHex(P);
          j.isPublic = false;
          return j;
        }
        if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
          var I = F.getDecryptedKeyHex(l, k);
          var E = d(I, 0, [1], "02");
          var D = d(I, 0, [2], "02");
          var K = d(I, 0, [3], "02");
          var r2 = d(I, 0, [4], "02");
          var s = d(I, 0, [5], "02");
          var P = new C();
          P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r2, 16), new BigInteger(s, 16));
          return P;
        }
        if (l.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1) {
          return F.getKeyFromEncryptedPKCS8PEM(l, k);
        }
        throw new Error("not supported argument");
      };
      KEYUTIL.generateKeypair = function(a, c) {
        if (a == "RSA") {
          var b = c;
          var h = new RSAKey();
          h.generate(b, "10001");
          h.isPrivate = true;
          h.isPublic = true;
          var f = new RSAKey();
          var e2 = h.n.toString(16);
          var i = h.e.toString(16);
          f.setPublic(e2, i);
          f.isPrivate = false;
          f.isPublic = true;
          var k = {};
          k.prvKeyObj = h;
          k.pubKeyObj = f;
          return k;
        } else {
          if (a == "EC") {
            var d = c;
            var g = new KJUR.crypto.ECDSA({ curve: d });
            var j = g.generateKeyPairHex();
            var h = new KJUR.crypto.ECDSA({ curve: d });
            h.setPublicKeyHex(j.ecpubhex);
            h.setPrivateKeyHex(j.ecprvhex);
            h.isPrivate = true;
            h.isPublic = false;
            var f = new KJUR.crypto.ECDSA({ curve: d });
            f.setPublicKeyHex(j.ecpubhex);
            f.isPrivate = false;
            f.isPublic = true;
            var k = {};
            k.prvKeyObj = h;
            k.pubKeyObj = f;
            return k;
          } else {
            throw new Error("unknown algorithm: " + a);
          }
        }
      };
      KEYUTIL.getPEM = function(b, D, y, m, q, j) {
        var F = KJUR, k = F.asn1, z2 = k.DERObjectIdentifier, f = k.DERInteger, l = k.ASN1Util.newObject, a = k.x509, C = a.SubjectPublicKeyInfo, e2 = F.crypto, u = e2.DSA, r2 = e2.ECDSA, n2 = RSAKey;
        function A(s) {
          var H = l({ seq: [{ "int": 0 }, { "int": { bigint: s.n } }, { "int": s.e }, { "int": { bigint: s.d } }, { "int": { bigint: s.p } }, { "int": { bigint: s.q } }, { "int": { bigint: s.dmp1 } }, { "int": { bigint: s.dmq1 } }, { "int": { bigint: s.coeff } }] });
          return H;
        }
        function B(H) {
          var s = l({ seq: [{ "int": 1 }, { octstr: { hex: H.prvKeyHex } }, { tag: ["a0", true, { oid: { name: H.curveName } }] }, { tag: ["a1", true, { bitstr: { hex: "00" + H.pubKeyHex } }] }] });
          return s;
        }
        function x(s) {
          var H = l({ seq: [{ "int": 0 }, { "int": { bigint: s.p } }, { "int": { bigint: s.q } }, { "int": { bigint: s.g } }, { "int": { bigint: s.y } }, { "int": { bigint: s.x } }] });
          return H;
        }
        if ((n2 !== void 0 && b instanceof n2 || u !== void 0 && b instanceof u || r2 !== void 0 && b instanceof r2) && b.isPublic == true && (D === void 0 || D == "PKCS8PUB")) {
          var E = new C(b);
          var w = E.tohex();
          return hextopem(w, "PUBLIC KEY");
        }
        if (D == "PKCS1PRV" && n2 !== void 0 && b instanceof n2 && (y === void 0 || y == null) && b.isPrivate == true) {
          var E = A(b);
          var w = E.tohex();
          return hextopem(w, "RSA PRIVATE KEY");
        }
        if (D == "PKCS1PRV" && r2 !== void 0 && b instanceof r2 && (y === void 0 || y == null) && b.isPrivate == true) {
          var i = new z2({ name: b.curveName });
          var v = i.tohex();
          var h = B(b);
          var t3 = h.tohex();
          var p = "";
          p += hextopem(v, "EC PARAMETERS");
          p += hextopem(t3, "EC PRIVATE KEY");
          return p;
        }
        if (D == "PKCS1PRV" && u !== void 0 && b instanceof u && (y === void 0 || y == null) && b.isPrivate == true) {
          var E = x(b);
          var w = E.tohex();
          return hextopem(w, "DSA PRIVATE KEY");
        }
        if (D == "PKCS5PRV" && n2 !== void 0 && b instanceof n2 && (y !== void 0 && y != null) && b.isPrivate == true) {
          var E = A(b);
          var w = E.tohex();
          if (m === void 0) {
            m = "DES-EDE3-CBC";
          }
          return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", w, y, m, j);
        }
        if (D == "PKCS5PRV" && r2 !== void 0 && b instanceof r2 && (y !== void 0 && y != null) && b.isPrivate == true) {
          var E = B(b);
          var w = E.tohex();
          if (m === void 0) {
            m = "DES-EDE3-CBC";
          }
          return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", w, y, m, j);
        }
        if (D == "PKCS5PRV" && u !== void 0 && b instanceof u && (y !== void 0 && y != null) && b.isPrivate == true) {
          var E = x(b);
          var w = E.tohex();
          if (m === void 0) {
            m = "DES-EDE3-CBC";
          }
          return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", w, y, m, j);
        }
        var o2 = function(H, s) {
          var J = c(H, s);
          var I = new l({ seq: [{ seq: [{ oid: { name: "pkcs5PBES2" } }, { seq: [{ seq: [{ oid: { name: "pkcs5PBKDF2" } }, { seq: [{ octstr: { hex: J.pbkdf2Salt } }, { "int": J.pbkdf2Iter }] }] }, { seq: [{ oid: { name: "des-EDE3-CBC" } }, { octstr: { hex: J.encryptionSchemeIV } }] }] }] }, { octstr: { hex: J.ciphertext } }] });
          return I.tohex();
        };
        var c = function(O, P) {
          var I = 100;
          var N = CryptoJS.lib.WordArray.random(8);
          var M = "DES-EDE3-CBC";
          var s = CryptoJS.lib.WordArray.random(8);
          var J = CryptoJS.PBKDF2(P, N, { keySize: 192 / 32, iterations: I });
          var K = CryptoJS.enc.Hex.parse(O);
          var L = CryptoJS.TripleDES.encrypt(K, J, { iv: s }) + "";
          var H = {};
          H.ciphertext = L;
          H.pbkdf2Salt = CryptoJS.enc.Hex.stringify(N);
          H.pbkdf2Iter = I;
          H.encryptionSchemeAlg = M;
          H.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(s);
          return H;
        };
        if (D == "PKCS8PRV" && n2 != void 0 && b instanceof n2 && b.isPrivate == true) {
          var g = A(b);
          var d = g.tohex();
          var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "rsaEncryption" } }, { "null": true }] }, { octstr: { hex: d } }] });
          var w = E.tohex();
          if (y === void 0 || y == null) {
            return hextopem(w, "PRIVATE KEY");
          } else {
            var t3 = o2(w, y);
            return hextopem(t3, "ENCRYPTED PRIVATE KEY");
          }
        }
        if (D == "PKCS8PRV" && r2 !== void 0 && b instanceof r2 && b.isPrivate == true) {
          var G = { seq: [{ "int": 1 }, { octstr: { hex: b.prvKeyHex } }] };
          if (typeof b.pubKeyHex == "string") {
            G.seq.push({ tag: ["a1", true, { bitstr: { hex: "00" + b.pubKeyHex } }] });
          }
          var g = new l(G);
          var d = g.tohex();
          var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "ecPublicKey" } }, { oid: { name: b.curveName } }] }, { octstr: { hex: d } }] });
          var w = E.tohex();
          if (y === void 0 || y == null) {
            return hextopem(w, "PRIVATE KEY");
          } else {
            var t3 = o2(w, y);
            return hextopem(t3, "ENCRYPTED PRIVATE KEY");
          }
        }
        if (D == "PKCS8PRV" && u !== void 0 && b instanceof u && b.isPrivate == true) {
          var g = new f({ bigint: b.x });
          var d = g.tohex();
          var E = l({ seq: [{ "int": 0 }, { seq: [{ oid: { name: "dsa" } }, { seq: [{ "int": { bigint: b.p } }, { "int": { bigint: b.q } }, { "int": { bigint: b.g } }] }] }, { octstr: { hex: d } }] });
          var w = E.tohex();
          if (y === void 0 || y == null) {
            return hextopem(w, "PRIVATE KEY");
          } else {
            var t3 = o2(w, y);
            return hextopem(t3, "ENCRYPTED PRIVATE KEY");
          }
        }
        throw new Error("unsupported object nor format");
      };
      KEYUTIL.getKeyFromCSRPEM = function(b) {
        var a = pemtohex(b, "CERTIFICATE REQUEST");
        var c = KEYUTIL.getKeyFromCSRHex(a);
        return c;
      };
      KEYUTIL.getKeyFromCSRHex = function(a) {
        var c = KEYUTIL.parseCSRHex(a);
        var b = KEYUTIL.getKey(c.p8pubkeyhex, null, "pkcs8pub");
        return b;
      };
      KEYUTIL.parseCSRHex = function(d) {
        var i = ASN1HEX;
        var f = i.getChildIdx;
        var c = i.getTLV;
        var b = {};
        var g = d;
        if (g.substr(0, 2) != "30") {
          throw new Error("malformed CSR(code:001)");
        }
        var e2 = f(g, 0);
        if (e2.length < 1) {
          throw new Error("malformed CSR(code:002)");
        }
        if (g.substr(e2[0], 2) != "30") {
          throw new Error("malformed CSR(code:003)");
        }
        var a = f(g, e2[0]);
        if (a.length < 3) {
          throw new Error("malformed CSR(code:004)");
        }
        b.p8pubkeyhex = c(g, a[2]);
        return b;
      };
      KEYUTIL.getKeyID = function(f) {
        var c = KEYUTIL;
        var e2 = ASN1HEX;
        if (typeof f === "string" && f.indexOf("BEGIN ") != -1) {
          f = c.getKey(f);
        }
        var d = pemtohex(c.getPEM(f));
        var b = e2.getIdxbyList(d, 0, [1]);
        var a = e2.getV(d, b).substring(2);
        return KJUR.crypto.Util.hashHex(a, "sha1");
      };
      KEYUTIL.getJWK = function(d, h, g, b, f) {
        var i;
        var k = {};
        var e2;
        var c = KJUR.crypto.Util.hashHex;
        if (typeof d == "string") {
          i = KEYUTIL.getKey(d);
          if (d.indexOf("CERTIFICATE") != -1) {
            e2 = pemtohex(d);
          }
        } else {
          if (typeof d == "object") {
            if (d instanceof X509) {
              i = d.getPublicKey();
              e2 = d.hex;
            } else {
              i = d;
            }
          } else {
            throw new Error("unsupported keyinfo type");
          }
        }
        if (i instanceof RSAKey && i.isPrivate) {
          k.kty = "RSA";
          k.n = hextob64u(i.n.toString(16));
          k.e = hextob64u(i.e.toString(16));
          k.d = hextob64u(i.d.toString(16));
          k.p = hextob64u(i.p.toString(16));
          k.q = hextob64u(i.q.toString(16));
          k.dp = hextob64u(i.dmp1.toString(16));
          k.dq = hextob64u(i.dmq1.toString(16));
          k.qi = hextob64u(i.coeff.toString(16));
        } else {
          if (i instanceof RSAKey && i.isPublic) {
            k.kty = "RSA";
            k.n = hextob64u(i.n.toString(16));
            k.e = hextob64u(i.e.toString(16));
          } else {
            if (i instanceof KJUR.crypto.ECDSA && i.isPrivate) {
              var a = i.getShortNISTPCurveName();
              if (a !== "P-256" && a !== "P-384" && a !== "P-521") {
                throw new Error("unsupported curve name for JWT: " + a);
              }
              var j = i.getPublicKeyXYHex();
              k.kty = "EC";
              k.crv = a;
              k.x = hextob64u(j.x);
              k.y = hextob64u(j.y);
              k.d = hextob64u(i.prvKeyHex);
            } else {
              if (i instanceof KJUR.crypto.ECDSA && i.isPublic) {
                var a = i.getShortNISTPCurveName();
                if (a !== "P-256" && a !== "P-384" && a !== "P-521") {
                  throw new Error("unsupported curve name for JWT: " + a);
                }
                var j = i.getPublicKeyXYHex();
                k.kty = "EC";
                k.crv = a;
                k.x = hextob64u(j.x);
                k.y = hextob64u(j.y);
              }
            }
          }
        }
        if (k.kty == void 0) {
          throw new Error("unsupported keyinfo");
        }
        if (!i.isPrivate && h != true) {
          k.kid = KJUR.jws.JWS.getJWKthumbprint(k);
        }
        if (e2 != void 0 && g != true) {
          k.x5c = [hex2b64(e2)];
        }
        if (e2 != void 0 && b != true) {
          k.x5t = b64tob64u(hex2b64(c(e2, "sha1")));
        }
        if (e2 != void 0 && f != true) {
          k["x5t#S256"] = b64tob64u(hex2b64(c(e2, "sha256")));
        }
        return k;
      };
      KEYUTIL.getJWKFromKey = function(a) {
        return KEYUTIL.getJWK(a, true, true, true, true);
      };
      RSAKey.getPosArrayOfChildrenFromHex = function(a) {
        return ASN1HEX.getChildIdx(a, 0);
      };
      RSAKey.getHexValueArrayOfChildrenFromHex = function(f) {
        var n2 = ASN1HEX;
        var i = n2.getV;
        var k = RSAKey.getPosArrayOfChildrenFromHex(f);
        var e2 = i(f, k[0]);
        var j = i(f, k[1]);
        var b = i(f, k[2]);
        var c = i(f, k[3]);
        var h = i(f, k[4]);
        var g = i(f, k[5]);
        var m = i(f, k[6]);
        var l = i(f, k[7]);
        var d = i(f, k[8]);
        var k = new Array();
        k.push(e2, j, b, c, h, g, m, l, d);
        return k;
      };
      RSAKey.prototype.readPrivateKeyFromPEMString = function(d) {
        var c = pemtohex(d);
        var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
        this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
      };
      RSAKey.prototype.readPKCS5PrvKeyHex = function(c) {
        var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
        this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
      };
      RSAKey.prototype.readPKCS8PrvKeyHex = function(e2) {
        var c, i, k, b, a, f, d, j;
        var m = ASN1HEX;
        var l = m.getVbyListEx;
        if (m.isASN1HEX(e2) === false) {
          throw new Error("not ASN.1 hex string");
        }
        try {
          c = l(e2, 0, [2, 0, 1], "02");
          i = l(e2, 0, [2, 0, 2], "02");
          k = l(e2, 0, [2, 0, 3], "02");
          b = l(e2, 0, [2, 0, 4], "02");
          a = l(e2, 0, [2, 0, 5], "02");
          f = l(e2, 0, [2, 0, 6], "02");
          d = l(e2, 0, [2, 0, 7], "02");
          j = l(e2, 0, [2, 0, 8], "02");
        } catch (g) {
          throw new Error("malformed PKCS#8 plain RSA private key");
        }
        this.setPrivateEx(c, i, k, b, a, f, d, j);
      };
      RSAKey.prototype.readPKCS5PubKeyHex = function(c) {
        var e2 = ASN1HEX;
        var b = e2.getV;
        if (e2.isASN1HEX(c) === false) {
          throw new Error("keyHex is not ASN.1 hex string");
        }
        var a = e2.getChildIdx(c, 0);
        if (a.length !== 2 || c.substr(a[0], 2) !== "02" || c.substr(a[1], 2) !== "02") {
          throw new Error("wrong hex for PKCS#5 public key");
        }
        var f = b(c, a[0]);
        var d = b(c, a[1]);
        this.setPublic(f, d);
      };
      RSAKey.prototype.readPKCS8PubKeyHex = function(b) {
        var c = ASN1HEX;
        if (c.isASN1HEX(b) === false) {
          throw new Error("not ASN.1 hex string");
        }
        if (c.getTLVbyListEx(b, 0, [0, 0]) !== "06092a864886f70d010101") {
          throw new Error("not PKCS8 RSA public key");
        }
        var a = c.getTLVbyListEx(b, 0, [1, 0]);
        this.readPKCS5PubKeyHex(a);
      };
      RSAKey.prototype.readCertPubKeyHex = function(b, d) {
        var a, c;
        a = new X509();
        a.readCertHex(b);
        c = a.getPublicKeyHex();
        this.readPKCS8PubKeyHex(c);
      };
      var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");
      function _zeroPaddingOfSignature(e2, d) {
        var c = "";
        var a = d / 4 - e2.length;
        for (var b = 0; b < a; b++) {
          c = c + "0";
        }
        return c + e2;
      }
      RSAKey.prototype.sign = function(d, a) {
        var b = function(e2) {
          return KJUR.crypto.Util.hashString(e2, a);
        };
        var c = b(d);
        return this.signWithMessageHash(c, a);
      };
      RSAKey.prototype.signWithMessageHash = function(e2, c) {
        var f = KJUR.crypto.Util.getPaddedDigestInfoHex(e2, c, this.n.bitLength());
        var b = parseBigInt(f, 16);
        var d = this.doPrivate(b);
        var a = d.toString(16);
        return _zeroPaddingOfSignature(a, this.n.bitLength());
      };
      function pss_mgf1_str(c, a, e2) {
        var b = "", d = 0;
        while (b.length < a) {
          b += hextorstr(e2(rstrtohex(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]))));
          d += 1;
        }
        return b;
      }
      RSAKey.prototype.signPSS = function(e2, a, d) {
        var c = function(f) {
          return KJUR.crypto.Util.hashHex(f, a);
        };
        var b = c(rstrtohex(e2));
        if (d === void 0) {
          d = -1;
        }
        return this.signWithMessageHashPSS(b, a, d);
      };
      RSAKey.prototype.signWithMessageHashPSS = function(l, a, k) {
        var b = hextorstr(l);
        var g = b.length;
        var m = this.n.bitLength() - 1;
        var c = Math.ceil(m / 8);
        var d;
        var o2 = function(i) {
          return KJUR.crypto.Util.hashHex(i, a);
        };
        if (k === -1 || k === void 0) {
          k = g;
        } else {
          if (k === -2) {
            k = c - g - 2;
          } else {
            if (k < -2) {
              throw new Error("invalid salt length");
            }
          }
        }
        if (c < g + k + 2) {
          throw new Error("data too long");
        }
        var f = "";
        if (k > 0) {
          f = new Array(k);
          new SecureRandom().nextBytes(f);
          f = String.fromCharCode.apply(String, f);
        }
        var n2 = hextorstr(o2(rstrtohex("\0\0\0\0\0\0\0\0" + b + f)));
        var j = [];
        for (d = 0; d < c - k - g - 2; d += 1) {
          j[d] = 0;
        }
        var e2 = String.fromCharCode.apply(String, j) + "" + f;
        var h = pss_mgf1_str(n2, e2.length, o2);
        var q = [];
        for (d = 0; d < e2.length; d += 1) {
          q[d] = e2.charCodeAt(d) ^ h.charCodeAt(d);
        }
        var p = 65280 >> 8 * c - m & 255;
        q[0] &= ~p;
        for (d = 0; d < g; d++) {
          q.push(n2.charCodeAt(d));
        }
        q.push(188);
        return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16), this.n.bitLength());
      };
      function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f) {
        for (var e2 in KJUR.crypto.Util.DIGESTINFOHEAD) {
          var d = KJUR.crypto.Util.DIGESTINFOHEAD[e2];
          var b = d.length;
          if (f.substring(0, b) == d) {
            var c = [e2, f.substring(b)];
            return c;
          }
        }
        return [];
      }
      RSAKey.prototype.verify = function(f, l) {
        l = l.toLowerCase();
        if (l.match(/^[0-9a-f]+$/) == null) {
          return false;
        }
        var b = parseBigInt(l, 16);
        var k = this.n.bitLength();
        if (b.bitLength() > k) {
          return false;
        }
        var j = this.doPublic(b);
        var i = j.toString(16);
        if (i.length + 3 != k / 4) {
          return false;
        }
        var e2 = i.replace(/^1f+00/, "");
        var g = _rsasign_getAlgNameAndHashFromHexDisgestInfo(e2);
        if (g.length == 0) {
          return false;
        }
        var d = g[0];
        var h = g[1];
        var a = function(m) {
          return KJUR.crypto.Util.hashString(m, d);
        };
        var c = a(f);
        return h == c;
      };
      RSAKey.prototype.verifyWithMessageHash = function(e2, a) {
        if (a.length != Math.ceil(this.n.bitLength() / 4)) {
          return false;
        }
        var b = parseBigInt(a, 16);
        if (b.bitLength() > this.n.bitLength()) {
          return 0;
        }
        var h = this.doPublic(b);
        var g = h.toString(16).replace(/^1f+00/, "");
        var c = _rsasign_getAlgNameAndHashFromHexDisgestInfo(g);
        if (c.length == 0) {
          return false;
        }
        var d = c[0];
        var f = c[1];
        return f == e2;
      };
      RSAKey.prototype.verifyPSS = function(c, b, a, f) {
        var e2 = function(g) {
          return KJUR.crypto.Util.hashHex(g, a);
        };
        var d = e2(rstrtohex(c));
        if (f === void 0) {
          f = -1;
        }
        return this.verifyWithMessageHashPSS(d, b, a, f);
      };
      RSAKey.prototype.verifyWithMessageHashPSS = function(f, s, l, c) {
        if (s.length != Math.ceil(this.n.bitLength() / 4)) {
          return false;
        }
        var k = new BigInteger(s, 16);
        var r2 = function(i) {
          return KJUR.crypto.Util.hashHex(i, l);
        };
        var j = hextorstr(f);
        var h = j.length;
        var g = this.n.bitLength() - 1;
        var m = Math.ceil(g / 8);
        var q;
        if (c === -1 || c === void 0) {
          c = h;
        } else {
          if (c === -2) {
            c = m - h - 2;
          } else {
            if (c < -2) {
              throw new Error("invalid salt length");
            }
          }
        }
        if (m < h + c + 2) {
          throw new Error("data too long");
        }
        var a = this.doPublic(k).toByteArray();
        for (q = 0; q < a.length; q += 1) {
          a[q] &= 255;
        }
        while (a.length < m) {
          a.unshift(0);
        }
        if (a[m - 1] !== 188) {
          throw new Error("encoded message does not end in 0xbc");
        }
        a = String.fromCharCode.apply(String, a);
        var d = a.substr(0, m - h - 1);
        var e2 = a.substr(d.length, h);
        var p = 65280 >> 8 * m - g & 255;
        if ((d.charCodeAt(0) & p) !== 0) {
          throw new Error("bits beyond keysize not zero");
        }
        var n2 = pss_mgf1_str(e2, d.length, r2);
        var o2 = [];
        for (q = 0; q < d.length; q += 1) {
          o2[q] = d.charCodeAt(q) ^ n2.charCodeAt(q);
        }
        o2[0] &= ~p;
        var b = m - h - c - 2;
        for (q = 0; q < b; q += 1) {
          if (o2[q] !== 0) {
            throw new Error("leftmost octets not zero");
          }
        }
        if (o2[b] !== 1) {
          throw new Error("0x01 marker not found");
        }
        return e2 === hextorstr(r2(rstrtohex("\0\0\0\0\0\0\0\0" + j + String.fromCharCode.apply(String, o2.slice(-c)))));
      };
      RSAKey.SALT_LEN_HLEN = -1;
      RSAKey.SALT_LEN_MAX = -2;
      RSAKey.SALT_LEN_RECOVER = -2;
      function X509(v) {
        var o2 = ASN1HEX, s = o2.getChildIdx, k = o2.getV, y = o2.dump, j = o2.parse, b = o2.getTLV, c = o2.getVbyList, p = o2.getVbyListEx, a = o2.getTLVbyList, q = o2.getTLVbyListEx, l = o2.getIdxbyList, f = o2.getIdxbyListEx, n2 = o2.getVidx, x = o2.getInt, u = o2.oidname, r2 = o2.hextooidstr, d = X509, w = pemtohex, g, m = Error;
        try {
          g = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
        } catch (t3) {
        }
        this.HEX2STAG = { "0c": "utf8", "13": "prn", "16": "ia5", "1a": "vis", "1e": "bmp" };
        this.hex = null;
        this.version = 0;
        this.foffset = 0;
        this.aExtInfo = null;
        this.getVersion = function() {
          if (this.hex === null || this.version !== 0) {
            return this.version;
          }
          var A = a(this.hex, 0, [0, 0]);
          if (A.substr(0, 2) == "a0") {
            var B = a(A, 0, [0]);
            var z2 = x(B, 0);
            if (z2 < 0 || 2 < z2) {
              throw new Error("malformed version field");
            }
            this.version = z2 + 1;
            return this.version;
          } else {
            this.version = 1;
            this.foffset = -1;
            return 1;
          }
        };
        this.getSerialNumberHex = function() {
          return p(this.hex, 0, [0, 0], "02");
        };
        this.getSignatureAlgorithmField = function() {
          var z2 = q(this.hex, 0, [0, 1]);
          return this.getAlgorithmIdentifierName(z2);
        };
        this.getAlgorithmIdentifierName = function(z2) {
          for (var A in g) {
            if (z2 === g[A]) {
              return A;
            }
          }
          return u(p(z2, 0, [0], "06"));
        };
        this.getIssuer = function(A, z2) {
          return this.getX500Name(this.getIssuerHex(), A, z2);
        };
        this.getIssuerHex = function() {
          return a(this.hex, 0, [0, 3 + this.foffset], "30");
        };
        this.getIssuerString = function() {
          var z2 = this.getIssuer();
          return z2.str;
        };
        this.getSubject = function(A, z2) {
          return this.getX500Name(this.getSubjectHex(), A, z2);
        };
        this.getSubjectHex = function() {
          return a(this.hex, 0, [0, 5 + this.foffset], "30");
        };
        this.getSubjectString = function() {
          var z2 = this.getSubject();
          return z2.str;
        };
        this.getNotBefore = function() {
          var z2 = c(this.hex, 0, [0, 4 + this.foffset, 0]);
          z2 = z2.replace(/(..)/g, "%$1");
          z2 = decodeURIComponent(z2);
          return z2;
        };
        this.getNotAfter = function() {
          var z2 = c(this.hex, 0, [0, 4 + this.foffset, 1]);
          z2 = z2.replace(/(..)/g, "%$1");
          z2 = decodeURIComponent(z2);
          return z2;
        };
        this.getPublicKeyHex = function() {
          return this.getSPKI();
        };
        this.getSPKI = function() {
          return a(this.hex, 0, [0, 6 + this.foffset], "30");
        };
        this.getSPKIValue = function() {
          var z2 = this.getSPKI();
          if (z2 == null) {
            return null;
          }
          return c(z2, 0, [1], "03", true);
        };
        this.getPublicKeyIdx = function() {
          return l(this.hex, 0, [0, 6 + this.foffset], "30");
        };
        this.getPublicKeyContentIdx = function() {
          var z2 = this.getPublicKeyIdx();
          return l(this.hex, z2, [1, 0], "30");
        };
        this.getPublicKey = function() {
          return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
        };
        this.getSignatureAlgorithmName = function() {
          var z2 = a(this.hex, 0, [1], "30");
          return this.getAlgorithmIdentifierName(z2);
        };
        this.getSignatureValueHex = function() {
          return c(this.hex, 0, [2], "03", true);
        };
        this.verifySignature = function(B) {
          var C = this.getSignatureAlgorithmField();
          var z2 = this.getSignatureValueHex();
          var A = a(this.hex, 0, [0], "30");
          var D = new KJUR.crypto.Signature({ alg: C });
          D.init(B);
          D.updateHex(A);
          return D.verify(z2);
        };
        this.parseExt = function(I) {
          var B, z2, D;
          if (I === void 0) {
            D = this.hex;
            if (this.version !== 3) {
              return -1;
            }
            B = l(D, 0, [0, 7, 0], "30");
            z2 = s(D, B);
          } else {
            D = pemtohex(I);
            var E = l(D, 0, [0, 3, 0, 0], "06");
            if (k(D, E) != "2a864886f70d01090e") {
              this.aExtInfo = new Array();
              return;
            }
            B = l(D, 0, [0, 3, 0, 1, 0], "30");
            z2 = s(D, B);
            this.hex = D;
          }
          this.aExtInfo = new Array();
          for (var C = 0; C < z2.length; C++) {
            var G = {};
            G.critical = false;
            var F = s(D, z2[C]);
            var A = 0;
            if (F.length === 3) {
              G.critical = true;
              A = 1;
            }
            G.oid = o2.hextooidstr(c(D, z2[C], [0], "06"));
            var H = l(D, z2[C], [1 + A]);
            G.vidx = n2(D, H);
            this.aExtInfo.push(G);
          }
        };
        this.getExtInfo = function(B) {
          var z2 = this.aExtInfo;
          var C = B;
          if (!B.match(/^[0-9.]+$/)) {
            C = KJUR.asn1.x509.OID.name2oid(B);
          }
          if (C === "") {
            return void 0;
          }
          for (var A = 0; A < z2.length; A++) {
            if (z2[A].oid === C) {
              return z2[A];
            }
          }
          return void 0;
        };
        this.getCriticalExtV = function(C, z2, B) {
          if (z2 != void 0) {
            return [z2, B];
          }
          var A = this.getExtInfo(C);
          if (A == void 0) {
            return [null, null];
          }
          return [b(this.hex, A.vidx), A.critical];
        };
        this.getExtBasicConstraints = function(A, E) {
          if (A === void 0 && E === void 0) {
            var C = this.getExtInfo("basicConstraints");
            if (C === void 0) {
              return void 0;
            }
            A = b(this.hex, C.vidx);
            E = C.critical;
          }
          var z2 = { extname: "basicConstraints" };
          if (E) {
            z2.critical = true;
          }
          if (A === "3000") {
            return z2;
          }
          if (A === "30030101ff") {
            z2.cA = true;
            return z2;
          }
          if (A.substr(0, 12) === "30060101ff02") {
            var D = k(A, 10);
            var B = parseInt(D, 16);
            z2.cA = true;
            z2.pathLen = B;
            return z2;
          }
          throw new Error("hExtV parse error: " + A);
        };
        this.getExtNameConstraints = function(I, G) {
          var A = this.getCriticalExtV("nameConstraints", I, G);
          I = A[0];
          G = A[1];
          if (I == null) {
            return void 0;
          }
          var K = { extname: "nameConstraints" };
          if (G) {
            K.critical = true;
          }
          var F = s(I, 0);
          for (var D = 0; D < F.length; D++) {
            var E = [];
            var B = s(I, F[D]);
            for (var C = 0; C < B.length; C++) {
              var H = b(I, B[C]);
              var z2 = this.getGeneralSubtree(H);
              E.push(z2);
            }
            var J = I.substr(F[D], 2);
            if (J == "a0") {
              K.permit = E;
            } else {
              if (J == "a1") {
                K.exclude = E;
              }
            }
          }
          return K;
        };
        this.getGeneralSubtree = function(F) {
          var D = s(F, 0);
          var C = D.length;
          if (C < 1 || 2 < C) {
            throw new Error("wrong num elements");
          }
          var B = this.getGeneralName(b(F, D[0]));
          for (var E = 1; E < C; E++) {
            var A = F.substr(D[E], 2);
            var z2 = k(F, D[E]);
            var G = parseInt(z2, 16);
            if (A == "80") {
              B.min = G;
            }
            if (A == "81") {
              B.max = G;
            }
          }
          return B;
        };
        this.getExtKeyUsage = function(A, C) {
          var B = this.getCriticalExtV("keyUsage", A, C);
          A = B[0];
          C = B[1];
          if (A == null) {
            return void 0;
          }
          var z2 = { extname: "keyUsage" };
          if (C) {
            z2.critical = true;
          }
          z2.names = this.getExtKeyUsageString(A).split(",");
          return z2;
        };
        this.getExtKeyUsageBin = function(A) {
          if (A === void 0) {
            var B = this.getExtInfo("keyUsage");
            if (B === void 0) {
              return "";
            }
            A = b(this.hex, B.vidx);
          }
          if (A.length != 8 && A.length != 10) {
            throw new Error("malformed key usage value: " + A);
          }
          var z2 = "000000000000000" + parseInt(A.substr(6), 16).toString(2);
          if (A.length == 8) {
            z2 = z2.slice(-8);
          }
          if (A.length == 10) {
            z2 = z2.slice(-16);
          }
          z2 = z2.replace(/0+$/, "");
          if (z2 == "") {
            z2 = "0";
          }
          return z2;
        };
        this.getExtKeyUsageString = function(B) {
          var C = this.getExtKeyUsageBin(B);
          var z2 = new Array();
          for (var A = 0; A < C.length; A++) {
            if (C.substr(A, 1) == "1") {
              z2.push(X509.KEYUSAGE_NAME[A]);
            }
          }
          return z2.join(",");
        };
        this.getExtSubjectKeyIdentifier = function(B, D) {
          if (B === void 0 && D === void 0) {
            var C = this.getExtInfo("subjectKeyIdentifier");
            if (C === void 0) {
              return void 0;
            }
            B = b(this.hex, C.vidx);
            D = C.critical;
          }
          var z2 = { extname: "subjectKeyIdentifier" };
          if (D) {
            z2.critical = true;
          }
          var A = k(B, 0);
          z2.kid = { hex: A };
          return z2;
        };
        this.getExtAuthorityKeyIdentifier = function(F, D) {
          if (F === void 0 && D === void 0) {
            var z2 = this.getExtInfo("authorityKeyIdentifier");
            if (z2 === void 0) {
              return void 0;
            }
            F = b(this.hex, z2.vidx);
            D = z2.critical;
          }
          var G = { extname: "authorityKeyIdentifier" };
          if (D) {
            G.critical = true;
          }
          var E = s(F, 0);
          for (var A = 0; A < E.length; A++) {
            var H = F.substr(E[A], 2);
            if (H === "80") {
              G.kid = { hex: k(F, E[A]) };
            }
            if (H === "a1") {
              var C = b(F, E[A]);
              var B = this.getGeneralNames(C);
              G.issuer = B[0]["dn"];
            }
            if (H === "82") {
              G.sn = { hex: k(F, E[A]) };
            }
          }
          return G;
        };
        this.getExtExtKeyUsage = function(C, E) {
          if (C === void 0 && E === void 0) {
            var D = this.getExtInfo("extKeyUsage");
            if (D === void 0) {
              return void 0;
            }
            C = b(this.hex, D.vidx);
            E = D.critical;
          }
          var z2 = { extname: "extKeyUsage", array: [] };
          if (E) {
            z2.critical = true;
          }
          var A = s(C, 0);
          for (var B = 0; B < A.length; B++) {
            z2.array.push(u(k(C, A[B])));
          }
          return z2;
        };
        this.getExtExtKeyUsageName = function() {
          var D = this.getExtInfo("extKeyUsage");
          if (D === void 0) {
            return D;
          }
          var z2 = new Array();
          var C = b(this.hex, D.vidx);
          if (C === "") {
            return z2;
          }
          var A = s(C, 0);
          for (var B = 0; B < A.length; B++) {
            z2.push(u(k(C, A[B])));
          }
          return z2;
        };
        this.getExtSubjectAltName = function(A, C) {
          if (A === void 0 && C === void 0) {
            var B = this.getExtInfo("subjectAltName");
            if (B === void 0) {
              return void 0;
            }
            A = b(this.hex, B.vidx);
            C = B.critical;
          }
          var z2 = { extname: "subjectAltName", array: [] };
          if (C) {
            z2.critical = true;
          }
          z2.array = this.getGeneralNames(A);
          return z2;
        };
        this.getExtIssuerAltName = function(A, C) {
          if (A === void 0 && C === void 0) {
            var B = this.getExtInfo("issuerAltName");
            if (B === void 0) {
              return void 0;
            }
            A = b(this.hex, B.vidx);
            C = B.critical;
          }
          var z2 = { extname: "issuerAltName", array: [] };
          if (C) {
            z2.critical = true;
          }
          z2.array = this.getGeneralNames(A);
          return z2;
        };
        this.getGeneralNames = function(D) {
          var B = s(D, 0);
          var z2 = [];
          for (var C = 0; C < B.length; C++) {
            var A = this.getGeneralName(b(D, B[C]));
            if (A !== void 0) {
              z2.push(A);
            }
          }
          return z2;
        };
        this.getGeneralName = function(A) {
          var z2 = A.substr(0, 2);
          var C = k(A, 0);
          var B = hextorstr(C);
          if (z2 == "81") {
            return { rfc822: B };
          }
          if (z2 == "82") {
            return { dns: B };
          }
          if (z2 == "86") {
            return { uri: B };
          }
          if (z2 == "87") {
            return { ip: hextoip(C) };
          }
          if (z2 == "a4") {
            return { dn: this.getX500Name(C) };
          }
          if (z2 == "a0") {
            return { other: this.getOtherName(A) };
          }
          return void 0;
        };
        this.getExtSubjectAltName2 = function() {
          var D, G, F;
          var E = this.getExtInfo("subjectAltName");
          if (E === void 0) {
            return E;
          }
          var z2 = new Array();
          var C = b(this.hex, E.vidx);
          var A = s(C, 0);
          for (var B = 0; B < A.length; B++) {
            F = C.substr(A[B], 2);
            D = k(C, A[B]);
            if (F === "81") {
              G = hextoutf8(D);
              z2.push(["MAIL", G]);
            }
            if (F === "82") {
              G = hextoutf8(D);
              z2.push(["DNS", G]);
            }
            if (F === "84") {
              G = X509.hex2dn(D, 0);
              z2.push(["DN", G]);
            }
            if (F === "86") {
              G = hextoutf8(D);
              z2.push(["URI", G]);
            }
            if (F === "87") {
              G = hextoip(D);
              z2.push(["IP", G]);
            }
          }
          return z2;
        };
        this.getExtCRLDistributionPoints = function(D, F) {
          if (D === void 0 && F === void 0) {
            var E = this.getExtInfo("cRLDistributionPoints");
            if (E === void 0) {
              return void 0;
            }
            D = b(this.hex, E.vidx);
            F = E.critical;
          }
          var A = { extname: "cRLDistributionPoints", array: [] };
          if (F) {
            A.critical = true;
          }
          var B = s(D, 0);
          for (var C = 0; C < B.length; C++) {
            var z2 = b(D, B[C]);
            A.array.push(this.getDistributionPoint(z2));
          }
          return A;
        };
        this.getDistributionPoint = function(E) {
          var B = {};
          var C = s(E, 0);
          for (var D = 0; D < C.length; D++) {
            var A = E.substr(C[D], 2);
            var z2 = b(E, C[D]);
            if (A == "a0") {
              B.dpname = this.getDistributionPointName(z2);
            }
          }
          return B;
        };
        this.getDistributionPointName = function(E) {
          var B = {};
          var C = s(E, 0);
          for (var D = 0; D < C.length; D++) {
            var A = E.substr(C[D], 2);
            var z2 = b(E, C[D]);
            if (A == "a0") {
              B.full = this.getGeneralNames(z2);
            }
          }
          return B;
        };
        this.getExtCRLDistributionPointsURI = function() {
          var D = this.getExtCRLDistributionPoints();
          if (D == void 0) {
            return D;
          }
          var A = D.array;
          var z2 = [];
          for (var C = 0; C < A.length; C++) {
            try {
              if (A[C].dpname.full[0].uri != void 0) {
                z2.push(A[C].dpname.full[0].uri);
              }
            } catch (B) {
            }
          }
          return z2;
        };
        this.getExtAIAInfo = function() {
          var D = this.getExtInfo("authorityInfoAccess");
          if (D === void 0) {
            return D;
          }
          var z2 = { ocsp: [], caissuer: [] };
          var A = s(this.hex, D.vidx);
          for (var B = 0; B < A.length; B++) {
            var E = c(this.hex, A[B], [0], "06");
            var C = c(this.hex, A[B], [1], "86");
            if (E === "2b06010505073001") {
              z2.ocsp.push(hextoutf8(C));
            }
            if (E === "2b06010505073002") {
              z2.caissuer.push(hextoutf8(C));
            }
          }
          return z2;
        };
        this.getExtAuthorityInfoAccess = function(G, E) {
          if (G === void 0 && E === void 0) {
            var z2 = this.getExtInfo("authorityInfoAccess");
            if (z2 === void 0) {
              return void 0;
            }
            G = b(this.hex, z2.vidx);
            E = z2.critical;
          }
          var H = { extname: "authorityInfoAccess", array: [] };
          if (E) {
            H.critical = true;
          }
          var F = s(G, 0);
          for (var A = 0; A < F.length; A++) {
            var D = p(G, F[A], [0], "06");
            var B = c(G, F[A], [1], "86");
            var C = hextoutf8(B);
            if (D == "2b06010505073001") {
              H.array.push({ ocsp: C });
            } else {
              if (D == "2b06010505073002") {
                H.array.push({ caissuer: C });
              } else {
                throw new Error("unknown method: " + D);
              }
            }
          }
          return H;
        };
        this.getExtCertificatePolicies = function(D, G) {
          if (D === void 0 && G === void 0) {
            var F = this.getExtInfo("certificatePolicies");
            if (F === void 0) {
              return void 0;
            }
            D = b(this.hex, F.vidx);
            G = F.critical;
          }
          var z2 = { extname: "certificatePolicies", array: [] };
          if (G) {
            z2.critical = true;
          }
          var A = s(D, 0);
          for (var B = 0; B < A.length; B++) {
            var E = b(D, A[B]);
            var C = this.getPolicyInformation(E);
            z2.array.push(C);
          }
          return z2;
        };
        this.getPolicyInformation = function(D) {
          var z2 = {};
          var F = c(D, 0, [0], "06");
          z2.policyoid = u(F);
          var G = f(D, 0, [1], "30");
          if (G != -1) {
            z2.array = [];
            var A = s(D, G);
            for (var B = 0; B < A.length; B++) {
              var E = b(D, A[B]);
              var C = this.getPolicyQualifierInfo(E);
              z2.array.push(C);
            }
          }
          return z2;
        };
        this.getOtherName = function(B) {
          var z2 = {};
          var A = s(B, 0);
          var D = c(B, A[0], [], "06");
          var C = c(B, A[1], []);
          z2.oid = u(D);
          z2.value = j(C);
          return z2;
        };
        this.getPolicyQualifierInfo = function(A) {
          var z2 = {};
          var B = c(A, 0, [0], "06");
          if (B === "2b06010505070201") {
            var D = p(A, 0, [1], "16");
            z2.cps = hextorstr(D);
          } else {
            if (B === "2b06010505070202") {
              var C = a(A, 0, [1], "30");
              z2.unotice = this.getUserNotice(C);
            }
          }
          return z2;
        };
        this.getUserNotice = function(D) {
          var A = {};
          var B = s(D, 0);
          for (var C = 0; C < B.length; C++) {
            var z2 = b(D, B[C]);
            if (z2.substr(0, 2) != "30") {
              A.exptext = this.getDisplayText(z2);
            }
          }
          return A;
        };
        this.getDisplayText = function(A) {
          var B = { "0c": "utf8", "16": "ia5", "1a": "vis", "1e": "bmp" };
          var z2 = {};
          z2.type = B[A.substr(0, 2)];
          z2.str = hextorstr(k(A, 0));
          return z2;
        };
        this.getExtPolicyMappings = function(G, E) {
          var z2 = this.getCriticalExtV("policyMappings", G, E);
          G = z2[0];
          E = z2[1];
          if (G == null) {
            return void 0;
          }
          var I = { extname: "policyMappings" };
          if (E) {
            I.critical = true;
          }
          try {
            var A = j(G);
            var B = A.seq;
            var F = [];
            for (var C = 0; C < B.length; C++) {
              var H = B[C].seq;
              F.push([H[0].oid, H[1].oid]);
            }
            I.array = F;
          } catch (D) {
            throw new m("malformed policyMappings");
          }
          return I;
        };
        this.getExtPolicyConstraints = function(G, D) {
          var z2 = this.getCriticalExtV("policyConstraints", G, D);
          G = z2[0];
          D = z2[1];
          if (G == null) {
            return void 0;
          }
          var H = { extname: "policyConstraints" };
          if (D) {
            H.critical = true;
          }
          var A = j(G);
          try {
            var F = A.seq;
            for (var B = 0; B < F.length; B++) {
              var E = F[B].tag;
              if (E.explicit != false) {
                continue;
              }
              if (E.tag == "80") {
                H.reqexp = parseInt(E.hex, 16);
              }
              if (E.tag == "81") {
                H.inhibit = parseInt(E.hex, 16);
              }
            }
          } catch (C) {
            return new m("malformed policyConstraints value");
          }
          return H;
        };
        this.getExtInhibitAnyPolicy = function(A, D) {
          var C = this.getCriticalExtV("inhibitAnyPolicy", A, D);
          A = C[0];
          D = C[1];
          if (A == null) {
            return void 0;
          }
          var z2 = { extname: "inhibitAnyPolicy" };
          if (D) {
            z2.critical = true;
          }
          var B = x(A, 0);
          if (B == -1) {
            return new m("wrong value");
          }
          z2.skip = B;
          return z2;
        };
        this.getExtCRLNumber = function(A, B) {
          var z2 = { extname: "cRLNumber" };
          if (B) {
            z2.critical = true;
          }
          if (A.substr(0, 2) == "02") {
            z2.num = { hex: k(A, 0) };
            return z2;
          }
          throw new m("hExtV parse error: " + A);
        };
        this.getExtCRLReason = function(A, B) {
          var z2 = { extname: "cRLReason" };
          if (B) {
            z2.critical = true;
          }
          if (A.substr(0, 2) == "0a") {
            z2.code = parseInt(k(A, 0), 16);
            return z2;
          }
          throw new Error("hExtV parse error: " + A);
        };
        this.getExtOcspNonce = function(A, C) {
          var z2 = { extname: "ocspNonce" };
          if (C) {
            z2.critical = true;
          }
          var B = k(A, 0);
          z2.hex = B;
          return z2;
        };
        this.getExtOcspNoCheck = function(A, B) {
          var z2 = { extname: "ocspNoCheck" };
          if (B) {
            z2.critical = true;
          }
          return z2;
        };
        this.getExtAdobeTimeStamp = function(C, F) {
          if (C === void 0 && F === void 0) {
            var E = this.getExtInfo("adobeTimeStamp");
            if (E === void 0) {
              return void 0;
            }
            C = b(this.hex, E.vidx);
            F = E.critical;
          }
          var z2 = { extname: "adobeTimeStamp" };
          if (F) {
            z2.critical = true;
          }
          var B = s(C, 0);
          if (B.length > 1) {
            var G = b(C, B[1]);
            var A = this.getGeneralName(G);
            if (A.uri != void 0) {
              z2.uri = A.uri;
            }
          }
          if (B.length > 2) {
            var D = b(C, B[2]);
            if (D == "0101ff") {
              z2.reqauth = true;
            }
            if (D == "010100") {
              z2.reqauth = false;
            }
          }
          return z2;
        };
        var e2 = function(E) {
          var z2 = {};
          try {
            var B = E.seq[0].oid;
            var D = KJUR.asn1.x509.OID.name2oid(B);
            z2.type = KJUR.asn1.x509.OID.oid2atype(D);
            var A = E.seq[1];
            if (A.utf8str != void 0) {
              z2.ds = "utf8";
              z2.value = A.utf8str.str;
            } else {
              if (A.numstr != void 0) {
                z2.ds = "num";
                z2.value = A.numstr.str;
              } else {
                if (A.telstr != void 0) {
                  z2.ds = "tel";
                  z2.value = A.telstr.str;
                } else {
                  if (A.prnstr != void 0) {
                    z2.ds = "prn";
                    z2.value = A.prnstr.str;
                  } else {
                    if (A.ia5str != void 0) {
                      z2.ds = "ia5";
                      z2.value = A.ia5str.str;
                    } else {
                      if (A.visstr != void 0) {
                        z2.ds = "vis";
                        z2.value = A.visstr.str;
                      } else {
                        if (A.bmpstr != void 0) {
                          z2.ds = "bmp";
                          z2.value = A.bmpstr.str;
                        } else {
                          throw "error";
                        }
                      }
                    }
                  }
                }
              }
            }
            return z2;
          } catch (C) {
            throw new Erorr("improper ASN.1 parsed AttrTypeAndValue");
          }
        };
        var i = function(A) {
          try {
            return A.set.map(function(B) {
              return e2(B);
            });
          } catch (z2) {
            throw new Error("improper ASN.1 parsed RDN: " + z2);
          }
        };
        var h = function(A) {
          try {
            return A.seq.map(function(B) {
              return i(B);
            });
          } catch (z2) {
            throw new Error("improper ASN.1 parsed X500Name: " + z2);
          }
        };
        this.getX500NameRule = function(z2) {
          var G = true;
          var K = true;
          var J = false;
          var A = "";
          var D = "";
          var M = null;
          var H = [];
          for (var C = 0; C < z2.length; C++) {
            var E = z2[C];
            for (var B = 0; B < E.length; B++) {
              H.push(E[B]);
            }
          }
          for (var C = 0; C < H.length; C++) {
            var L = H[C];
            var N = L.ds;
            var I = L.value;
            var F = L.type;
            A += ":" + N;
            if (N != "prn" && N != "utf8" && N != "ia5") {
              return "mixed";
            }
            if (N == "ia5") {
              if (F != "CN") {
                return "mixed";
              } else {
                if (!KJUR.lang.String.isMail(I)) {
                  return "mixed";
                } else {
                  continue;
                }
              }
            }
            if (F == "C") {
              if (N == "prn") {
                continue;
              } else {
                return "mixed";
              }
            }
            D += ":" + N;
            if (M == null) {
              M = N;
            } else {
              if (M !== N) {
                return "mixed";
              }
            }
          }
          if (M == null) {
            return "prn";
          } else {
            return M;
          }
        };
        this.getAttrTypeAndValue = function(z2) {
          var A = j(z2);
          return e2(A);
        };
        this.getRDN = function(z2) {
          var A = j(z2);
          return i(A);
        };
        this.getX500NameArray = function(z2) {
          var A = j(z2);
          return h(A);
        };
        this.getX500Name = function(C, E, D) {
          var A = this.getX500NameArray(C);
          var B = this.dnarraytostr(A);
          var z2 = { str: B };
          z2.array = A;
          if (D == true) {
            z2.hex = C;
          }
          if (E == true) {
            z2.canon = this.c14nRDNArray(A);
          }
          return z2;
        };
        this.readCertPEM = function(z2) {
          this.readCertHex(w(z2));
        };
        this.readCertHex = function(z2) {
          this.hex = z2;
          this.getVersion();
          try {
            l(this.hex, 0, [0, 7], "a3");
            this.parseExt();
          } catch (A) {
          }
        };
        this.getParam = function(A) {
          var z2 = {};
          if (A == void 0) {
            A = {};
          }
          z2.version = this.getVersion();
          z2.serial = { hex: this.getSerialNumberHex() };
          z2.sigalg = this.getSignatureAlgorithmField();
          z2.issuer = this.getIssuer(A.dncanon, A.dnhex);
          z2.notbefore = this.getNotBefore();
          z2.notafter = this.getNotAfter();
          z2.subject = this.getSubject(A.dncanon, A.dnhex);
          z2.sbjpubkey = hextopem(this.getPublicKeyHex(), "PUBLIC KEY");
          if (this.aExtInfo != void 0 && this.aExtInfo.length > 0) {
            z2.ext = this.getExtParamArray();
          }
          z2.sighex = this.getSignatureValueHex();
          if (A.tbshex == true) {
            z2.tbshex = a(this.hex, 0, [0]);
          }
          if (A.nodnarray == true) {
            delete z2.issuer.array;
            delete z2.subject.array;
          }
          return z2;
        };
        this.getExtParamArray = function(A) {
          if (A == void 0) {
            var C = f(this.hex, 0, [0, "[3]"]);
            if (C != -1) {
              A = q(this.hex, 0, [0, "[3]", 0], "30");
            }
          }
          var z2 = [];
          var B = s(A, 0);
          for (var D = 0; D < B.length; D++) {
            var F = b(A, B[D]);
            var E = this.getExtParam(F);
            if (E != null) {
              z2.push(E);
            }
          }
          return z2;
        };
        this.getExtParam = function(A) {
          var H = {};
          var C = s(A, 0);
          var D = C.length;
          if (D != 2 && D != 3) {
            throw new Error("wrong number elements in Extension: " + D + " " + A);
          }
          var B = r2(c(A, 0, [0], "06"));
          var F = false;
          if (D == 3 && a(A, 0, [1]) == "0101ff") {
            F = true;
          }
          var G = a(A, 0, [D - 1, 0]);
          var E = void 0;
          if (B == "2.5.29.14") {
            E = this.getExtSubjectKeyIdentifier(G, F);
          } else {
            if (B == "2.5.29.15") {
              E = this.getExtKeyUsage(G, F);
            } else {
              if (B == "2.5.29.17") {
                E = this.getExtSubjectAltName(G, F);
              } else {
                if (B == "2.5.29.18") {
                  E = this.getExtIssuerAltName(G, F);
                } else {
                  if (B == "2.5.29.19") {
                    E = this.getExtBasicConstraints(G, F);
                  } else {
                    if (B == "2.5.29.30") {
                      E = this.getExtNameConstraints(G, F);
                    } else {
                      if (B == "2.5.29.31") {
                        E = this.getExtCRLDistributionPoints(G, F);
                      } else {
                        if (B == "2.5.29.32") {
                          E = this.getExtCertificatePolicies(G, F);
                        } else {
                          if (B == "2.5.29.33") {
                            E = this.getExtPolicyMappings(G, F);
                          } else {
                            if (B == "2.5.29.35") {
                              E = this.getExtAuthorityKeyIdentifier(G, F);
                            } else {
                              if (B == "2.5.29.36") {
                                E = this.getExtPolicyConstraints(G, F);
                              } else {
                                if (B == "2.5.29.37") {
                                  E = this.getExtExtKeyUsage(G, F);
                                } else {
                                  if (B == "2.5.29.54") {
                                    E = this.getExtInhibitAnyPolicy(G, F);
                                  } else {
                                    if (B == "1.3.6.1.5.5.7.1.1") {
                                      E = this.getExtAuthorityInfoAccess(G, F);
                                    } else {
                                      if (B == "2.5.29.20") {
                                        E = this.getExtCRLNumber(G, F);
                                      } else {
                                        if (B == "2.5.29.21") {
                                          E = this.getExtCRLReason(G, F);
                                        } else {
                                          if (B == "1.3.6.1.5.5.7.48.1.2") {
                                            E = this.getExtOcspNonce(G, F);
                                          } else {
                                            if (B == "1.3.6.1.5.5.7.48.1.5") {
                                              E = this.getExtOcspNoCheck(G, F);
                                            } else {
                                              if (B == "1.2.840.113583.1.1.9.1") {
                                                E = this.getExtAdobeTimeStamp(G, F);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (E != void 0) {
            return E;
          }
          var z2 = { extname: B, extn: G };
          if (F) {
            z2.critical = true;
          }
          return z2;
        };
        this.findExt = function(A, B) {
          for (var z2 = 0; z2 < A.length; z2++) {
            if (A[z2].extname == B) {
              return A[z2];
            }
          }
          return null;
        };
        this.updateExtCDPFullURI = function(D, z2) {
          var C = this.findExt(D, "cRLDistributionPoints");
          if (C == null) {
            return;
          }
          if (C.array == void 0) {
            return;
          }
          var F = C.array;
          for (var B = 0; B < F.length; B++) {
            if (F[B].dpname == void 0) {
              continue;
            }
            if (F[B].dpname.full == void 0) {
              continue;
            }
            var G = F[B].dpname.full;
            for (var A = 0; A < G.length; A++) {
              var E = G[B];
              if (E.uri == void 0) {
                continue;
              }
              E.uri = z2;
            }
          }
        };
        this.updateExtAIAOCSP = function(D, A) {
          var C = this.findExt(D, "authorityInfoAccess");
          if (C == null) {
            return;
          }
          if (C.array == void 0) {
            return;
          }
          var z2 = C.array;
          for (var B = 0; B < z2.length; B++) {
            if (z2[B].ocsp != void 0) {
              z2[B].ocsp = A;
            }
          }
        };
        this.updateExtAIACAIssuer = function(D, A) {
          var C = this.findExt(D, "authorityInfoAccess");
          if (C == null) {
            return;
          }
          if (C.array == void 0) {
            return;
          }
          var z2 = C.array;
          for (var B = 0; B < z2.length; B++) {
            if (z2[B].caissuer != void 0) {
              z2[B].caissuer = A;
            }
          }
        };
        this.dnarraytostr = function(B) {
          function z2(C) {
            return C.map(function(D) {
              return A(D).replace(/\+/, "\\+");
            }).join("+");
          }
          function A(C) {
            return C.type + "=" + C.value;
          }
          return "/" + B.map(function(C) {
            return z2(C).replace(/\//, "\\/");
          }).join("/");
        };
        this.setCanonicalizedDN = function(A) {
          var C;
          if (A.str != void 0 && A.array == void 0) {
            var B = new KJUR.asn1.x509.X500Name({ str: A.str });
            var z2 = B.tohex();
            C = this.getX500NameArray(z2);
          } else {
            C = A.array;
          }
          if (A.canon == void 0) {
            A.canon = this.c14nRDNArray(C);
          }
        };
        this.c14nRDNArray = function(G) {
          var A = [];
          for (var C = 0; C < G.length; C++) {
            var E = G[C];
            var z2 = [];
            for (var B = 0; B < E.length; B++) {
              var D = E[B];
              var F = D.value;
              F = F.replace(/^\s*/, "");
              F = F.replace(/\s*$/, "");
              F = F.replace(/\s+/g, " ");
              F = F.toLowerCase();
              z2.push(D.type.toLowerCase() + "=" + F);
            }
            A.push(z2.join("+"));
          }
          return "/" + A.join("/");
        };
        this.getInfo = function() {
          var A = function(W) {
            var ac = "";
            var U = "    ";
            var Y = "\n";
            var Z = W.array;
            for (var X = 0; X < Z.length; X++) {
              var V = Z[X];
              if (V.dn != void 0) {
                ac += U + "dn: " + V.dn.str + Y;
              }
              if (V.ip != void 0) {
                ac += U + "ip: " + V.ip + Y;
              }
              if (V.rfc822 != void 0) {
                ac += U + "rfc822: " + V.rfc822 + Y;
              }
              if (V.dns != void 0) {
                ac += U + "dns: " + V.dns + Y;
              }
              if (V.uri != void 0) {
                ac += U + "uri: " + V.uri + Y;
              }
              if (V.other != void 0) {
                var ab = V.other.oid;
                var aa = JSON.stringify(V.other.value).replace(/\"/g, "");
                ac += U + "other: " + ab + "=" + aa + Y;
              }
            }
            ac = ac.replace(/\n$/, "");
            return ac;
          };
          var H = function(aa) {
            var Y = "";
            var U = aa.array;
            for (var X = 0; X < U.length; X++) {
              var Z = U[X];
              Y += "    policy oid: " + Z.policyoid + "\n";
              if (Z.array === void 0) {
                continue;
              }
              for (var W = 0; W < Z.array.length; W++) {
                var V = Z.array[W];
                if (V.cps !== void 0) {
                  Y += "    cps: " + V.cps + "\n";
                }
              }
            }
            return Y;
          };
          var K = function(Y) {
            var X = "";
            var U = Y.array;
            for (var W = 0; W < U.length; W++) {
              var Z = U[W];
              try {
                if (Z.dpname.full[0].uri !== void 0) {
                  X += "    " + Z.dpname.full[0].uri + "\n";
                }
              } catch (V) {
              }
              try {
                if (Z.dname.full[0].dn.hex !== void 0) {
                  X += "    " + X509.hex2dn(Z.dpname.full[0].dn.hex) + "\n";
                }
              } catch (V) {
              }
            }
            return X;
          };
          var I = function(Y) {
            var X = "";
            var U = Y.array;
            for (var V = 0; V < U.length; V++) {
              var W = U[V];
              if (W.caissuer !== void 0) {
                X += "    caissuer: " + W.caissuer + "\n";
              }
              if (W.ocsp !== void 0) {
                X += "    ocsp: " + W.ocsp + "\n";
              }
            }
            return X;
          };
          var B = X509;
          var M, L, T;
          M = "Basic Fields\n";
          M += "  serial number: " + this.getSerialNumberHex() + "\n";
          M += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n";
          M += "  issuer: " + this.getIssuerString() + "\n";
          M += "  notBefore: " + this.getNotBefore() + "\n";
          M += "  notAfter: " + this.getNotAfter() + "\n";
          M += "  subject: " + this.getSubjectString() + "\n";
          M += "  subject public key info: \n";
          L = this.getPublicKey();
          M += "    key algorithm: " + L.type + "\n";
          if (L.type === "RSA") {
            M += "    n=" + hextoposhex(L.n.toString(16)).substr(0, 16) + "...\n";
            M += "    e=" + hextoposhex(L.e.toString(16)) + "\n";
          }
          T = this.aExtInfo;
          if (T !== void 0 && T !== null) {
            M += "X509v3 Extensions:\n";
            for (var P = 0; P < T.length; P++) {
              var R = T[P];
              var z2 = KJUR.asn1.x509.OID.oid2name(R.oid);
              if (z2 === "") {
                z2 = R.oid;
              }
              var O = "";
              if (R.critical === true) {
                O = "CRITICAL";
              }
              M += "  " + z2 + " " + O + ":\n";
              if (z2 === "basicConstraints") {
                var C = this.getExtBasicConstraints();
                if (C.cA === void 0) {
                  M += "    {}\n";
                } else {
                  M += "    cA=true";
                  if (C.pathLen !== void 0) {
                    M += ", pathLen=" + C.pathLen;
                  }
                  M += "\n";
                }
              } else {
                if (z2 == "policyMappings") {
                  var S = this.getExtPolicyMappings().array;
                  var G = S.map(function(U) {
                    var V = U;
                    return V[0] + ":" + V[1];
                  }).join(", ");
                  M += "    " + G + "\n";
                } else {
                  if (z2 == "policyConstraints") {
                    var N = this.getExtPolicyConstraints();
                    M += "    ";
                    if (N.reqexp != void 0) {
                      M += " reqexp=" + N.reqexp;
                    }
                    if (N.inhibit != void 0) {
                      M += " inhibit=" + N.inhibit;
                    }
                    M += "\n";
                  } else {
                    if (z2 == "inhibitAnyPolicy") {
                      var N = this.getExtInhibitAnyPolicy();
                      M += "    skip=" + N.skip + "\n";
                    } else {
                      if (z2 == "keyUsage") {
                        M += "    " + this.getExtKeyUsageString() + "\n";
                      } else {
                        if (z2 == "subjectKeyIdentifier") {
                          M += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
                        } else {
                          if (z2 == "authorityKeyIdentifier") {
                            var D = this.getExtAuthorityKeyIdentifier();
                            if (D.kid !== void 0) {
                              M += "    kid=" + D.kid.hex + "\n";
                            }
                          } else {
                            if (z2 == "extKeyUsage") {
                              var Q = this.getExtExtKeyUsage().array;
                              M += "    " + Q.join(", ") + "\n";
                            } else {
                              if (z2 == "subjectAltName") {
                                var E = A(this.getExtSubjectAltName());
                                M += E + "\n";
                              } else {
                                if (z2 == "cRLDistributionPoints") {
                                  var J = this.getExtCRLDistributionPoints();
                                  M += K(J);
                                } else {
                                  if (z2 == "authorityInfoAccess") {
                                    var F = this.getExtAuthorityInfoAccess();
                                    M += I(F);
                                  } else {
                                    if (z2 == "certificatePolicies") {
                                      M += H(this.getExtCertificatePolicies());
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          M += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n";
          M += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
          return M;
        };
        if (typeof v == "string") {
          if (v.indexOf("-----BEGIN") != -1) {
            this.readCertPEM(v);
          } else {
            if (KJUR.lang.String.isHex(v)) {
              this.readCertHex(v);
            }
          }
        }
      }
      X509.hex2dn = function(e2, b) {
        if (b === void 0) {
          b = 0;
        }
        var a = new X509();
        var c = ASN1HEX.getTLV(e2, b);
        var d = a.getX500Name(e2);
        return d.str;
      };
      X509.hex2rdn = function(f, b) {
        if (b === void 0) {
          b = 0;
        }
        if (f.substr(b, 2) !== "31") {
          throw new Error("malformed RDN");
        }
        var c = new Array();
        var d = ASN1HEX.getChildIdx(f, b);
        for (var e2 = 0; e2 < d.length; e2++) {
          c.push(X509.hex2attrTypeValue(f, d[e2]));
        }
        c = c.map(function(a) {
          return a.replace("+", "\\+");
        });
        return c.join("+");
      };
      X509.hex2attrTypeValue = function(d, i) {
        var j = ASN1HEX;
        var h = j.getV;
        if (i === void 0) {
          i = 0;
        }
        if (d.substr(i, 2) !== "30") {
          throw new Error("malformed attribute type and value");
        }
        var g = j.getChildIdx(d, i);
        if (g.length !== 2 || d.substr(g[0], 2) !== "06") {
          "malformed attribute type and value";
        }
        var b = h(d, g[0]);
        var f = KJUR.asn1.ASN1Util.oidHexToInt(b);
        var e2 = KJUR.asn1.x509.OID.oid2atype(f);
        var a = h(d, g[1]);
        var c = hextorstr(a);
        return e2 + "=" + c;
      };
      X509.getPublicKeyFromCertHex = function(b) {
        var a = new X509();
        a.readCertHex(b);
        return a.getPublicKey();
      };
      X509.getPublicKeyFromCertPEM = function(b) {
        var a = new X509();
        a.readCertPEM(b);
        return a.getPublicKey();
      };
      X509.getPublicKeyInfoPropOfCertPEM = function(c) {
        var e2 = ASN1HEX;
        var g = e2.getVbyList;
        var b = {};
        var a, f, d;
        b.algparam = null;
        a = new X509();
        a.readCertPEM(c);
        f = a.getPublicKeyHex();
        b.keyhex = g(f, 0, [1], "03").substr(2);
        b.algoid = g(f, 0, [0, 0], "06");
        if (b.algoid === "2a8648ce3d0201") {
          b.algparam = g(f, 0, [0, 1], "06");
        }
        return b;
      };
      X509.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"];
      var X509CRL = function(e2) {
        var a = KJUR, f = a.lang.String.isHex, m = ASN1HEX, k = m.getV, b = m.getTLV, h = m.getVbyList, c = m.getTLVbyList, d = m.getTLVbyListEx, i = m.getIdxbyList, g = m.getIdxbyListEx, l = m.getChildIdx, j = new X509();
        this.hex = null;
        this.posSigAlg = null;
        this.posRevCert = null;
        this.parsed = null;
        this._setPos = function() {
          var o2 = i(this.hex, 0, [0, 0]);
          var n2 = this.hex.substr(o2, 2);
          if (n2 == "02") {
            this.posSigAlg = 1;
          } else {
            if (n2 == "30") {
              this.posSigAlg = 0;
            } else {
              throw new Error("malformed 1st item of TBSCertList: " + n2);
            }
          }
          var s = i(this.hex, 0, [0, this.posSigAlg + 3]);
          var r2 = this.hex.substr(s, 2);
          if (r2 == "17" || r2 == "18") {
            var q, p;
            q = i(this.hex, 0, [0, this.posSigAlg + 4]);
            this.posRevCert = null;
            if (q != -1) {
              p = this.hex.substr(q, 2);
              if (p == "30") {
                this.posRevCert = this.posSigAlg + 4;
              }
            }
          } else {
            if (r2 == "30") {
              this.posRevCert = this.posSigAlg + 3;
            } else {
              if (r2 == "a0") {
                this.posRevCert = null;
              } else {
                throw new Error("malformed nextUpdate or revCert tag: " + r2);
              }
            }
          }
        };
        this.getVersion = function() {
          if (this.posSigAlg == 0) {
            return null;
          }
          return parseInt(h(this.hex, 0, [0, 0], "02"), 16) + 1;
        };
        this.getSignatureAlgorithmField = function() {
          var n2 = c(this.hex, 0, [0, this.posSigAlg], "30");
          return j.getAlgorithmIdentifierName(n2);
        };
        this.getIssuer = function() {
          return j.getX500Name(this.getIssuerHex());
        };
        this.getIssuerHex = function() {
          return c(this.hex, 0, [0, this.posSigAlg + 1], "30");
        };
        this.getThisUpdate = function() {
          var n2 = h(this.hex, 0, [0, this.posSigAlg + 2]);
          return result = hextorstr(n2);
        };
        this.getNextUpdate = function() {
          var o2 = i(this.hex, 0, [0, this.posSigAlg + 3]);
          var n2 = this.hex.substr(o2, 2);
          if (n2 != "17" && n2 != "18") {
            return null;
          }
          return hextorstr(k(this.hex, o2));
        };
        this.getRevCertArray = function() {
          if (this.posRevCert == null) {
            return null;
          }
          var o2 = [];
          var n2 = i(this.hex, 0, [0, this.posRevCert]);
          var p = l(this.hex, n2);
          for (var q = 0; q < p.length; q++) {
            var r2 = b(this.hex, p[q]);
            o2.push(this.getRevCert(r2));
          }
          return o2;
        };
        this.getRevCert = function(p) {
          var o2 = {};
          var n2 = l(p, 0);
          o2.sn = { hex: h(p, 0, [0], "02") };
          o2.date = hextorstr(h(p, 0, [1]));
          if (n2.length == 3) {
            o2.ext = j.getExtParamArray(c(p, 0, [2]));
          }
          return o2;
        };
        this.findRevCert = function(p) {
          var n2 = new X509(p);
          var o2 = n2.getSerialNumberHex();
          return this.findRevCertBySN(o2);
        };
        this.findRevCertBySN = function(o2) {
          if (this.parsed == null) {
            this.getParam();
          }
          if (this.parsed.revcert == null) {
            return null;
          }
          var n2 = this.parsed.revcert;
          for (var p = 0; p < n2.length; p++) {
            if (o2 == n2[p].sn.hex) {
              return n2[p];
            }
          }
          return null;
        };
        this.getSignatureValueHex = function() {
          return h(this.hex, 0, [2], "03", true);
        };
        this.verifySignature = function(o2) {
          var p = this.getSignatureAlgorithmField();
          var n2 = this.getSignatureValueHex();
          var q = c(this.hex, 0, [0], "30");
          var r2 = new KJUR.crypto.Signature({ alg: p });
          r2.init(o2);
          r2.updateHex(q);
          return r2.verify(n2);
        };
        this.getParam = function(r2) {
          var n2 = {};
          var p = this.getVersion();
          if (p != null) {
            n2.version = p;
          }
          n2.sigalg = this.getSignatureAlgorithmField();
          n2.issuer = this.getIssuer();
          n2.thisupdate = this.getThisUpdate();
          var q = this.getNextUpdate();
          if (q != null) {
            n2.nextupdate = q;
          }
          var t3 = this.getRevCertArray();
          if (t3 != null) {
            n2.revcert = t3;
          }
          var s = g(this.hex, 0, [0, "[0]"]);
          if (s != -1) {
            var o2 = d(this.hex, 0, [0, "[0]", 0]);
            n2.ext = j.getExtParamArray(o2);
          }
          n2.sighex = this.getSignatureValueHex();
          this.parsed = n2;
          if (typeof r2 == "object") {
            if (r2.tbshex == true) {
              n2.tbshex = c(this.hex, 0, [0]);
            }
            if (r2.nodnarray == true) {
              delete n2.issuer.array;
            }
          }
          return n2;
        };
        if (typeof e2 == "string") {
          if (f(e2)) {
            this.hex = e2;
          } else {
            if (e2.match(/-----BEGIN X509 CRL/)) {
              this.hex = pemtohex(e2);
            }
          }
          this._setPos();
        }
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
        KJUR.jws = {};
      }
      KJUR.jws.JWS = function() {
        var b = KJUR, a = b.jws.JWS, c = a.isSafeJSONString;
        this.parseJWS = function(g, j) {
          if (this.parsedJWS !== void 0 && (j || this.parsedJWS.sigvalH !== void 0)) {
            return;
          }
          var i = g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
          if (i == null) {
            throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
          }
          var k = i[1];
          var e2 = i[2];
          var l = i[3];
          var n2 = k + "." + e2;
          this.parsedJWS = {};
          this.parsedJWS.headB64U = k;
          this.parsedJWS.payloadB64U = e2;
          this.parsedJWS.sigvalB64U = l;
          this.parsedJWS.si = n2;
          if (!j) {
            var h = b64utohex(l);
            var f = parseBigInt(h, 16);
            this.parsedJWS.sigvalH = h;
            this.parsedJWS.sigvalBI = f;
          }
          var d = b64utoutf8(k);
          var m = b64utoutf8(e2);
          this.parsedJWS.headS = d;
          this.parsedJWS.payloadS = m;
          if (!c(d, this.parsedJWS, "headP")) {
            throw "malformed JSON string for JWS Head: " + d;
          }
        };
      };
      KJUR.jws.JWS.sign = function(j, w, z2, A, a) {
        var x = KJUR, n2 = x.jws, r2 = n2.JWS, h = r2.readSafeJSONString, q = r2.isSafeJSONString, d = x.crypto, l = d.ECDSA, p = d.Mac, c = d.Signature, u = JSON;
        var t3, k, o2;
        if (typeof w != "string" && typeof w != "object") {
          throw "spHeader must be JSON string or object: " + w;
        }
        if (typeof w == "object") {
          k = w;
          t3 = u.stringify(k);
        }
        if (typeof w == "string") {
          t3 = w;
          if (!q(t3)) {
            throw "JWS Head is not safe JSON string: " + t3;
          }
          k = h(t3);
        }
        o2 = z2;
        if (typeof z2 == "object") {
          o2 = u.stringify(z2);
        }
        if ((j == "" || j == null) && k.alg !== void 0) {
          j = k.alg;
        }
        if (j != "" && j != null && k.alg === void 0) {
          k.alg = j;
          t3 = u.stringify(k);
        }
        if (j !== k.alg) {
          throw "alg and sHeader.alg doesn't match: " + j + "!=" + k.alg;
        }
        var s = null;
        if (r2.jwsalg2sigalg[j] === void 0) {
          throw "unsupported alg name: " + j;
        } else {
          s = r2.jwsalg2sigalg[j];
        }
        var e2 = utf8tob64u(t3);
        var m = utf8tob64u(o2);
        var b = e2 + "." + m;
        var y = "";
        if (s.substr(0, 4) == "Hmac") {
          if (A === void 0) {
            throw "mac key shall be specified for HS* alg";
          }
          var i = new p({ alg: s, prov: "cryptojs", pass: A });
          i.updateString(b);
          y = i.doFinal();
        } else {
          if (s.indexOf("withECDSA") != -1) {
            var f = new c({ alg: s });
            f.init(A, a);
            f.updateString(b);
            var g = f.sign();
            y = KJUR.crypto.ECDSA.asn1SigToConcatSig(g);
          } else {
            if (s != "none") {
              var f = new c({ alg: s });
              f.init(A, a);
              f.updateString(b);
              y = f.sign();
            }
          }
        }
        var v = hextob64u(y);
        return b + "." + v;
      };
      KJUR.jws.JWS.verify = function(w, B, n2) {
        var x = KJUR, q = x.jws, t3 = q.JWS, i = t3.readSafeJSONString, e2 = x.crypto, p = e2.ECDSA, s = e2.Mac, d = e2.Signature, m;
        if (typeof RSAKey !== void 0) {
          m = RSAKey;
        }
        if (!isBase64URLDot(w)) {
          return false;
        }
        var y = w.split(".");
        if (y.length !== 3) {
          return false;
        }
        var f = y[0];
        var r2 = y[1];
        var c = f + "." + r2;
        var A = b64utohex(y[2]);
        var l = i(b64utoutf8(y[0]));
        var k = null;
        var z2 = null;
        if (l.alg === void 0) {
          throw "algorithm not specified in header";
        } else {
          k = l.alg;
          z2 = k.substr(0, 2);
        }
        if (n2 != null && Object.prototype.toString.call(n2) === "[object Array]" && n2.length > 0) {
          var b = ":" + n2.join(":") + ":";
          if (b.indexOf(":" + k + ":") == -1) {
            throw "algorithm '" + k + "' not accepted in the list";
          }
        }
        if (k != "none" && B === null) {
          throw "key shall be specified to verify.";
        }
        if (typeof B == "string" && B.indexOf("-----BEGIN ") != -1) {
          B = KEYUTIL.getKey(B);
        }
        if (z2 == "RS" || z2 == "PS") {
          if (!(B instanceof m)) {
            throw "key shall be a RSAKey obj for RS* and PS* algs";
          }
        }
        if (z2 == "ES") {
          if (!(B instanceof p)) {
            throw "key shall be a ECDSA obj for ES* algs";
          }
        }
        if (k == "none") {
        }
        var u = null;
        if (t3.jwsalg2sigalg[l.alg] === void 0) {
          throw "unsupported alg name: " + k;
        } else {
          u = t3.jwsalg2sigalg[k];
        }
        if (u == "none") {
          throw "not supported";
        } else {
          if (u.substr(0, 4) == "Hmac") {
            var o2 = null;
            if (B === void 0) {
              throw "hexadecimal key shall be specified for HMAC";
            }
            var j = new s({ alg: u, pass: B });
            j.updateString(c);
            o2 = j.doFinal();
            return A == o2;
          } else {
            if (u.indexOf("withECDSA") != -1) {
              var h = null;
              try {
                h = p.concatSigToASN1Sig(A);
              } catch (v) {
                return false;
              }
              var g = new d({ alg: u });
              g.init(B);
              g.updateString(c);
              return g.verify(h);
            } else {
              var g = new d({ alg: u });
              g.init(B);
              g.updateString(c);
              return g.verify(A);
            }
          }
        }
      };
      KJUR.jws.JWS.parse = function(g) {
        var c = g.split(".");
        var b = {};
        var f, e2, d;
        if (c.length != 2 && c.length != 3) {
          throw "malformed sJWS: wrong number of '.' splitted elements";
        }
        f = c[0];
        e2 = c[1];
        if (c.length == 3) {
          d = c[2];
        }
        b.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));
        b.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e2));
        b.headerPP = JSON.stringify(b.headerObj, null, "  ");
        if (b.payloadObj == null) {
          b.payloadPP = b64utoutf8(e2);
        } else {
          b.payloadPP = JSON.stringify(b.payloadObj, null, "  ");
        }
        if (d !== void 0) {
          b.sigHex = b64utohex(d);
        }
        return b;
      };
      KJUR.jws.JWS.verifyJWT = function(e2, l, r2) {
        var d = KJUR, j = d.jws, o2 = j.JWS, n2 = o2.readSafeJSONString, p = o2.inArray, f = o2.includedArray;
        if (!isBase64URLDot(e2)) {
          return false;
        }
        var k = e2.split(".");
        if (k.length != 3) {
          return false;
        }
        var c = k[0];
        var i = k[1];
        var q = c + "." + i;
        var m = b64utohex(k[2]);
        var h = n2(b64utoutf8(c));
        var g = n2(b64utoutf8(i));
        if (h.alg === void 0) {
          return false;
        }
        if (r2.alg === void 0) {
          throw "acceptField.alg shall be specified";
        }
        if (!p(h.alg, r2.alg)) {
          return false;
        }
        if (g.iss !== void 0 && typeof r2.iss === "object") {
          if (!p(g.iss, r2.iss)) {
            return false;
          }
        }
        if (g.sub !== void 0 && typeof r2.sub === "object") {
          if (!p(g.sub, r2.sub)) {
            return false;
          }
        }
        if (g.aud !== void 0 && typeof r2.aud === "object") {
          if (typeof g.aud == "string") {
            if (!p(g.aud, r2.aud)) {
              return false;
            }
          } else {
            if (typeof g.aud == "object") {
              if (!f(g.aud, r2.aud)) {
                return false;
              }
            }
          }
        }
        var b = j.IntDate.getNow();
        if (r2.verifyAt !== void 0 && typeof r2.verifyAt === "number") {
          b = r2.verifyAt;
        }
        if (r2.gracePeriod === void 0 || typeof r2.gracePeriod !== "number") {
          r2.gracePeriod = 0;
        }
        if (g.exp !== void 0 && typeof g.exp == "number") {
          if (g.exp + r2.gracePeriod < b) {
            return false;
          }
        }
        if (g.nbf !== void 0 && typeof g.nbf == "number") {
          if (b < g.nbf - r2.gracePeriod) {
            return false;
          }
        }
        if (g.iat !== void 0 && typeof g.iat == "number") {
          if (b < g.iat - r2.gracePeriod) {
            return false;
          }
        }
        if (g.jti !== void 0 && r2.jti !== void 0) {
          if (g.jti !== r2.jti) {
            return false;
          }
        }
        if (!o2.verify(e2, l, r2.alg)) {
          return false;
        }
        return true;
      };
      KJUR.jws.JWS.includedArray = function(b, a) {
        var c = KJUR.jws.JWS.inArray;
        if (b === null) {
          return false;
        }
        if (typeof b !== "object") {
          return false;
        }
        if (typeof b.length !== "number") {
          return false;
        }
        for (var d = 0; d < b.length; d++) {
          if (!c(b[d], a)) {
            return false;
          }
        }
        return true;
      };
      KJUR.jws.JWS.inArray = function(d, b) {
        if (b === null) {
          return false;
        }
        if (typeof b !== "object") {
          return false;
        }
        if (typeof b.length !== "number") {
          return false;
        }
        for (var c = 0; c < b.length; c++) {
          if (b[c] == d) {
            return true;
          }
        }
        return false;
      };
      KJUR.jws.JWS.jwsalg2sigalg = { HS256: "HmacSHA256", HS384: "HmacSHA384", HS512: "HmacSHA512", RS256: "SHA256withRSA", RS384: "SHA384withRSA", RS512: "SHA512withRSA", ES256: "SHA256withECDSA", ES384: "SHA384withECDSA", ES512: "SHA512withECDSA", PS256: "SHA256withRSAandMGF1", PS384: "SHA384withRSAandMGF1", PS512: "SHA512withRSAandMGF1", none: "none" };
      KJUR.jws.JWS.isSafeJSONString = function(c, b, d) {
        var e2 = null;
        try {
          e2 = jsonParse(c);
          if (typeof e2 != "object") {
            return 0;
          }
          if (e2.constructor === Array) {
            return 0;
          }
          if (b) {
            b[d] = e2;
          }
          return 1;
        } catch (a) {
          return 0;
        }
      };
      KJUR.jws.JWS.readSafeJSONString = function(b) {
        var c = null;
        try {
          c = jsonParse(b);
          if (typeof c != "object") {
            return null;
          }
          if (c.constructor === Array) {
            return null;
          }
          return c;
        } catch (a) {
          return null;
        }
      };
      KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(b) {
        var a = b.match(/^[^.]+\.[^.]+\.([^.]+)$/);
        if (a == null) {
          throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
        }
        return a[1];
      };
      KJUR.jws.JWS.getJWKthumbprint = function(d) {
        if (d.kty !== "RSA" && d.kty !== "EC" && d.kty !== "oct") {
          throw "unsupported algorithm for JWK Thumprint";
        }
        var a = "{";
        if (d.kty === "RSA") {
          if (typeof d.n != "string" || typeof d.e != "string") {
            throw "wrong n and e value for RSA key";
          }
          a += '"e":"' + d.e + '",';
          a += '"kty":"' + d.kty + '",';
          a += '"n":"' + d.n + '"}';
        } else {
          if (d.kty === "EC") {
            if (typeof d.crv != "string" || typeof d.x != "string" || typeof d.y != "string") {
              throw "wrong crv, x and y value for EC key";
            }
            a += '"crv":"' + d.crv + '",';
            a += '"kty":"' + d.kty + '",';
            a += '"x":"' + d.x + '",';
            a += '"y":"' + d.y + '"}';
          } else {
            if (d.kty === "oct") {
              if (typeof d.k != "string") {
                throw "wrong k value for oct(symmetric) key";
              }
              a += '"kty":"' + d.kty + '",';
              a += '"k":"' + d.k + '"}';
            }
          }
        }
        var b = rstrtohex(a);
        var c = KJUR.crypto.Util.hashHex(b, "sha256");
        var e2 = hextob64u(c);
        return e2;
      };
      KJUR.jws.IntDate = {};
      KJUR.jws.IntDate.get = function(c) {
        var b = KJUR.jws.IntDate, d = b.getNow, a = b.getZulu;
        if (c == "now") {
          return d();
        } else {
          if (c == "now + 1hour") {
            return d() + 60 * 60;
          } else {
            if (c == "now + 1day") {
              return d() + 60 * 60 * 24;
            } else {
              if (c == "now + 1month") {
                return d() + 60 * 60 * 24 * 30;
              } else {
                if (c == "now + 1year") {
                  return d() + 60 * 60 * 24 * 365;
                } else {
                  if (c.match(/Z$/)) {
                    return a(c);
                  } else {
                    if (c.match(/^[0-9]+$/)) {
                      return parseInt(c);
                    }
                  }
                }
              }
            }
          }
        }
        throw "unsupported format: " + c;
      };
      KJUR.jws.IntDate.getZulu = function(a) {
        return zulutosec(a);
      };
      KJUR.jws.IntDate.getNow = function() {
        var a = ~~(new Date() / 1e3);
        return a;
      };
      KJUR.jws.IntDate.intDate2UTCString = function(a) {
        var b = new Date(a * 1e3);
        return b.toUTCString();
      };
      KJUR.jws.IntDate.intDate2Zulu = function(e2) {
        var i = new Date(e2 * 1e3), h = ("0000" + i.getUTCFullYear()).slice(-4), g = ("00" + (i.getUTCMonth() + 1)).slice(-2), b = ("00" + i.getUTCDate()).slice(-2), a = ("00" + i.getUTCHours()).slice(-2), c = ("00" + i.getUTCMinutes()).slice(-2), f = ("00" + i.getUTCSeconds()).slice(-2);
        return h + g + b + a + c + f + "Z";
      };
      if (typeof KJUR == "undefined" || !KJUR) {
        KJUR = {};
      }
      if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
        KJUR.jws = {};
      }
      KJUR.jws.JWSJS = function() {
        var c = KJUR, b = c.jws, a = b.JWS, d = a.readSafeJSONString;
        this.aHeader = [];
        this.sPayload = "";
        this.aSignature = [];
        this.init = function() {
          this.aHeader = [];
          this.sPayload = void 0;
          this.aSignature = [];
        };
        this.initWithJWS = function(f) {
          this.init();
          var e2 = f.split(".");
          if (e2.length != 3) {
            throw "malformed input JWS";
          }
          this.aHeader.push(e2[0]);
          this.sPayload = e2[1];
          this.aSignature.push(e2[2]);
        };
        this.addSignature = function(e2, h, m, k) {
          if (this.sPayload === void 0 || this.sPayload === null) {
            throw "there's no JSON-JS signature to add.";
          }
          var l = this.aHeader.length;
          if (this.aHeader.length != this.aSignature.length) {
            throw "aHeader.length != aSignature.length";
          }
          try {
            var f = KJUR.jws.JWS.sign(e2, h, this.sPayload, m, k);
            var j = f.split(".");
            var n2 = j[0];
            var g = j[2];
            this.aHeader.push(j[0]);
            this.aSignature.push(j[2]);
          } catch (i) {
            if (this.aHeader.length > l) {
              this.aHeader.pop();
            }
            if (this.aSignature.length > l) {
              this.aSignature.pop();
            }
            throw "addSignature failed: " + i;
          }
        };
        this.verifyAll = function(h) {
          if (this.aHeader.length !== h.length || this.aSignature.length !== h.length) {
            return false;
          }
          for (var g = 0; g < h.length; g++) {
            var f = h[g];
            if (f.length !== 2) {
              return false;
            }
            var e2 = this.verifyNth(g, f[0], f[1]);
            if (e2 === false) {
              return false;
            }
          }
          return true;
        };
        this.verifyNth = function(f, j, g) {
          if (this.aHeader.length <= f || this.aSignature.length <= f) {
            return false;
          }
          var h = this.aHeader[f];
          var k = this.aSignature[f];
          var l = h + "." + this.sPayload + "." + k;
          var e2 = false;
          try {
            e2 = a.verify(l, j, g);
          } catch (i) {
            return false;
          }
          return e2;
        };
        this.readJWSJS = function(g) {
          if (typeof g === "string") {
            var f = d(g);
            if (f == null) {
              throw "argument is not safe JSON object string";
            }
            this.aHeader = f.headers;
            this.sPayload = f.payload;
            this.aSignature = f.signatures;
          } else {
            try {
              if (g.headers.length > 0) {
                this.aHeader = g.headers;
              } else {
                throw "malformed header";
              }
              if (typeof g.payload === "string") {
                this.sPayload = g.payload;
              } else {
                throw "malformed signatures";
              }
              if (g.signatures.length > 0) {
                this.aSignature = g.signatures;
              } else {
                throw "malformed signatures";
              }
            } catch (e2) {
              throw "malformed JWS-JS JSON object: " + e2;
            }
          }
        };
        this.getJSON = function() {
          return { headers: this.aHeader, payload: this.sPayload, signatures: this.aSignature };
        };
        this.isEmpty = function() {
          if (this.aHeader.length == 0) {
            return 1;
          }
          return 0;
        };
      };
      exports.SecureRandom = SecureRandom;
      exports.rng_seed_time = rng_seed_time;
      exports.BigInteger = BigInteger;
      exports.RSAKey = RSAKey;
      exports.ECDSA = KJUR.crypto.ECDSA;
      exports.DSA = KJUR.crypto.DSA;
      exports.Signature = KJUR.crypto.Signature;
      exports.MessageDigest = KJUR.crypto.MessageDigest;
      exports.Mac = KJUR.crypto.Mac;
      exports.Cipher = KJUR.crypto.Cipher;
      exports.KEYUTIL = KEYUTIL;
      exports.ASN1HEX = ASN1HEX;
      exports.X509 = X509;
      exports.X509CRL = X509CRL;
      exports.CryptoJS = CryptoJS;
      exports.b64tohex = b64tohex;
      exports.b64toBA = b64toBA;
      exports.ECFieldElementFp = ECFieldElementFp;
      exports.ECPointFp = ECPointFp;
      exports.ECCurveFp = ECCurveFp;
      exports.stoBA = stoBA;
      exports.BAtos = BAtos;
      exports.BAtohex = BAtohex;
      exports.stohex = stohex;
      exports.stob64 = stob64;
      exports.stob64u = stob64u;
      exports.b64utos = b64utos;
      exports.b64tob64u = b64tob64u;
      exports.b64utob64 = b64utob64;
      exports.hex2b64 = hex2b64;
      exports.hextob64u = hextob64u;
      exports.b64utohex = b64utohex;
      exports.utf8tob64u = utf8tob64u;
      exports.b64utoutf8 = b64utoutf8;
      exports.utf8tob64 = utf8tob64;
      exports.b64toutf8 = b64toutf8;
      exports.utf8tohex = utf8tohex;
      exports.hextoutf8 = hextoutf8;
      exports.hextorstr = hextorstr;
      exports.rstrtohex = rstrtohex;
      exports.hextob64 = hextob64;
      exports.hextob64nl = hextob64nl;
      exports.b64nltohex = b64nltohex;
      exports.hextopem = hextopem;
      exports.pemtohex = pemtohex;
      exports.hextoArrayBuffer = hextoArrayBuffer;
      exports.ArrayBuffertohex = ArrayBuffertohex;
      exports.zulutomsec = zulutomsec;
      exports.zulutosec = zulutosec;
      exports.zulutodate = zulutodate;
      exports.datetozulu = datetozulu;
      exports.uricmptohex = uricmptohex;
      exports.hextouricmp = hextouricmp;
      exports.ipv6tohex = ipv6tohex;
      exports.hextoipv6 = hextoipv6;
      exports.hextoip = hextoip;
      exports.iptohex = iptohex;
      exports.ucs2hextoutf8 = ucs2hextoutf8;
      exports.encodeURIComponentAll = encodeURIComponentAll;
      exports.newline_toUnix = newline_toUnix;
      exports.newline_toDos = newline_toDos;
      exports.hextoposhex = hextoposhex;
      exports.intarystrtohex = intarystrtohex;
      exports.strdiffidx = strdiffidx;
      exports.oidtohex = oidtohex;
      exports.hextooid = hextooid;
      exports.strpad = strpad;
      exports.bitstrtoint = bitstrtoint;
      exports.inttobitstr = inttobitstr;
      exports.bitstrtobinstr = bitstrtobinstr;
      exports.binstrtobitstr = binstrtobitstr;
      exports.isBase64URLDot = isBase64URLDot;
      exports.namearraytobinstr = namearraytobinstr;
      exports.extendClass = extendClass;
      exports.KJUR = KJUR;
      exports.crypto = KJUR.crypto;
      exports.asn1 = KJUR.asn1;
      exports.jws = KJUR.jws;
      exports.lang = KJUR.lang;
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    AppActions: () => AppActions,
    ChannelActions: () => ChannelActions,
    ForwardingActions: () => ForwardingActions,
    MemberActions: () => MemberActions,
    PublicationActions: () => PublicationActions,
    SfuBotActions: () => SfuBotActions,
    SfuSubscriptionActions: () => SfuSubscriptionActions,
    SkyWayAuthToken: () => SkyWayAuthToken,
    SubscriptionActions: () => SubscriptionActions,
    nowInSec: () => nowInSec,
    tokenErrors: () => tokenErrors,
    uuidV4: () => uuidV4
  });
  init_process();

  // node_modules/uuid/dist/esm-browser/index.js
  init_process();

  // node_modules/uuid/dist/esm-browser/rng.js
  init_process();
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/stringify.js
  init_process();
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // node_modules/uuid/dist/esm-browser/v4.js
  init_process();

  // node_modules/uuid/dist/esm-browser/native.js
  init_process();
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // src/encoder.ts
  init_process();

  // ../common/src/index.ts
  init_process();

  // ../common/src/error.ts
  init_process();

  // ../common/src/logger.ts
  init_process();
  var logLevelTypes = [
    "disable",
    "error",
    "warn",
    "info",
    "debug"
  ];
  var _Logger = class {
    constructor(prefix) {
      this.debug = (...msg) => {
        this._log("debug", ...msg);
        return Date.now();
      };
      this.info = (...msg) => {
        this._log("info", ...msg);
        return Date.now();
      };
      this.warn = (...msg) => {
        this._log("warn", ...msg);
      };
      this.error = (...msg) => {
        this._log("error", ...msg);
      };
      this.elapsed = (timestamp, ...msg) => {
        const elapsed = Date.now() - timestamp;
        this._log("info", `elapsed ms:${elapsed}`, ...msg);
      };
      this.prefix = prefix;
    }
    _log(level, ...msg) {
      const logType = logLevelTypes.indexOf(level);
      const logLevel = logLevelTypes.indexOf(_Logger.level);
      if (logLevel >= logType) {
        const timestamp = new Date(Date.now() + 60 * 9 * 6e4).toISOString() + "+JST";
        const parsed = [this.prefix, ...msg].map((m) => {
          if (m instanceof Error) {
            if (m.toJSON) {
              return m.toJSON();
            }
            return { name: m.name, message: m.message, stack: m.stack };
          }
          if (typeof m === "object") {
            try {
              return JSON.parse(JSON.stringify(m));
            } catch (error) {
              return "json error";
            }
          }
          return m;
        });
        msg = parsed;
        let log6 = [timestamp, level, ...msg];
        if (_Logger.format === "string") {
          log6 = [timestamp + " " + level + " " + JSON.stringify(msg)];
        }
        switch (level) {
          case "debug":
            console.log(...log6);
            break;
          case "info":
            console.info(...log6);
            break;
          case "warn":
            console.warn(...log6);
            break;
          case "error":
            console.error(...log6);
            break;
        }
        _Logger.onLog({ id: _Logger.id, timestamp, level, message: msg });
      }
    }
    createBlock(info) {
      return {
        warn: (...msg) => {
          this.warn(__spreadValues({}, info), ...msg);
        },
        debug: (...msg) => {
          this.debug(__spreadValues({}, info), ...msg);
        },
        info: (...msg) => {
          this.info(__spreadValues({}, info), ...msg);
        },
        error: (...msg) => {
          this.error(__spreadValues({}, info), ...msg);
        }
      };
    }
  };
  var Logger = _Logger;
  Logger.level = "error";
  Logger.format = "object";
  Logger.onLog = () => {
  };
  Logger.id = Math.random().toString().slice(2, 7);

  // ../common/src/error.ts
  var log = new Logger("packages/common/src/error.ts");
  var SkyWayError = class extends Error {
    constructor(init, logging = true) {
      super(init.info.detail);
      this.id = Math.random().toString().slice(2, 10);
      Object.assign(this, init);
      this.name = this.info.name;
      if (logging) {
        const messages = [
          "SkyWayError",
          `name:${this.info.name}, detail:${this.info.detail}, solution:${this.info.solution}`
        ];
        if (this.path) {
          messages.push(this.path);
        }
        if (this.error) {
          messages.push(this.error);
        }
        if (this.payload) {
          messages.push(this.payload);
        }
        messages.push(this.id);
        log.warn(...messages);
      }
    }
    toJSON() {
      return {
        id: this.id,
        info: this.info,
        path: this.path,
        payload: this.payload,
        error: this.error,
        stack: this.stack
      };
    }
  };

  // ../common/src/event.ts
  init_process();
  var log2 = new Logger("packages/common/src/event.ts");

  // ../common/src/http.ts
  init_process();
  var log3 = new Logger("packages/common/src/http.ts");

  // ../common/src/promise.ts
  init_process();
  var log4 = new Logger("packages/common/src/promise.ts");

  // ../common/src/util.ts
  init_process();

  // src/encoder.ts
  var import_jsrsasign = __toESM(require_jsrsasign());

  // ../../node_modules/jwt-decode/build/jwt-decode.esm.js
  init_process();
  function e(e2) {
    this.message = e2;
  }
  e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
  var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if ("string" != typeof e2)
      throw new n("Invalid token specified");
    var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
  var jwt_decode_esm_default = o;

  // src/encoder.ts
  var log5 = new Logger("packages/token/src/encoder.ts");
  var SkyWayAuthToken = class {
    constructor(props) {
      Object.assign(this, props);
    }
    static Decode(token) {
      try {
        const props = jwt_decode_esm_default(token);
        const authToken = new SkyWayAuthToken(props);
        authToken.tokenString = token;
        return authToken;
      } catch (error) {
        throw new SkyWayError({
          path: log5.prefix,
          info: tokenErrors.invalidParameter,
          error
        });
      }
    }
    encode(secret) {
      const payload = {
        jti: this.jti,
        iat: this.iat,
        exp: this.exp,
        scope: this.scope
      };
      this.tokenString = import_jsrsasign.default.KJUR.jws.JWS.sign(
        "HS256",
        JSON.stringify({ alg: "HS256", typ: "JWT" }),
        JSON.stringify(payload),
        secret
      );
      return this.tokenString;
    }
    toJSON() {
      return {
        jti: this.jti,
        iat: this.iat,
        exp: this.exp,
        scope: this.scope,
        encoded: this.tokenString
      };
    }
  };

  // src/scope/app.ts
  init_process();
  var AppActions = ["listChannels", "read", "write"];
  var ChannelActions = [
    "write",
    "read",
    "create",
    "delete",
    "updateMetadata"
  ];
  var MemberActions = [
    "write",
    "create",
    "delete",
    "updateMetadata",
    "signal"
  ];
  var PublicationActions = [
    "write",
    "create",
    "delete",
    "updateMetadata",
    "enable",
    "disable"
  ];
  var SubscriptionActions = ["write", "create", "delete"];

  // src/scope/sfu.ts
  init_process();
  var SfuBotActions = ["create", "write", "delete"];
  var ForwardingActions = ["create", "write", "delete"];
  var SfuSubscriptionActions = ["create", "write", "delete"];

  // src/token.ts
  init_process();

  // src/errors.ts
  init_process();
  var tokenErrors = {
    invalidParameter: {
      name: "invalidParameter",
      detail: "failed to decode token",
      solution: "Use the correct token according to the specification"
    }
  };

  // src/util.ts
  init_process();
  var nowInSec = () => Math.floor(Date.now() / 1e3);

  // src/index.ts
  var uuidV4 = v4_default;
  return __toCommonJS(src_exports);
})();
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
/*! (c) Tom Wu, Kenji Urushima | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */

/*
@skyway-sdk/common@1.4.1

MIT

https://github.com/skyway/js-sdk

MIT License

Copyright (c) 2023 NTT Communications Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


---

@skyway-sdk/token@1.4.1

MIT

https://github.com/skyway/js-sdk

MIT License

Copyright (c) 2023 NTT Communications Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


---

axios@0.23.0

MIT

https://github.com/axios/axios

Copyright (c) 2014-present Matt Zabriskie

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


---

follow-redirects@1.15.2

MIT

https://github.com/follow-redirects/follow-redirects

Copyright 2014–present Olivier Lalonde <olalonde@gmail.com>, James Talmage <james@talmage.io>, Ruben Verborgh

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


---

jsrsasign@10.8.6

MIT

https://github.com/kjur/jsrsasign

---

jwt-decode@3.1.2

MIT

https://github.com/auth0/jwt-decode

The MIT License (MIT)
 
Copyright (c) 2015 Auth0, Inc. <support@auth0.com> (http://auth0.com)
 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
 
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


---

uuid@9.0.0

MIT

https://github.com/uuidjs/uuid

The MIT License (MIT)

Copyright (c) 2010-2020 Robert Kieffer and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


---

*/